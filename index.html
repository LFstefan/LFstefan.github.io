<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|comic sans:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="染心" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一只奋进的小菜鸟">
<meta property="og:type" content="website">
<meta property="og:title" content="染心">
<meta property="og:url" content="https://lfstefan.github.io/index.html">
<meta property="og:site_name" content="染心">
<meta property="og:description" content="一只奋进的小菜鸟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="染心">
<meta name="twitter:description" content="一只奋进的小菜鸟">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lfstefan.github.io/"/>





  <title>染心</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>
    <a href="https://github.com/LFstefan"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">染心</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Coding Everyday</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lfstefan.github.io/2018/07/08/Zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="染心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/08/Zookeeper/" itemprop="url">
                  Zookeeper
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T12:21:25+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">Zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/07/08/Zookeeper/" class="leancloud_visitors" data-flag-title="Zookeeper">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ul>
<li>What is Zookeeper ?</li>
<li>Why use Zookeeper ?</li>
<li>Theory</li>
<li>Leader Election </li>
<li>Deploy </li>
<li>How to use ?<ul>
<li>Command Line</li>
<li>API</li>
<li>Curator</li>
</ul>
</li>
</ul>
<h3 id="What-is-Zookeeper"><a href="#What-is-Zookeeper" class="headerlink" title="What is Zookeeper ?"></a>What is Zookeeper ?</h3><blockquote>
<p>ZK被多数人认为是一个注册中心，在分布式架构中像服务提供者和服务消费者之间的一个枢纽站，服务提供者将服务注册在注册中心以供服务消费者来获取消费，支持一对一，一对多，多对一，多对多等模式，其原理简单来讲，就是服务提供者在注册中心注册自己的服务地址，并通过一定端口将自己的服务暴露出去，消费者想要使用提供者所提供的服务时，首先需要去注册中心匹配相应的服务以获取该具体服务提供的地址，然后才能去访问该服务提供者以消费该服务，多对多模式中，如果同一时间消费者大量的涌入注册中心去访问同一服务，ZK还具有负载均衡的作用来有效的分配大量的请求流量。 </p>
</blockquote>
<h3 id="Why-use-Zookeeper"><a href="#Why-use-Zookeeper" class="headerlink" title="Why use Zookeeper ?"></a>Why use Zookeeper ?</h3><blockquote>
<p>问：为什么不直接用消费者去调用服务提供者，加一层类似中间件的注册中心有什么好处，有哪些实际应用场景，即ZK存在的理由 ?</p>
</blockquote>
<p>答：首先明确一点，就是所有的中间件的诞生都是基于将某些公共的，重复的内容抽取出来简化过程，ZK的诞生同样也不例外。 </p>
<ul>
<li><p>集群的管理：所谓集群管理，无外乎两点，是否有机器加入和退出，选举master，ZK的leader选举规则（此处为超链接）。 </p>
</li>
<li><p>公共配置的管理：分布式环境或者是集群环境中，将同一个应用系统部署到多台服务器上，或者一个应用系统需要多台服务器一起运行是非常常见的情况，那么一定会存在大量的配置是公共的，重复性的存在于多台服务器上，一旦配置发生变动，那配置的更改将变得非常繁琐，并且容易出现错误，这时我们就想要将所有的公共的配置全部都提取出来共同维护，ZK将所有的公共配置全部注册到它的服务器上，并且让所有用到该配置的其他服务启用监听，每当ZK服务器上的配置发生变动时，所有监听的服务就会收到ZK的通知，然后监听服务只需要从ZK服务器更新配置文件即可，免去了人工手动更改大量重复配置文件的繁琐操作，同时也降低了错误发生的概率。 </p>
</li>
<li><p>共享锁/分布式锁：锁服务可以分为两类，一种是独占锁，一种是时序锁。 </p>
</li>
</ul>
<blockquote>
<p>在同一个进程中锁往往很容易实现，但是在跨进程和跨服务之间就不容易实现了，因为感知其他进程和服务的锁的使用情况变得复杂，但是Zookeeper 却很容易实现这个功能，因为它可以将各个进程或者服务对锁的使用情况再次变得简单起来 </p>
</blockquote>
<ol>
<li><p>利用节点名称唯一性来实现 </p>
<ul>
<li>思路: 利用名称唯一性，加锁操作时，只需要所有客户端一起创建/test/Lock节点，只有一个创建成功，成功者获得锁。解锁时，只需删除/test/Lock节点，其余客户端再次进入竞争创建节点，直到所有客户端都获得锁。 </li>
<li>缺点：会产生“惊群”效应，假如许多客户端在等待一把锁，当锁释放时候所有客户端都被唤醒，仅仅有一个客户端得到锁。 </li>
</ul>
</li>
<li><p>利用临时顺序节点来实现 </p>
<blockquote>
<p>Zookeeper中有一种节点叫做顺序节点ZooKeeper中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端与ZooKeeper集群断开连接，则开节点自动被删除。 </p>
</blockquote>
<ul>
<li>客户端调用create()方法创建名为“locknode/guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。 </li>
<li>客户端调用getChildren(“locknode”)方法来获取所有已经创建的子节点，同时在这个节点上注册上子节点变更通知的Watcher。客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么就认为这个客户端获得了锁。 </li>
<li>如果在步骤3中发现自己并非是所有子节点中最小的，说明自己还没有获取到锁，就开始等待，直到下次子节点变更通知的时候，再进行子节点的获取，判断是否获取锁。 </li>
</ul>
</li>
<li><p>临时顺序节点改进 </p>
<blockquote>
<p>方法2的缺点：客户端接受到过多的和自己不相关的事件通知，这如果在集群规模大的时候，会对Server造成很大的性能影响，并且如果一旦同一时间有多个节点的客户端断开连接，这个时候，服务器就会像其余客户端发送大量的事件通知——这就是所谓的惊群效应。 </p>
</blockquote>
<ul>
<li>改进：由原来的监视所有节点变成监视一个节点。 </li>
<li>思路：对于加锁操作，可以让所有客户端都去/lock目录下创建临时顺序节点，如果创建的客户端发现自身创建节点序列号是/lock/目录下最小的节点，则获得锁。否则，监视比自己创建节点的序列号小的节点（比自己创建的节点小的最大节点），进入等待。 </li>
</ul>
</li>
<li><p>释放锁很简单，只要删除前面它自己所创建的目录节点就行了。 </p>
</li>
</ol>
<h3 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h3><ul>
<li>ZK中的角色定义： <ul>
<li>server角色 <ol>
<li>Leader：负责投票的发起和决议，更新系统状态 </li>
<li>Flower：接收客户请求并返回结果，在选主过程过程中参与投票 </li>
<li>Observe：接收客户端请求，转发给leader，且不参与选主过程，只是同步leader状态。其存在目的是为了扩展系统，提高读取速度。 </li>
</ol>
</li>
<li>Client角色 <ol>
<li>Client：发送请求 </li>
</ol>
</li>
</ul>
</li>
<li><p>工作原理： </p>
<blockquote>
<p>我们知道各服务是通过启用监听来保持和ZK服务器上公共配置的一致性，但是ZK内部自己是如何保持在集群状态下的各个leader和flower之间的同步以及leader的产生，即选主。 </p>
</blockquote>
</li>
<li><p>对应着ZK中两种模式来分别实现，恢复模式：即在集群平衡状态被打破后需要重新选举产生leader并完成选举后的同步；广播模式：即集群在平衡状态下leader与各flower之间的同步。 </p>
<blockquote>
<ul>
<li>为了保证事务的顺序一致性，zookeeper 采用了递增的事务 id 号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了 zxid。实现中 zxid 是一个 64 位的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增。 </li>
<li>ZXID=32(高位epoch，leader编号)+32（低位proposal事务编号） </li>
<li>这里的事务主要指的是写请求，因为读请求不会导致节点数据更新，即不会引发同步操作，只有当遇到写请求时才会导致同步发生，并且，flower只有处理读请求的权限，当遇到写请求时，flower会将请求转发给leader来处理，然后由leader来发起同步操作更新集群状态。 </li>
</ul>
</blockquote>
</li>
<li><p>消息广播 </p>
<ul>
<li>集群正常运转情况下：消息广播协议，当flower接受到数据改动请求，及写请求后，会将其转发给leader，然后leader将其请求以事务 的形式广播发给所有的flower，flower收到后以事务日志的形式存入本地磁盘，成功写入后然后回传给leader一个ack消息，leader收到ack响应后并且响应数量超过半数服务器数量后，便继续广播一个commit提交事务给所有的flower，flower收到后开始提交事务，同时leader也开始提交事务，以此达到数据同步的效果。 </li>
</ul>
</li>
<li><p>崩溃恢复 </p>
<ul>
<li>Leader宕机之后如何恢复并选举出新的leader：首先，leader宕机后或者TCP连接中断后，所有的flower和leader均变成looking状态，即选举leader状态。 </li>
<li>从所有的flower中选出ZXID最大的作为新leader，因为新leader上任后需要应对缺失事务proposal补充和多余事务的丢弃，而由于ZXID 为一个全局的唯一ID，ZXID 最大意味着最高事务编号，也就意味着其包含了所有的成功已提交事务，省去了检查事务提交和缺失丢弃的步骤。 </li>
<li>Leader选举后的数据同步和数据丢弃 <ul>
<li>数据同步：leader将那些flower没有的事务proposal通过队列下发给所有的flower，flower将其同步到本地数据库中，成功后leader将其列入可用flower列表中。 </li>
<li>数据丢弃：leader根据自己的proposal和flower和proposal比较，结果必然是flower进行回退，丢弃自己的proposal，回退到一个集群中过半数flower提交的最新的事务proposal。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h3><blockquote>
<p>首先明确zookeeper选举规则的先决条件; 可用节点数量 &gt; 总节点数量/2  。注意 是 &gt; , 不是 ≥。 </p>
</blockquote>
<p>注：为什么规则要求 可用节点数量 &gt; 集群总结点数量/2 ？（为什么集群数量一般为奇数）   </p>
<ul>
<li>如果不这样限制，在集群出现脑裂的时候，可能会出现多个子集群同时服务的情况（即子集群各组选举出自己的leader）， 这样对整个zookeeper集群来说是紊乱的。 </li>
<li>换句话说，如果遵守上述规则进行选举，即使出现脑裂，集群最多也只能回出现一个子集群可以提供服务的情况（能满足节点数量&gt; 总结点数量/2 的子集群最多只会有一个）。所以要限制 可用节点数量 &gt; 集群总结点数量/2 。 </li>
<li>什么是脑裂？集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。 </li>
</ul>
<p><a href="https://zookeeper.apache.org/doc/current/recipes.html" title="Zookeeper.LeaderElection" target="_blank" rel="external">官方文档地址：https://zookeeper.apache.org/doc/current/recipes.html </a></p>
<p>内容如下： </p>
<blockquote>
<p>Leader Election<br>A simple way of doing leader election with ZooKeeper is to use the SEQUENCE|EPHEMERAL flags when creating znodes that represent “proposals” of clients. The idea is to have a znode, say “/election”, such that each znode creates a child znode “/election/n<em>“ with both flags SEQUENCE|EPHEMERAL. With the sequence flag, ZooKeeper automatically appends a sequence number that is greater that any one previously appended to a child of “/election”. The process that created the znode with the smallest appended sequence number is the leader.<br>That’s not all, though. It is important to watch for failures of the leader, so that a new client arises as the new leader in the case the current leader fails. A trivial solution is to have all application processes watching upon the current smallest znode, and checking if they are the new leader when the smallest znode goes away (note that the smallest znode will go away if the leader fails because the node is ephemeral). But this causes a herd effect: upon of failure of the current leader, all other processes receive a notification, and execute getChildren on “/election” to obtain the current list of children of “/election”. If the number of clients is large, it causes a spike on the number of operations that ZooKeeper servers have to process. To avoid the herd effect, it is sufficient to watch for the next znode down on the sequence of znodes. If a client receives a notification that the znode it is watching is gone, then it becomes the new leader in the case that there is no smaller znode. Note that this avoids the herd effect by not having all clients watching the same znode.<br>Here’s the pseudo code:<br>Let ELECTION be a path of choice of the application. To volunteer to be a leader:<br>Create znode z with path “ELECTION/n</em>“ with both SEQUENCE and EPHEMERAL flags;<br>Let C be the children of “ELECTION”, and i be the sequence number of z;<br>Watch for changes on “ELECTION/n_j”, where j is the largest sequence number such that j &lt; i and n_j is a znode in C;<br>Upon receiving a notification of znode deletion:<br>Let C be the new set of children of ELECTION;<br>If z is the smallest node in C, then execute leader procedure;<br>Otherwise, watch for changes on “ELECTION/n_j”, where j is the largest sequence number such that j &lt; i and n_j is a znode in C;<br>Note that the znode having no preceding znode on the list of children does not imply that the creator of this znode is aware that it is the current leader. Applications may consider creating a separate znode to acknowledge that the leader has executed the leader procedure. </p>
</blockquote>
<ul>
<li>大意为：选举的一种简单方式为利用ZK中的临时顺序节点，具体思路为有一个名为/election的节点，然后所有节点开始在该节点下创建子节点/election/n_，类型为临时顺序节点，创建成功后ZK自动在节点后衔接一个顺序号，顺序号最小的即为leader，同时，所有节点启动对/election节点的监视，当该节点发生变动时，检测自己的节点顺序号是否为最小，是则晋升为leader，否则继续监视。 </li>
<li>与分布式锁遇到的问题雷同，所有节点监视/election节点，相当于监视所有节点在该节点下的子节点，当该节点发生变动时，所有节点都会接收到通知，但其实只有一个节点晋升为leader，意味着其他节点会接受到大量的无用通知，当服务器数量较为庞大时，便会引起”惊群效应”。改进措施同样与分布式锁解决方案一样，将对/election节点的监视更改为对该节点下顺序号比自己小的最大节点的监视。可对比分布式锁理解。 </li>
</ul>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><ul>
<li><p>单机模式：</p>
<ul>
<li><p>下载zookeeper到本地（PC端），解压后可看到zookeeper的目录结构，/bin中存放着一些.sh或者.cmd的命令（如启动服务器命令和客户端连接服务器命令等），/conf中存放着配置文件，其中有一个zoo.sample.cfg的配置文件，我们需要将其复制一份命名为zoo.cfg，然后在其中添加两行（官网说默认在日志和数据存放在一个文件中，但是考虑到性能问题，建议还是分开存放） </p>
<blockquote>
<p>dataDir=../data     用于存放snapshot文件<br>dataLogDir=../log   用于存放日志log文件 </p>
</blockquote>
</li>
<li><p>客户端端口默认为2181，一般无需修改，除非自己本机出现端口占用问题 。clientPort=2181 </p>
</li>
<li>我们下载的zookeeper文件夹中有一个zookeeper.jar包，我们可以理解为zookeeper的客户端API，我们可以将该jar包导入工程项目中来连接zookeeper的服务器并对其进行相关操作。 </li>
<li>还有一个客户端我们可以使用——Curator（<a href="https://curator.apache.org/）" target="_blank" rel="external">https://curator.apache.org/）</a> </li>
</ul>
</li>
<li><p>集群模式：</p>
<ul>
<li>在不同的服务器上分别安装zookeeper，并对其进行相关配置，在zoo.cfg配置文件中我们需要加上相同的几行配置（下面的意思为让zookeeper的集群服务器之间相互知道对方的存在，由于在不同的服务器上，所以端口号无需修改，但是服务器ip一定不能相同） <blockquote>
<p>server.1=server.ip1:2888:3888<br>server.2=server.ip2:2888:3888<br>server.3=server.ip3:2888:3888 </p>
</blockquote>
</li>
<li>然后我们还需要在存放snapshot文件的data文件夹中创建myid文件并在其中写入一行配置，即自己的服务器序号，就是配置文件中自己ip前面的服务器序号（server.1的1，其范围是1到255） </li>
</ul>
</li>
<li><p>伪集群模式：</p>
<ul>
<li>即在一个物理服务器上搭建多个逻辑上的zookeeper集群，其部署方式与真正集群相似，不同的是在同一个服务器上，所以配置文件中的ip均相同，但是端口号需要改为不同的端口号，其余均与集群配置一致。 <blockquote>
<p>server.1=server.ip:2888:3888<br>server.2=server.ip:2889:3889<br>server.3=server.ip:2890:3890 </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use ?"></a>How to use ?</h3><ul>
<li><h3 id="命令行指令"><a href="#命令行指令" class="headerlink" title="命令行指令"></a>命令行指令</h3><blockquote>
<p>在ZK中，ZK客户端对服务器每一个数据节点的写操作，ZK会认为都是一次完整的事务操作，要么成功，要么失败，保证了数据的原子性。而每次事务都会分配一个唯一的事务id，以标识这次事务操作的数据信息。下面详细理解一下节点状态各个字段的含义：<br>cZxid：创建节点的事务id<br>ctime：创建节点的时间<br>mZxid：修改节点的事务id<br>mtime：修改节点的时间<br>pZxid：子节点列表最后一次修改的事务id。删除或添加子节点，不包含修改子节点的数据。<br>cversion：子节点的版本号，删除或添加子节点，版本号会自增<br>dataVersion：节点数据版本号，数据写入操作，版本号会递增<br>aclVersion：节点ACL权限版本，权限写入操作，版本号会递增<br>ephemeralOwner：临时节点创建时的事务id，如果节点是永久节点，则它的值为0<br>dataLength：节点数据长度（单位：byte），中文占3个byte<br>numChildren：子节点数量 </p>
</blockquote>
<ul>
<li>服务器启动命令：./zkServer.sh start </li>
<li>服务器检测状态：./zkServer.sh status     </li>
<li>客户端连接本地服务器：./zkCli.sh -server 127.0.0.1:2181 </li>
<li>显示节点：ls /（或者ls2 /） </li>
<li>创建节点：create /liufein（节点名） liufei（节点值） </li>
<li>获取节点信息：get /liufein </li>
<li>设置节点信息：set /liufein stefan（节点新值）【信息中数据版本字段会随着数据更改次数而自增】 </li>
<li>删除节点信息：delete /liufein（子节点不为空不能删除）删除节点命令，此命令与delete命令不同的是delete不可删除有子节点的节点，但是rmr命令可以删除，注意路径为绝对路径。该命令现在也可执行，但会有提示使用deleteall命令来替代 </li>
<li>查看节点状态信息。如stat /zookeeper </li>
<li>显示配额：如listquota /zookeeper </li>
<li>查看节点权限Acl：如getAcl /zookeeper/node1 </li>
<li><p>SetAcl命令，设置权限 </p>
<blockquote>
<p>（ACL权限控制:注意:删除权限的作用范围为其子节点，而非其本身，意味着当你给某一节点设置了删除权限后，你依然可以随意的删除该节点，但是其子节点不能。） </p>
</blockquote>
<ul>
<li>acl由三部分组成：1为scheme，2为user，3为permission，一般情况下表示为scheme:id:permissions。 </li>
<li>world: 它下面只有一个id, 叫anyone, world:anyone代表任何人，zookeeper中对所有人有权限的结点就是属于world:anyone的 </li>
<li>auth: 它不需要id, 只要是通过authentication的user都有权限（zookeeper支持通过kerberos来进行authencation, 也支持username/password形式的authentication) </li>
<li>digest: 它对应的id为username:BASE64(SHA1(password))，它需要先通过username:password形式的authentication。（由于使用digest时，密码会经过SHA1和BASE64的两层编码转换，所以我们可以使用命令：echo -n lf:lf | openssl dgst -binary -sha1 | openssl base64用于输出密码所对应的BASE64(SHA1(password))编码之后的值，然后使用该值进行权限的设置，这样在我们使用授权的时候就可以直接使用编码前的字符，避免使用编码后的复杂难记忆的字符，例如setAcl /liufein digest:lf:shTM7tNH6fVkpZWS9MbSN6xaJEM=:rwdca设置授权命令，addauth digest lf:lf添加权限命令） </li>
<li>ip: 它对应的id为客户机的IP地址，设置的时候可以设置一个ip段，比如ip:192.168.1.0/16, 表示匹配前16个bit的IP段 </li>
<li>super: 在这种scheme情况下，对应的id拥有超级权限，可以做任何事情(cdrwa) </li>
<li><p>Permissions </p>
<ol>
<li>CREATE(c): 创建权限，可以在在当前node下创建child node </li>
<li>DELETE(d): 删除权限，可以删除当前的node </li>
<li>READ(r): 读权限，可以获取当前node的数据，可以list当前node所有的child nodes </li>
<li>WRITE(w): 写权限，可以向当前node写数据 </li>
<li>ADMIN(a): 管理权限，可以设置当前node的permission </li>
</ol>
<blockquote>
<p>综上，一个简单使用setAcl命令，则可以为：setAcl/zookeeper/node1 world:anyone:cdrw </p>
</blockquote>
</li>
</ul>
</li>
<li><p>Digest:先设置权限，其中密码使用的是编码的格式setAcl /zookeeper digest:username:BASE64(SHA1(password)):rwadc然后添加访问权限，此时密码使用的明文字符addauth digest lf:lf添加权限后才能进行相关操作 </p>
</li>
<li>Auth：先添加权限，密码为明文addauth digest username:password然后设置权限，密码同样为明文setAcl /zookeeper auth:username:passeword:rwadc </li>
<li>可以添加监听watajch的命令有(即可以使用以下命令来设置watch) <ul>
<li>Stat path [watch] </li>
<li>Ls path [watch] </li>
<li>Ls2 path [watch] </li>
<li>Get path [watch] </li>
</ul>
</li>
</ul>
</li>
<li><h3 id="API使用指南"><a href="#API使用指南" class="headerlink" title="API使用指南"></a>API使用指南</h3></li>
</ul>
<blockquote>
<ul>
<li>API官方地址：<a href="https://zookeeper.apache.org/doc/r3.4.6/api/org/apache/zookeeper/ZooKeeper.html" target="_blank" rel="external">https://zookeeper.apache.org/doc/r3.4.6/api/org/apache/zookeeper/ZooKeeper.html</a> </li>
<li>Zk中为我们提供了一个原生的jar包来供我们依赖使用，其位置就在/zookeeper/下</li>
</ul>
</blockquote>
<p>我们在开发环境中，新建工程，将其导入即可使用其来操作zk服务器中节点数据，如下为简单的一些实际操作 </p>
<ul>
<li><p>连接zk </p>
<ul>
<li>客户端和zk服务端链接是一个异步的过，当连接成功后后，客户端会收的一个watch通知 </li>
<li>参数：connectString：连接服务器的ip字符串，比如: “192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181”可以是一个ip，也可以是多个ip，一个ip代表单机，多个ip代表集群，也可以在ip后加路径 </li>
<li>sessionTimeout：超时时间，心跳收不到了，那就超时 </li>
<li>watcher：通知事件，如果有对应的事件触发，则会收到一个通知；如果不需要，那就设置为null </li>
<li>canBeReadOnly：可读，当这个物理机节点断开后，还是可以读到数据的，只是不能写，此时数据被读取到的可能是旧数据，此处建议设置为false，不推荐使用 </li>
<li>sessionId：会话的id </li>
<li><p>sessionPasswd：会话密码    当会话丢失后，可以依据 sessionId 和 sessionPasswd 重新获取会话 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(ZK_SERVER_PATH, TIME_OUT, <span class="keyword">new</span> ZKConnection()); </div><div class="line"><span class="keyword">long</span> sessionId = zk.getSessionId(); </div><div class="line"><span class="keyword">byte</span>[] sessionPassword = zk.getSessionPasswd(); </div><div class="line">ZooKeeper zkSession = <span class="keyword">new</span> ZooKeeper(ZK_SERVER_PATH,TIME_OUT,<span class="keyword">new</span> ZKConnection(), sessionId,sessionPassword);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>节点创建 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * 同步或者异步创建节点，都不支持子节点的递归创建，异步有一个callback函数 </div><div class="line">     * 参数： </div><div class="line">     * path：创建的路径 </div><div class="line">     * data：存储的数据的byte[] </div><div class="line">     * acl：控制权限策略 </div><div class="line">     *             Ids.OPEN_ACL_UNSAFE --&gt; world:anyone:cdrwa </div><div class="line">     *             CREATOR_ALL_ACL --&gt; auth:user:password:cdrwa </div><div class="line">     * createMode：节点类型, 是一个枚举 </div><div class="line">     *             PERSISTENT：持久节点 </div><div class="line">     *             PERSISTENT_SEQUENTIAL：持久顺序节点 </div><div class="line">     *             EPHEMERAL：临时节点 </div><div class="line">     *             EPHEMERAL_SEQUENTIAL：临时顺序节点 </div><div class="line">     */ </div><div class="line">    <span class="comment">/*同步创建*/</span> </div><div class="line">    result = zookeeper.create(path, data, acls, CreateMode.PERSISTENT);</div><div class="line">    <span class="comment">/*异步创建*/</span> </div><div class="line">    String ctx = <span class="string">"&#123;'create':'success'&#125;"</span>; </div><div class="line">    zookeeper.create(path, data, acls, CreateMode.PERSISTENT, <span class="keyword">new</span> CreateCallBack(), ctx); </div><div class="line">``` </div><div class="line"></div><div class="line">- Callback回调函数： </div><div class="line">	- 通知和回调的区别： </div><div class="line">	- 通知是ZooKeeper中注册了监视点的客户端收到的事件报告消息 </div><div class="line">	- 回调是基于异步思想的,通过回调函数来确定操作的完成情况 </div><div class="line">	</div><div class="line">	&gt; ZK中回调函数均由某些接口定义，我们需要实现该接口，并实现其中的processResult方法，其中接口的实现随功能而定，如以下创建和删除方法中的回调接口便不一致（方法内参数也不同），具体可参考官方API </div><div class="line"></div><div class="line">	- 参数中有一个Object ctx，该参数为回调信息，类型为Object意味着回调类型可以为任意类型。 </div><div class="line">	</div><div class="line">	```<span class="function">java</span></div><div class="line">	<span class="title">create</span><span class="params">(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode, AsyncCallback.StringCallback cb, Object ctx)</span> </div><div class="line">	<span class="title">delete</span><span class="params">(String path, <span class="keyword">int</span> version, AsyncCallback.VoidCallback cb, Object ctx)</span></div></pre></td></tr></table></figure>
</li>
<li><p>Watcher通知事件： </p>
</li>
</ul>
<blockquote>
<p>ZooKeeper中实现对接点的监控,需要实现Watcher接口类,实现其中的process方法 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatcherDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123; </div><div class="line">             监视事件发生后进行的操作 </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>监视事件的设置，如： </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Zookeeper.exists(String path, Watcher watcher)方法， </div><div class="line">具体使用为：Zookeeper.exists(<span class="string">"/dubbo"</span>, <span class="keyword">new</span> WatcherDemo() )</div></pre></td></tr></table></figure>
<blockquote>
<p>意味着给节点/dubbo实行监视，当他存在即创建时，监视事件WatcherDemo被触发，引发该类的process()方法被执行。其余均类似，可参考官方API中具体有那些方法可以设置通知事件Watcher </p>
</blockquote>
<ul>
<li><p>权限设置 </p>
<ul>
<li><p>任何人可以访问：   </p>
<figure class="highlight java"><figcaption><span>zkServer.createZKNode("/aclimooc", "test".getBytes(), Ids.OPEN_ACL_UNSAFE); </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">	</div></pre></td></tr></table></figure>
</li>
<li><p>自定义用户认证访问： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;(); </div><div class="line">Id imooc1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>,DigestAuthenticationProvider.generateDigest(<span class="string">"imooc1:123456"</span>)); </div><div class="line">Id imooc2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>,DigestAuthenticationProvider.generateDigest(<span class="string">"imooc2:123456"</span>)); </div><div class="line">acls.add(<span class="keyword">new</span> ACL(Perms.ALL, imooc1)); </div><div class="line">acls.add(<span class="keyword">new</span> ACL(Perms.READ, imooc2)); </div><div class="line">acls.add(<span class="keyword">new</span> ACL(Perms.DELETE | Perms.CREATE, imooc2)); </div><div class="line">zkServer.createZKNode(<span class="string">"/aclimooc/testdigest"</span>, <span class="string">"testdigest"</span>.getBytes(), acls);</div></pre></td></tr></table></figure>
</li>
<li><p>注册过的用户必须通过addAuthInfo才能操作节点，参考命令行 addauth： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zkServer.getZookeeper().addAuthInfo(<span class="string">"digest"</span>, <span class="string">"imooc1:123456"</span>.getBytes()); </div><div class="line">zkServer.createZKNode(<span class="string">"/aclimooc/testdigest/childtest"</span>,<span class="string">"childtest"</span>.getBytes(),Ids.CREATOR_ALL_ACL); </div><div class="line">Stat stat = <span class="keyword">new</span> Stat(); </div><div class="line"><span class="keyword">byte</span>[] data = zkServer.getZookeeper().getData(<span class="string">"/aclimooc/testdigest"</span>, <span class="keyword">false</span>, stat); </div><div class="line">System.out.println(<span class="keyword">new</span> String(data)); </div><div class="line">zkServer.getZookeeper().setData(<span class="string">"/aclimooc/testdigest"</span>, <span class="string">"now"</span>.getBytes(), <span class="number">1</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>Ip方式的acl： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;ACL&gt; aclsIP = <span class="keyword">new</span> ArrayList&lt;ACL&gt;(); </div><div class="line">Id ipId1 = <span class="keyword">new</span> Id(<span class="string">"ip"</span>, <span class="string">"192.168.1.6"</span>); </div><div class="line">aclsIP.add(<span class="keyword">new</span> ACL(Perms.ALL, ipId1)); </div><div class="line">zkServer.createZKNode(<span class="string">"/aclimooc/iptest6"</span>, <span class="string">"iptest"</span>.getBytes(), aclsIP);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>DigestAuthenticationProvider.generateDigest(id);转码操作，类似于命令行的echo -n lf:lf | openssl dgst -binary -sha1 | openssl base64 </p>
</blockquote>
<ul>
<li><h3 id="Curator客户端使用指南"><a href="#Curator客户端使用指南" class="headerlink" title="Curator客户端使用指南"></a>Curator客户端使用指南</h3></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lfstefan.github.io/2018/07/01/BeanCopy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="染心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/01/BeanCopy/" itemprop="url">
                  BeanCopy
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T12:21:25+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/07/01/BeanCopy/" class="leancloud_visitors" data-flag-title="BeanCopy">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Bean类的复制"><a href="#Bean类的复制" class="headerlink" title="Bean类的复制"></a>Bean类的复制</h1><blockquote>
<p>当bean对象中属性字段较少时，我们通常手动使用置取方法来完成一个bean对象的复制，但是实际项目中往往一个bean类中含有大量的属性字段，所以手动复制变得不太现实，beancopy技术因此应用而生。</p>
</blockquote>
<h3 id="Apache的两个版本：（原理：反射机制）"><a href="#Apache的两个版本：（原理：反射机制）" class="headerlink" title="Apache的两个版本：（原理：反射机制）"></a>Apache的两个版本：（原理：反射机制）</h3><ul>
<li>org.apache.commons.beanutils.PropertyUtils.copyProperties(Object     dest, Object orig)</li>
<li>org.apache.commons.beanutils.BeanUtils.copyProperties(Object dest,     Object orig)<h3 id="Spring版本：（原理：反射机制）"><a href="#Spring版本：（原理：反射机制）" class="headerlink" title="Spring版本：（原理：反射机制）"></a>Spring版本：（原理：反射机制）</h3></li>
<li>org.springframework.beans.BeanUtils.copyProperties(Object source,     Object target, Class     editable, String[] ignoreProperties)<h3 id="cglib版本：（原理：字节码-动态代理，效率最高）"><a href="#cglib版本：（原理：字节码-动态代理，效率最高）" class="headerlink" title="cglib版本：（原理：字节码+动态代理，效率最高）"></a>cglib版本：（原理：字节码+动态代理，效率最高）</h3></li>
<li>net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object     paramObject2, Converter     paramConverter)</li>
</ul>
<blockquote>
<p>反射原理我们都很熟，也很常见，字节码可能听着较为生疏，所以这里主要聊一聊cglib版本的beancopy（这是cglib用到的两个jar包：cglib-nodep-3.2.7.jar和asm-4.0.jar）</p>
</blockquote>
<h3 id="使用指南："><a href="#使用指南：" class="headerlink" title="使用指南："></a>使用指南：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SourceBean sourceBean = <span class="keyword">new</span> SourceBean();</div><div class="line">TargetBean targetBean = <span class="keyword">new</span> TargetBean(); </div><div class="line">BeanCopier copier = BeanCopier.create(SourceBean.class, TargetBean.class, <span class="keyword">false</span>); </div><div class="line">copier.copy(sourceBean, targetBean, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<h3 id="BeanCopier中Create对象过程："><a href="#BeanCopier中Create对象过程：" class="headerlink" title="BeanCopier中Create对象过程："></a>BeanCopier中Create对象过程：</h3><blockquote>
<p>产生sourceClass-》TargetClass的拷贝代理类，放入jvm中，所以创建的代理类的时候比较耗时，最好保证这个对象的单例模式。</p>
</blockquote>
<ul>
<li>创建过程：源代码见jdk：net.sf.cglib.beans.BeanCopier.Generator.generateClass(ClassVisitor)<ol>
<li>获取sourceClass的所有public get 方法-》PropertyDescriptor[] getters</li>
<li>获取TargetClass 的所有 public set 方法-》PropertyDescriptor[] setters</li>
<li>遍历setters的每一个属性，执行4和5</li>
<li>按setters的name生成sourceClass的所有setter方法-》PropertyDescriptor getter【不符合javabean规范的类将会可能出现空指针异常】</li>
<li>PropertyDescriptor[] setters-》PropertyDescriptor setter</li>
<li>将setter和getter名字和类型 配对，生成代理类的拷贝方法。</li>
</ol>
</li>
<li>Copy属性过程：调用生成的代理类，代理类的代码和手工操作的代码很类似，效率非常高。</li>
</ul>
<blockquote>
<p>从多字段向少字段（层层筛选）的拷贝，从少字段的向多字段（层层叠加）的拷贝均可实现，其核心都是target.setXXX(source.getXXX()),所以源类的get方法和目标类的set方法不可缺少，否则值将拷贝不过去。</p>
</blockquote>
<h3 id="后续延伸"><a href="#后续延伸" class="headerlink" title="后续延伸"></a>后续延伸</h3><blockquote>
<p>cglib是一款比较底层的操作java字节码的框架<br>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lfstefan.github.io/2018/06/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="染心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/24/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-24T17:20:58+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/06/24/hello-world/" class="leancloud_visitors" data-flag-title="Hello World">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lfstefan.github.io/2018/04/29/Json与序列化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="染心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/29/Json与序列化/" itemprop="url">
                  Json与序列化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T12:13:21+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Json/" itemprop="url" rel="index">
                    <span itemprop="name">Json</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/04/29/Json与序列化/" class="leancloud_visitors" data-flag-title="Json与序列化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Json与序列化"><a href="#Json与序列化" class="headerlink" title="Json与序列化"></a>Json与序列化</h1><blockquote>
<ul>
<li>序列化：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</li>
<li>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
</blockquote>
<h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><ul>
<li>对象表示为键值对</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = JSON.toJSONString(person);</div><div class="line">JSONObject jObject = JSON.parseObject(str);</div><div class="line">Person p = JSONObject.toJavaObject(jObject, Person.class);</div><div class="line">System.out.println(person.getName());</div></pre></td></tr></table></figure>
<blockquote>
<p>json的实现有很多，这里使用的fastjson，较其速度相对来说是所有实现中最快的，使用json代码较为简洁干练，并且其生成的字符串体积较小，易于传输。</p>
</blockquote>
<h2 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化/反序列化"></a>序列化/反序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*序列化对象到临时性存储介质，如字符串临时变量*/</span></div><div class="line">ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();  </div><div class="line">ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteOut);</div><div class="line"></div><div class="line"><span class="comment">/*序列化对象到永久性存储介质，如本地文件</span></div><div class="line">ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("D:/序列化.txt"));*/</div><div class="line"></div><div class="line">objectOutputStream.writeObject(person);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"序列化后对象的值为："</span>+byteOut.toString());</div><div class="line"><span class="comment">//System.out.println("序列化后对象的值为："+byteOut.toString("ISO-8859-1"));</span></div><div class="line">		</div><div class="line"><span class="comment">/*从文件反序列化对象</span></div><div class="line">ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("D:/序列化.txt"));*/</div><div class="line"></div><div class="line"><span class="comment">/*从字符串反序列化对象*/</span></div><div class="line">ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(byteOut.toString().getBytes());  </div><div class="line">ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteIn);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	Person readPerson = (Person)objectInputStream.readObject();</div><div class="line">	System.out.println(readPerson.getName());</div><div class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">	<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">	e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>serialize后字符串包含了子串的长度，这可能是速度方面的优化</li>
<li>至于两者的速度各有千秋，因不同的场景，不同的条件而定</li>
</ul>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://lfstefan.github.io/2018/04/22/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="染心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/22/JVM/" itemprop="url">
                  JVM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T12:21:25+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/04/22/JVM/" class="leancloud_visitors" data-flag-title="JVM">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="步入java虚拟机的世界"><a href="#步入java虚拟机的世界" class="headerlink" title="步入java虚拟机的世界"></a>步入java虚拟机的世界</h1><ul>
<li>内存管理<ul>
<li>运行时数据区域</li>
<li>内存分配与回收</li>
</ul>
</li>
<li>虚拟机对象</li>
<li>垃圾回收<ul>
<li>垃圾回收算法</li>
<li>垃圾收集器</li>
</ul>
</li>
<li>GC日志</li>
<li>class文件</li>
<li>类加载机制</li>
</ul>
<blockquote>
<p>建议读者自行了解java的技术体系结构以及java虚拟机的历史发展，这里不做叙述！</p>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><ul>
<li><p>程序计数器(线程私有)</p>
<blockquote>
<p>PC寄存器（pc计数器） 通过计数器来知道下一条应该执行的指令，精准记录各个线程正在执行的当前字节码指令地址 </p>
</blockquote>
</li>
<li><p>虚拟机栈（线程私有）</p>
<blockquote>
<p>也可以叫做JAVA栈 ，代表了处理逻辑 ，每当启动一个新线程时，JAVA虚拟机就会为他分配一个JAVA栈（以栈帧为单位保存线程的运行状态）。<br>单位为栈帧 （每调用一个方法时，都会创建一个新的栈帧） ，由局部变量表 （存储方法参数和局部变量 ，所需内存空间编译器完成，运行期间不变），操作数栈 ，动态链接 （指向运行时常量池中该栈帧所属方法的引用 ），方法返回值 四部分组成。</p>
</blockquote>
</li>
<li><p>本地方法栈（线程私有）</p>
<blockquote>
<p>虚拟机执行native方法，hotspot中将本地方法栈和虚拟机栈合二为一，作用类似</p>
</blockquote>
</li>
<li><p>java堆（线程共享）</p>
<blockquote>
<p>堆 ，代表了数据，运行时动态分配内存 </p>
<ul>
<li>一个JAVA程序在运行时创建的所有的类实例或数组都放在同一个堆里面。 </li>
<li>一个JAVA虚拟机实例中只会存在一个堆空间，所有的线程共享这个堆空间。 </li>
<li>一个JAVA 程序独占一个JAVA虚拟机实例。 </li>
<li>所以每个JAVA程序都有自己的堆空间，彼此互不干扰。 </li>
</ul>
<p>堆中的的分代：YoungGen（新生代，存放新生对象或年龄不大的对象）{Eden  +  From Survivor  +  To Survivor} OldGen（老生代，存放大对象或者年龄较大的对象） </p>
</blockquote>
</li>
<li><p>方法区</p>
<blockquote>
<p>方法区—编译后代码的存储区，存储了每一个java类的结构信息，逻辑上独立，物理上属于堆的一部分 </p>
</blockquote>
</li>
<li><p>运行时常量区</p>
<blockquote>
<p>运行时常量池—方法区的一部分，用于存放编译器生成的字面量和符号引用</p>
</blockquote>
</li>
<li><p>直接内存</p>
<blockquote>
<p>本地函数库直接分配内存，由堆中一个DirectorByteBuffer指向引用操作</p>
</blockquote>
</li>
</ul>
<h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><ul>
<li>大多数情况下，对象直接在Eden区域分配，如果该区域不够，则虚拟机进行一次minorGC</li>
</ul>
<blockquote>
<p>minorGC：新生代GC，由于新生代对象生命周期较短，朝生夕灭，所以minorGC较为频繁，速度较快<br>majorGC：老年代GC，大对象，周期较长，不频繁，速度比minorGC慢十倍左右，一般majorGC的发生总会伴随着至少一次的minorGC</p>
</blockquote>
<ul>
<li>大对象直接在老年代分配（应该尽量避免短命大对象）<ul>
<li>对象年龄计数器：在Eden出生经过一次minorGC并且被survivor接收的话（如果survivor不接受则进入老年代），进入survivor后年龄设置为1，然后每熬过一次minorGC，年龄加一，到达一定年龄后进入老年代，默认年龄是15岁进入老年代。</li>
<li>动态年龄判定：survivor中相同年龄的对象大小总和大于survivor空间大小的一半时，所有大于等于该年龄的对象进入老年代</li>
<li>空间分配担保：minorGC前会判断老年代中空闲空间大小是否大于新生代所有对象所占空间总和，大于则绝对安全（即使minorGC后新生代对象所有都进入老年代，也可以容的下），否则需要风险担保，由于具体进入老年代的对象所占空间大小在minorGC之后才能确定，所以在此之前，老年代会采用之前数据的平均值来预估是否可以容下即将进入老年代的所有对象，故存在一定风险导致容不下，而导致发生fullGC（我们的目标是尽量减少fullgc，因为耗时太久）。</li>
</ul>
</li>
</ul>
<h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><ul>
<li><p>对象的创建</p>
<blockquote>
<p>这里指的是普通对象的创建，即我们最常使用的关键字new创建对象的过程（不包括数组对象和class对象）</p>
</blockquote>
<ul>
<li>首先在常量池中定位该类的符号引用是否存在</li>
<li>存在紧接着判定是否加载过（即经历了加载，解析，初始化三个阶段）</li>
<li>加载过然后堆中分配内存空间，具体大小加载中已计算出来<ul>
<li>这里涉及到堆中分配策略：主要有两种，指针碰撞和空闲列表</li>
<li>指针碰撞：堆内存空间规整，已分配/未分配空间区域有明确分界线，这时只需要将指针向一个未分配区域方向移动所需空间大小即可实现对象的堆中内存空间分配</li>
<li>空闲列表：堆内存空间不规整，这样的话就得维护一个列表，负责记录空闲空间，然后从列表中找出一个符合分配对象大小的空间分配给它</li>
<li>堆空间的规整与否，取决于垃圾回收器是否有压缩整理功能</li>
<li>考虑到并发操作的安全性，提出了两种解决方案：1. cas原子性操作，2. 本地线程分配缓冲池TLAB—java堆区域中一块线程私有区域，包含在Eden空间中，用于快速分配策略（每一个线程在堆中的一小块内存空间，操作系统中称为快表，因为线程私有，所以线程安全，只有TLAB分配完后才从共享堆中执行原子性操作分配空间）</li>
<li>TlAB分配失败直接在Eden中分配，Eden也失败则执行GC，如果是大对象直接在老年代中分配 </li>
</ul>
</li>
<li>内存空间分配好后初始化内存空间</li>
<li>然后设置对象头（对象头用于存放类的各种信息，类比报文头理解）</li>
<li>init()</li>
</ul>
</li>
<li><p>对象访问定位</p>
<blockquote>
<p>栈中reference引用数据指向堆中对象(具体访问实现调用由虚拟机实现，因此不同虚拟机实现不同,主流有两种，句柄，直接指针。见下图理解）</p>
</blockquote>
<ul>
<li><p>句柄实现如下：</p>
<p><img src="http://op7sipvie.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D1.png" alt="对象访问定位1"></p>
</li>
<li><p>直接指针实现如下：</p>
<p><img src="http://op7sipvie.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D2.png" alt="对象访问定位2"></p>
</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判定对象可以进行回收"><a href="#如何判定对象可以进行回收" class="headerlink" title="如何判定对象可以进行回收"></a>如何判定对象可以进行回收</h3><ul>
<li>引用计数法：简而言之就是记录对象的引用数，为零时可回收，但是该方法无法解决对象的循环引用问题</li>
<li>可达性分析算法（简单来说，就是图的根节点如果无法间接相连到该节点，则说明该节点不可达，回收，如下图所示）</li>
</ul>
<p><img src="http://op7sipvie.bkt.clouddn.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="可达性分析算法图解"></p>
<ul>
<li><p>引用分类（由于以前引用的定义过于狭隘，而现实中我们想实现一种“空间充足，则对象存在，空间紧迫，则对象回收”的美好愿景，于是引用分类由此而生）</p>
<ul>
<li>强引用</li>
<li>软引用：有用非必须，内存溢出之前进行回收</li>
<li>弱引用：只能存活到下一次垃圾回收之前</li>
<li>虚引用（依次递减）：无法通过该引用获得实例对象，其存在的唯一目的就是进行垃圾回收时会收到一个系统通知</li>
</ul>
</li>
<li><p>一个对象的死亡之路：</p>
<blockquote>
<p>首先可达性分析—–&gt;不可达—–&gt;第一次标记，筛选（即一次miniorGC过程）——&gt;若没有覆盖finalize()方法/或已执行finalize方法——&gt;否——&gt;执行finalize方法—–&gt;放入F-queue队列中—-&gt;一定时间后执行二次标记（在此之前如果队列中对象可以再次获取引用，则到时候出队列躲过被回收的命运，否则就真的被回收）</p>
</blockquote>
</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>标记清除算法：先标记回收对象，然后统一回收，效率较低，导致内存碎片过多，使得内存利用率降低</li>
<li>复制算法：将内存空间对半分为相等的两部分，一半使用，另一半保留，当需要回收时将使用过的那一半中的对象复制到保留未使用的一般中，然后清空那一半空间保留下一次回收时使用。此方法可以避免内存碎片，提高内存利用率。</li>
<li>标记整理算法：先标记，后移动可用空间到一起，然后统一清除剩下的</li>
<li>分代回收算法：按生存周期划分内存空间，不同空间采用不同的回收算法。新生代（复制算法）老年代（对象存活率高，采用标记清除/整理算法）</li>
</ul>
<h3 id="垃圾收集器：内存回收的具体实现"><a href="#垃圾收集器：内存回收的具体实现" class="headerlink" title="垃圾收集器：内存回收的具体实现"></a>垃圾收集器：内存回收的具体实现</h3><pre><code>- serial：单线程+stop the world-----新生代收集器
- parnew：多线程版本的serial-----新生代收集器
- paralel scavenge：关注点在高吞吐量，提高cpu效率，多线程，新生代收集器
- seri old：serial的老年代收集器版本，单线程
- paralel old：paralel scavenge的老年代收集器版本，多线程
- cms：强调一次GC过程的最短停顿时间，
- g1收集器
</code></pre><h2 id="GC日志阅读"><a href="#GC日志阅读" class="headerlink" title="GC日志阅读"></a>GC日志阅读</h2><blockquote>
<p>GC日志的阅读有助于处理遇到的内存问题，就好比看日志调试bug一样</p>
</blockquote>
<p><img src="http://op7sipvie.bkt.clouddn.com/GC%E6%97%A5%E5%BF%97.png" alt="GC日志参数读取图"></p>
<h2 id="认识class文件"><a href="#认识class文件" class="headerlink" title="认识class文件"></a>认识class文件</h2><blockquote>
<p>虚拟机不与包括java在内的所有语言绑定，而是与class文件绑定，意味着和虚拟机打交道的是class文件</p>
</blockquote>
<ul>
<li>首先了解class文件是一组以8位字节为基础单位的二进制流； </li>
<li>其编译原理过程较为复杂，这里不做深究，大致过程为：词法分析（生成Token序列）—语法分析（生成抽象语法树）—语义分析（完善语法树）—生成最终字节码 </li>
<li>本章节重点了解class文件的结构组成： （其结构如下图所示）</li>
</ul>
<p><img src="http://op7sipvie.bkt.clouddn.com/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="class文件结构图"></p>
<blockquote>
<p>（U1,U2,U4分别表示1，2，4个字节的无符号数）ClassFile表结构是class文件的最外层结构，即class文件的格式</p>
</blockquote>
<ul>
<li>第一项为魔数：CA-FE-BA-BE（cafebabe）（对应的十进制为202-254-186-190），用于判定是否为java-class文件。 </li>
<li>第二项是主次版本号（；不同版本的jvm编译下的class文件在其他版本的jvm下不适用） </li>
<li><p>第三项是常量池（常量池数量+常量池数组），存在于方法区中，由11种基本的常量项（常量表）组成，Java程序的一个类中的所有常量数据都将存储在这里，像类名，方法名，返回类型等等 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">项的通用格式 cp_info&#123; </div><div class="line">u1 tag； </div><div class="line">u1 info[]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>第四项：access_flags </p>
</li>
<li>第五项：this_class，记录当前类的全限定名（包名+类名），其值指向常量池中对应的索引值 </li>
<li>第六项：supper_class 记录当前类的父类的全限定名， </li>
<li>第七项：interface_count，记录当前类的实现的接口数量 </li>
<li>第八项：interface，记录当前类实现的接口 </li>
<li>第九项：field_count，记录当前类的定义的变量的总数量 </li>
<li>第十项：field 变量详细信息 </li>
<li><p>字段表代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Filed_info&#123; </div><div class="line">u2 access_flags;（访问权限和基本属性的掩码标志） </div><div class="line">u2 name_index; </div><div class="line">u2 descriptor_index; </div><div class="line">u2 attributes_counts; </div><div class="line">Attribute_info attributes[attributes_counts]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法表代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">method_info&#123; </div><div class="line">u2 access_flags;（访问权限和基本属性的掩码标志） </div><div class="line">u2 name_index; </div><div class="line">u2 descriptor_index; </div><div class="line">u2 attributes_counts; </div><div class="line">Attribute_info attributes[attributes_counts]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注：类和接口的名称采用全限定形式 ；方法，字段名，局部变量采用非全限定形式 </p>
</blockquote>
<h3 id="Class文件校验"><a href="#Class文件校验" class="headerlink" title="Class文件校验"></a>Class文件校验</h3><ul>
<li>Class文件加载过程：装载—链接（验证(确保类型格式)—准备(分配内存)—解析(常量池中的符号链接转换为直接引用)）—初始化(赋予初值)<clinit>方法 <blockquote>
<p>注：<clinit>类型的初始化方法，jvm决定加载某个类型时调用该方法<br><init>类的构造函数，jvm决定实例化某个类型时调用该方法 </init></clinit></p>
</blockquote>
</clinit></li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><blockquote>
<p>加载-（验证-准备-解析（只有该阶段执行顺序不一定，可变））统称为连接-初始化-使用-卸载</p>
</blockquote>
<ul>
<li>加载：<ul>
<li>通过一个类 的全限定名来获取的此类的二进制字节流</li>
<li>将这字节流所代表的静态存储结构转化为方法区运行时数据结构</li>
<li>在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
<li>验证：连接第一步，保证class文件中字节流包好信息符合虚拟机要求，其中包括文件格式，元数据验证，字节码验证，符号引用验证</li>
<li>准备：类变量分配内存（包好static，不包含实例变量），初始化变量值</li>
<li>解析：虚拟机将 常量池内符号引用替换为直接引用<ul>
<li>符号引用：与虚拟机布局无关，引用目标不一定加载到内存中，class文件中明确规定</li>
<li>直接引用：与虚拟机布局有关，引用目标必然存在于内存中</li>
</ul>
</li>
<li>初始化：执行类构造器<clinit>方法的过程<ul>
<li><clinit>方法详解</clinit></li>
<li>编译器自动收集类中所有的类变量的赋值动作和静态语句块中语句合并而成（静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的只能赋值，不能访问）</li>
<li>不同于构造函数（init()函数），它不会显示的调用父类构造器，虚拟机保证在子类的clinit之前父类clinit已经执行完毕，所以虚拟机中第一个执行的肯定是object的clinit</li>
<li>如果一个类或者接口中没有静态语句块，并且没有对变量的赋值操作，编译器可以不生成clinit方法</li>
</ul>
</clinit></li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>”通过一个类的全限定名来获取描述此类的二进制字节流“这个动作在虚拟机外部实现，</li>
<li>同一份class文件，不同的类加载器加载后形成的类不一样</li>
<li>启动类加载器：BoostropClassLoader，c++实现，虚拟机自身一部分</li>
<li>其他所有类加载器：java实现，虚拟机外部<ul>
<li>扩展类加载器</li>
<li>应用程序加载器</li>
<li>自定义加载器</li>
</ul>
</li>
<li>双亲委派模型：类加载器收到类加载请求后，将请求委派给父加载器，所有的请求最终被传送到启动类加载器上，只有父加载器自己无法完成加载后，子加载器才会自己加载，</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="刘飞" />
          <p class="site-author-name" itemprop="name">刘飞</p>
           
              <p class="site-description motion-element" itemprop="description">一只奋进的小菜鸟</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">74</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LFstefan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  Sat Apr 29 2017 08:00:00 GMT+0800 (中国标准时间) - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘飞</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  
    

    
  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("4jo3lh32lhNprUWelt3fCUrM-gzGzoHsz", "cTko66LfK5xF0OrYbFlACBB7");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
