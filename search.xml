<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java描绘数据统计图]]></title>
    <url>%2F2018%2F04%2F01%2FJava%E6%8F%8F%E7%BB%98%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Java描绘数据统计图ECharts 最近需要实现一个数据曲线对比的小任务，于是想试试描绘数据统计图，了解到可以使用echarts和hcharts，这里使用的是echarts，首先官方实例很好，容易理解且上手快，但是都是静态的，我要实现的是动态获取后台数据来前台显示数据曲线对比，所以会涉及到ajax和json的相关内容（读者自行了解）！ 代码展示 首先是html最终呈现效果页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 初始化移动浏览显示 --&gt; &lt;meta name="Author" content="Dreamer-1."&gt; &lt;title&gt;- 观测数据 -&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 初始化一块区域来显示Echarts图表 --&gt; &lt;div style="height:410px;min-height:100px;margin:0 auto;" id="main"&gt;&lt;/div&gt; &lt;!-- 引入相关js文件 --&gt; &lt;script type="text/javascript" src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); var companyName = []; //类别数组（每个企业名称） var mar = []; //隐患级别数组（企业每月隐患级别） var apr = []; var may = []; var jun = []; var jul = []; var aug = []; var sep = []; $.ajax(&#123; //使用JQuery内置的Ajax方法 type : "post", //post请求方式 async : true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行） url : "returnJsonData", //请求发送到returnJsonData的servlet处理 data : &#123;&#125;, dataType : "json", //返回数据形式为json success : function(result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 if (result != null &amp;&amp; result.length &gt; 0) &#123; for(var i=0;i&lt;result.length;i++)&#123; companyName.push(result[i].name); //挨个取出类别并填入类别数组 mar.push(result[i].mar); //挨个取出每个月份的隐患级别插入数组 apr.push(result[i].apr); may.push(result[i].may); jun.push(result[i].jun); jul.push(result[i].jul); aug.push(result[i].aug); sep.push(result[i].sep); &#125; //循环显示不同的曲线 var series = []; for(var i=0;i&lt;companyName.length;i++)&#123; series.push(&#123; "name":companyName[i], "type":"line", //折线图表示 "data":[mar[i],apr[i],may[i],jun[i],jul[i],aug[i],sep[i],] //数据值通过Ajax动态获取 &#125;); &#125; // 指定图表的配置项和数据 var option = &#123; title: &#123; //图表标题 text: '隐患数据表' &#125;, legend: &#123; //图表上方的类别显示 show:true, data : companyName &#125;, color:[ '#FF3333', //各曲线颜色 '#53FF53', '#B15BFF', ], toolbox: &#123; //工具栏显示 show: true, feature: &#123; saveAsImage: &#123;&#125; //显示“另存为图片”工具 &#125; &#125;, xAxis: &#123; //X轴 type: 'category', data: ["Mar","Apr","May","Jun","Jul","Aug","Sep"] &#125;, yAxis : [ &#123; type : 'value', name : '隐患级别', axisLabel : &#123; formatter: '&#123;value&#125; -level' //控制输出格式 &#125; &#125;, ], series : series &#125;; myChart.setOption(option); //载入图表 &#125; else &#123; //返回的数据为空时显示提示信息 alert("图表请求数据为空！"); myChart.hideLoading(); &#125; &#125;, error : function(errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败，可能是服务器开小差了"); myChart.hideLoading(); &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接下来是servlet后台获取数据并回传给前台显示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class returnJsonData extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public returnJsonData() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doPost(request,response); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub request.setCharacterEncoding("UTF-8"); //设定客户端提交给servlet的内容按UTF-8编码 response.setCharacterEncoding("UTF-8"); //设定servlet传回给客户端的内容按UTF-8编码 response.setContentType("text/html;charset=UTF-8"); //告知浏览器用UTF-8格式解析内容 //构造返回数据 List&lt;company&gt; list = new LinkedList&lt;company&gt;(); company com = new company(); company com1 = new company(); company com2 = new company(); list.add(fun(com,"企业一")); list.add(fun(com1,"企业二")); list.add(fun(com2,"企业三")); ObjectMapper mapper = new ObjectMapper(); //提供java-json相互转换功能的类 String json = mapper.writeValueAsString(list); //将list中的对象转换为Json格式的数组 //System.out.println(json);//打印验证json数据格式 //将json数据返回给客户端 response.setContentType("text/html; charset=utf-8"); response.getWriter().write(json); &#125; public company fun(company com, String str)&#123; com.setName(str); com.setMar(Math.random()); com.setApr(Math.random()); com.setMay(Math.random()); com.setJun(Math.random()); com.setJul(Math.random()); com.setAug(Math.random()); com.setSep(Math.random()); return com; &#125;&#125; 最后附上完整实例代码：https://github.com/LFstefan/LineChart_example]]></content>
      <categories>
        <category>ECharts</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ECharts</tag>
        <tag>Ajax</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2017%2F10%2F21%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[java8新特性 本文参考自官方文档What’s New in JDK 8，内容有所筛选！ 目录 Java Programming Language Lambda Expressions（Lambda表达式） Method references （方法引用） Default methods （默认方法） Repeating Annotations （重复注释） Improved type inference（更好的类型推断） Method parameter reflection（方法参数反射） Collections（集合） Tool（工具） Javac tool Javadoc tool Internationalization（国际化） Date-Time Package （日期时间） IO and NIO java.lang and java.util Packages Parallel Array Sorting（并行数组排序） Standard Encoding and Decoding Base64（标准编码和解码Base64） Unsigned Arithmetic Support（无符号算术支持） JDBC The JDBC-ODBC Bridge has been removed. JDBC 4.2 introduces new features. Concurrency（并发） HotSpot 正文Java编程语言 Lambda表达式 Lambda表达式是一种新的语言功能，已在此版本中引入。它们使您能够将功能视为方法参数，或将代码视为数据。使用Lambda表达式可以更简洁地表达单方法接口（称为函数接口）的实例。 Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成（其中参数列表中的参数e的类型可以由编译器推理得出的，也可以显式指定该参数的类型），例如： 1234567891011//基本语法://(params) -&gt; expression//(params) -&gt; statement//(params) -&gt; &#123; statements &#125;Arrays.asList( "a", "b", "d" ).forEach( e -&gt; System.out.println( e ) );//等价于Arrays.asList( "a", "b", "d" ).forEach( ( String e ) -&gt; System.out.println( e ) );Arrays.asList( "a", "b", "d" ).forEach( e -&gt; &#123; System.out.print( e ); System.out.print( e );&#125; ); Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final），但是不能在lambda内部修改定义在域外的变量。同时Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，例如 12345678(final) String separator = ",";Arrays.asList( "a", "b", "d" ).forEach( ( String e ) -&gt; System.out.print( e + separator ) );//Lambda表达式中语句块只有一行，可以不用使用return语句Arrays.asList( "a", "b", "d" ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );Arrays.asList( "a", "b", "d" ).sort( ( e1, e2 ) -&gt; &#123; int result = e1.compareTo( e2 ); return result;&#125; ); 函数接口 函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义： 1234@FunctionalInterfacepublic interface Functional &#123; void method();&#125; 不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。 1234567891011121314@FunctionalInterfacepublic interface FunctionalDefaultMethods &#123; void method(); default void defaultMethod() &#123; &#125; &#125;@FunctionalInterfacepublic interface FunctionalStaticMethods &#123; void method(); Static void defaultMethod() &#123; &#125; &#125; lambda表达式替换匿名类 1234567891011121314151617181920212223// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start();// Java 8之前：Collections.sort(list, new Comparator&lt;Object&gt;() &#123; public int compare(Object arg0, Object arg1) &#123; String s1 = (String)arg0; String s2 = (String)arg1; return s1.compareTo( s2 ); &#125; &#125;);//Java 8方式： Collections.sort(list,(arg0,arg1) -&gt; &#123; String s1 = (String)arg0; String s2 = (String)arg1; return s1.compareTo( s2 ); &#125;); ####Stream stream()Stream filter(Predicate&lt;? super T&gt; predicate) Stream map(Function&lt;? super T,? extends R&gt; mapper)void forEach(Consumer&lt;? super T&gt; action) 1 方法引用 方法引用为已有名称的方法提供易读的lambda表达式。lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。 （引用静态方法）ContainingClass :: staticMethodName 1Arrays.sort(rosterAsArray, MyComparisonProvider::staticCompare); （引用特定对象的实例方法）containsObject :: instanceMethodName 12//ComparisonProvider myComparisonProvider = new ComparisonProvider();Arrays.sort(rosterAsArray, myComparisonProvider::normalCompare); （引用特定类型任意对象的实例方法）ContainingType :: methodName 123String[] stringArray = &#123; "Barbara", "James", "Mary", "John", "Patricia", "Robert", "Michael", "Linda" &#125;;Arrays.sort(stringArray, String::compareToIgnoreCase); （引用一个构造函数）ClassName :: new 1Set&lt;Person&gt; rosterSet = transferElements(roster, HashSet::new); 默认方法 默认方法可以将新功能添加到库的接口，并确保与为这些接口的旧版本编写的代码的二进制兼容性。 12345678910public interface TimeClient &#123; //通过接口直接调用该静态方法 static void dispaly () &#123; System.out.println("static"); &#125; //该接口的实现类不强制要求重写default方法，使得接口可以添加新功能而不影响其实现类 default void dispaly() &#123; System.out.println("default"); &#125; &#125; 重复注释 重复注释提供了将同一注释类型多次应用于相同的声明或类型使用的功能。Java8之前的注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。在Java 8中使用@Repeatable注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。 12345678910@Schedule(dayOfMonth="last")@Schedule(dayOfWeek="Fri", hour="23")public void doPeriodicCleanup() &#123; ... &#125;//The annotation type must be marked with the @Repeatable meta-annotation@Repeatable(Schedules.class)public @interface Schedule &#123; String dayOfMonth() default "first"; String dayOfWeek() default "Mon"; int hour() default 12;&#125; 更好的类型推断 12345678//Java 8方式： List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add("A");stringList.addAll(Arrays.asList());//Java 8之前： List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add("A");stringList.addAll(Arrays.&lt;String&gt;asList()); 方法参数反射 您可以使用方法java.lang.reflect.Executable.getParameters获取任何方法或构造函数的形式参数的名称。 （类Method和构造函数扩展了类Executable，因此继承了方法Executable.getParameters。）但是，.class文件默认不存储形式参数名称。 要将正式参数名称存储在特定的.class文件中，从而使Reflection API能够检索正式的参数名称，请使用javac编译器的-parameters选项编译源文件。 12345678public class ParameterNames &#123; public static void main(String[] args) throws Exception &#123; Method method = ParameterNames.class.getMethod( "main", String[].class ); for( final Parameter parameter: method.getParameters() ) &#123; System.out.println( "Parameter: " + parameter.getName() ); &#125; &#125;&#125; 集合 新的java.util.stream包中的类提供了一个Stream API来支持元素流上的函数式操作。 Stream API集成到Collections API中，可以对集合进行批量操作，例如顺序或并行的map-reduce转换。 java.util.stream.Stream部分方法如下 Stream filter(Predicate&lt;? super T&gt; predicate)（过滤） Stream map(Function&lt;? super T,? extends R&gt; mapper)（转换） IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper) Stream distinct()（返回由此流的不同元素，去重） Stream sorted()（默认排序） Stream sorted(Comparator&lt;? super T&gt; comparator)（排序） Stream peek(Consumer&lt;? super T&gt; action) 1234567//This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline:Stream.of("one", "two", "three", "four") .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println("Filtered value: " + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println("Mapped value: " + e)) .collect(Collectors.toList()); Stream limit(long maxSize)（限制） Stream skip(long n)（跳过前n个元素） void forEach(Consumer&lt;? super T&gt; action)（迭代） void forEachOrdered(Consumer&lt;? super T&gt; action) Object[] toArray()（转换成数组） 1Person[] men = people.stream().filter(p -&gt; p.getGender() == MALE).toArray(Person[]::new); T reduce(T identity,BinaryOperator accumulator)（合并） Optional reduce(BinaryOperator accumulator) U reduce(U identity,BiFunction accumulator,BinaryOperator combiner) R collect(Supplier supplier,BiConsumer accumulator,BiConsumer combiner) 1234//The following will accumulate strings into an ArrayList:List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add,ArrayList::addAll);//The following will take a stream of strings and concatenates them into a single string:String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,StringBuilder::append).toString(); R collect(Collector&lt;? super T,A,R&gt; collector) 123456//The following will accumulate strings into an ArrayList:List&lt;String&gt; asList = stringStream.collect(Collectors.toList());//The following will classify Person objects by city:按照城市分组Map&lt;String, List&lt;Person&gt;&gt;peopleByCity= personStream.collect(Collectors.groupingBy(Person::getCity));//The following will classify Person objects by state and city, cascading two Collectors together:按照国家和城市两项进行分组Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; peopleByStateAndCity= personStream.collect(Collectors.groupingBy(Person::getState,Collectors.groupingBy(Person::getCity))); Optional min(Comparator&lt;? super T&gt; comparator)（最小值） Optional max(Comparator&lt;? super T&gt; comparator)（最大值） long count()（计数） boolean anyMatch(Predicate&lt;? super T&gt; predicate)（匹配） boolean allMatch(Predicate&lt;? super T&gt; predicate) boolean noneMatch(Predicate&lt;? super T&gt; predicate) Optional findFirst() Optional findAny() static Stream empty() static Stream of(T t)（返回包含单个元素的顺序流。） static Stream of(T… values)（返回顺序排列的流，其元素是指定的值。） static Stream concat(Stream&lt;? extends T&gt; a,Stream&lt;? extends T&gt; b)（连接） forEach对列表进行迭代 12345678910// Java 8之前：List features = Arrays.asList("Lambdas", "Default Method", "Stream API", "Date and Time API");for (String feature : features) &#123; System.out.println(feature);&#125;// Java 8之后：List features = Arrays.asList("Lambdas", "Default Method", "Stream API", "Date and Time API");features.forEach(n -&gt; System.out.println(n));// 使用Java 8的方法引用更方便features.forEach(System.out::println); map将对象进行转换，reduce结果合并 123456789101112131415161718192021// Java 8之前：List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);for (Integer cost : costBeforeTax) &#123; double price = cost + .12*cost; System.out.println(price);&#125;// Java 8之后：List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).forEach(System.out::println);// Java 8之前：List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double total = 0;for (Integer cost : costBeforeTax) &#123; double price = cost + .12*cost; total = total + price;&#125;System.out.println("Total : " + total);// Java 8之后：List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).reduce((sum, cost) -&gt; sum + cost).get();System.out.println("Total : " + bill); filter元素过滤 123// 创建一个字符串列表，每个字符串长度大于2List&lt;String&gt; filtered = strList.stream().filter(x -&gt; x.length()&gt; 2).collect(Collectors.toList());System.out.printf("Original List : %s, filtered list : %s %n", strList, filtered); 具有关键冲突的HashMap性能改进 工具 Javac工具javac命令的-parameters选项可用于存储形式参数名称并使Reflection API检索正式参数名称。 Java语言规范（JLS）第15.21节中的相等运算符的类型规则现在可以通过javac命令正确执行。 Javadoc工具javadoc工具支持新的DocTree API，使您能够将Javadoc注释作为抽象语法树来遍历。 javadoc工具支持新的Javadoc Access API，使您可以直接从Java应用程序调用Javadoc工具，而无需执行新的过程。有关更多信息，请参阅javadoc什么是新页面。 现在，javadoc工具支持检查javadoc注释的内容，以解决可能导致运行javadoc时生成的文件中的各种问题（例如无效的HTML或可访问性问题）的问题。该功能默认启用，也可以通过新的-Xdoclint选项进行控制。有关更多详细信息，请参阅运行“javadoc -X”的输出。在javac工具中也可以使用此功能，但默认情况下它未启用。 国际化 Unicode增强功能，包括对Unicode 6.2.0的支持 采用Unicode CLDR数据和java.locale.providers系统属性 新的日历和区域设置API 能够将自定义资源包安装为扩展 日期时间包 - 一组提供全面日期 - 时间模型的新包。 IO和NIO 基于Solaris事件端口机制的Solaris新增SelectorProvider实现。要使用，使用设置为值sun.nio.ch.EventPortSelectorProvider的系统属性java.nio.channels.spi.Selector运行。 减小 /jre/lib/charsets.jar文件的大小 提高了java.lang.String（byte []，*）构造函数和java.lang.String.getBytes（）方法的性能。 java.lang和java.util包 并行数组排序 标准编码和解码Base64 无符号算术支持 JDBC- JDBC-ODBC Bridge已被删除。 - JDBC 4.2引入了新功能。 并发 类和接口已被添加到java.util.concurrent包中。 已经将方法添加到java.util.concurrent.ConcurrentHashMap类中，以支持基于新添加的流设施和lambda表达式的聚合操作。 已将类添加到java.util.concurrent.atomic包以支持可伸缩的可更新变量。 方法已被添加到java.util.concurrent.ForkJoinPool类中以支持公共池。 已添加java.util.concurrent.locks.StampedLock类以提供基于能力的锁，其中有三种控制读/写访问的模式。 HotSpot 硬件内在函数被添加到使用高级加密标准（AES）。 UseAES和UseAESIntrinsics标志可用于启用英特尔硬件的基于硬件的AES内在函数。硬件必须是2010年或更新的Westmere硬件。例如，要启用硬件AES，请使用以下标志：-XX：+ UseAES -XX：+ UseAESIntrinsics，要禁用硬件AES，请使用以下标志：-XX：-UseAES -XX：-UseAESIntrinsics 去除PermGen。 Java编程语言中的缺省方法由方法调用的字节码指令支持。]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F10%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式文档]]></content>
      <categories>
        <category>Regular_Expression</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Regular_Expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库优化]]></title>
    <url>%2F2017%2F10%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库优化选取最适用的字段属性 数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。 例如，邮政编码字段，CHAR(6)好过CHAR(255)和VARCHAR，同样MEDIUMINT好过BIGIN来定义整型字段（五种整型tinyint，smallint，mediumint，int，bigint）。 把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。 使用连接（JOIN）来代替子查询(Sub-Queries) MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 使用联合(UNION)来代替手动创建的临时表 MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。例如。SELECT Name,Phone FROM client UNION SELECT Name,BirthDate FROM author 事务 尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。 BEGIN;INSERT INTO salesinfo …;UPDATE inventory SET Quantity = 11 WHERE item = ‘book’;COMMIT; 事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。 锁定表 尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。 其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。 LOCKTABLE inventory WRITESELECT Quantity FROM inventory WHERE Item = ‘book’;…UPDATE inventory SET Quantity = 11 WHERE Item = ‘book’;UNLOCKTABLES 这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。 使用索引 索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。 那该对哪些字段建立索引呢？一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况 优化的查询语句 首先，最好是在相同类型的字段间进行比较的操作。在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。 其次，在建有索引的字段上尽量不要使用函数进行操作。例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。 第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的(like ‘xxx%’可以用到索引，但是like ‘%xxx%’不行，通过覆盖索引进行优化)。 例如下面的查询将会比较表中的每一条记录。SELECT FROM books WHERE name like “MySQL%”但是如果换用下面的查询，返回的结果一样，但速度就要快上很多：SELECT FROM books WHERE name＞=”MySQL” and name＜”MySQM” 数据分页处理 客户端(应用程序或浏览器)分页：将数据从应用服务器全部下载到本地应用程序或浏览器，在应用程序或浏览器内部通过本地代码进行分页处理 优点：编码简单，减少客户端与应用服务器网络交互次数 缺点：首次交互时间长，占用客户端内存 适应场景：客户端与应用服务器网络延时较大，但要求后续操作流畅，如手机GPRS，超远程访问（跨国）等等。 应用服务器分页：将数据从数据库服务器全部下载到应用服务器，在应用服务器内部再进行数据筛选。以下是一个应用服务器端Java程序分页的示例： 123List list=executeQuery(“select * from employee order by id”);Int count= list.size();List subList= list.subList(10, 20); 优点：编码简单，只需要一次SQL交互，总数据与分页数据差不多时性能较好。 缺点：总数据量较多时性能较差。 适应场景：数据库系统不支持分页处理，数据量较小并且可控。 数据库SQL分页：采用数据库SQL分页需要两次SQL完成，一个SQL计算总数量，一个SQL返回分页后的数据 优点：性能好 缺点：编码复杂，各种数据库语法不同，需要两次SQL交互。 oracle数据库一般采用rownum来进行分页，常用分页语法有如下两种： 直接通过rownum分页：数据访问开销=索引IO+索引全部记录结果对应的表数据IO 12345select * from ( select a.*,rownum rn from (select * from product a where company_id=? order by status) a where rownum&lt;=20)where rn&gt;10; 采用rowid分页语法：优化原理是通过纯索引找出分页记录的ROWID，再通过ROWID回表返回数据，要求内层查询和排序字段全在索引里。(数据访问开销=索引IO+索引分页结果对应的表数据IO) 12345678create index myindex on product(company_id,status);select b.* from ( select * from ( select a.*,rownum rn from (select rowid rid,status from product a where company_id=? order by status) a where rownum&lt;=20) where rn&gt;10) a, product bwhere a.rid=b.rowid; 减少交互次数 batch DML：数据库访问框架一般都提供了批量提交的接口，jdbc支持batch的提交处理方法，当你一次性要往一个表中插入1000万条数据时，如果采用普通的executeUpdate处理，那么和服务器交互次数为1000万次，按每秒钟可以向数据库服务器提交10000次估算，要完成所有工作需要1000秒。如果采用批量提交模式，1000条提交一次，那么和服务器交互次数为1万次，交互次数大大减少。采用batch操作一般不会减少很多数据库服务器的物理IO，但是会大大减少客户端与服务端的交互次数，从而减少了多次发起的网络延时开销，同时也会降低数据库的CPU开销。 In List 12//我们也可以做一个小的优化， 如下所示，用ID IN LIST的这种方式写SQL：select * from mytable where id in(:id1,id2,...,idn); 通过这样处理可以大大减少SQL请求的数量，从而提高性能。那如果有10000个ID，那是不是全部放在一条SQL里处理呢？答案肯定是否定的。首先大部份数据库都会有SQL长度和IN里个数的限制，如ORACLE的IN里就不允许超过1000个值。 另外当前数据库一般都是采用基于成本的优化规则，当IN数量达到一定值时有可能改变SQL执行计划，从索引访问变成全表访问，这将使性能急剧变化。随着SQL中IN的里面的值个数增加，SQL的执行计划会更复杂，占用的内存将会变大，这将会增加服务器CPU及内存成本。 评估在IN里面一次放多少个值还需要考虑应用服务器本地内存的开销，有并发访问时要计算本地数据使用周期内的并发上限，否则可能会导致内存溢出。 综合考虑，一般IN里面的值个数超过20个以后性能基本没什么太大变化，也特别说明不要超过100，超过后可能会引起执行计划的不稳定性及增加数据库CPU及内存成本，这个需要专业DBA评估。 如果确实想使用IN而且里面数量较多时，这个情况有两种解决方式： 将in列表里面的数据放入一张中间小表，采用两个表Hash Join关联的方式处理； 采用str2varList方法将字段串列表转换一个临时表处理； 设置Fetch Size 当我们采用select从数据库查询数据时，数据默认并不是一条一条返回给客户端的，也不是一次全部返回客户端的，而是根据客户端fetch_size参数处理，每次只返回fetch_size条记录，当客户端游标遍历到尾部时再从服务端取数据，直到最后全部传送完成。所以如果我们要从服务端一次取大量数据时，可以加大fetch_size，这样可以减少结果数据传输的交互次数及服务器数据准备时间，提高性能。 123456789101112//以下是jdbc测试的代码，采用本地数据库，表缓存在数据库CACHE中，因此没有网络连接及磁盘IO开销，客户端只遍历游标，不做任何处理，这样更能体现fetch参数的影响：String vsql ="select * from t_employee";PreparedStatement pstmt = conn.prepareStatement(vsql,ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);pstmt.setFetchSize(1000);ResultSet rs = pstmt.executeQuery(vsql);int cnt = rs.getMetaData().getColumnCount();Object o;while (rs.next()) &#123; for (int i = 1; i &lt;= cnt; i++) &#123; o = rs.getObject(i); &#125;&#125; 测试可以看出fetchsize对性能影响还是比较大的，但是当fetchsize大于100时就基本上没有影响了。fetchsize并不会存在一个最优的固定值，因为整体性能与记录集大小及硬件平台有关。根据测试结果建议当一次性要取大量数据时这个值设置为100左右，不要小于40。注意，fetchsize不能设置太大，如果一次取出的数据大于JVM的内存会导致内存溢出，所以建议不要超过1000，太大了也没什么性能提高，反而可能会增加内存溢出的危险。 1234//iBatis的SqlMapping配置文件可以对每个SQL语句指定fetchsize大小，如下所示：&lt;select id="getAllProduct" resultMap="HashMap" fetchSize="1000"&gt; select * from employee&lt;/select&gt; 使用存储过程 大型数据库一般都支持存储过程，合理的利用存储过程也可以提高系统性能。如你有一个业务需要将A表的数据做一些加工然后更新到B表中，但是又不可能一条SQL完成，这时你需要如下3步操作： a：将A表数据全部取出到客户端； b：计算出要更新的数据； c：将计算结果更新到B表。 如果采用存储过程你可以将整个业务逻辑封装在存储过程里，然后在客户端直接调用存储过程处理，这样可以减少网络交互的成本。 当然，存储过程也并不是十全十美，存储过程有以下缺点： a、不可移植性，每种数据库的内部编程语法都不太相同，当你的系统需要兼容多种数据库时最好不要用存储过程。 b、学习成本高，DBA一般都擅长写存储过程，但并不是每个程序员都能写好存储过程，除非你的团队有较多的开发人员熟悉写存储过程，否则后期系统维护会产生问题。 c、业务逻辑多处存在，采用存储过程后也就意味着你的系统有一些业务逻辑不是在应用程序里处理，这种架构会增加一些系统维护和调试成本。 d、存储过程和常用应用程序语言不一样，它支持的函数及语法有可能不能满足需求，有些逻辑就只能通过应用程序处理。 e、如果存储过程中有复杂运算的话，会增加一些数据库服务端的处理成本，对于集中式数据库可能会导致系统可扩展性问题。 f、为了提高性能，数据库会把存储过程代码编译成中间运行代码(类似于java的class文件)，所以更像静态语言。当存储过程引用的对像(表、视图等等)结构改变后，存储过程需要重新编译才能生效，在24*7高并发应用场景，一般都是在线变更结构的，所以在变更的瞬间要同时编译存储过程，这可能会导致数据库瞬间压力上升引起故障(Oracle数据库就存在这样的问题)。 建议：普通业务逻辑尽量不要使用存储过程，定时性的ETL任务或报表统计函数可以根据团队资源情况采用存储过程处理。 使用ResultSet游标处理记录 现在大部分Java框架都是通过jdbc从数据库取出数据，然后装载到一个list里再处理，list里可能是业务Object，也可能是hashmap。由于JVM内存一般都小于4G，所以不可能一次通过sql把大量数据装载到list里。为了完成功能，很多程序员喜欢采用分页的方法处理，如一次从数据库取1000条记录，通过多次循环搞定，保证不会引起JVM Out of memory问题。以下是实现此功能的代码示例，t_employee表有10万条记录，设置分页大小为1000： 12345678910111213141516171819202122232425262728293031d1 = Calendar.getInstance().getTime();//第一次先取出数据总数String vsql = "select count(*) cnt from t_employee";PreparedStatement pstmt = conn.prepareStatement(vsql);ResultSet rs = pstmt.executeQuery();Integer cnt = 0;while (rs.next()) &#123; cnt = rs.getInt("cnt");&#125;//第二次分页取数据Integer lastid = 0;Integer pagesize = 1000;System.out.println("cnt:" + cnt);for (int i = 0; i &lt;= cnt / pagesize; i++) &#123; vsql = "select * from (select * from t_employee where id&gt;? order by id) where rownum&lt;=?"; pstmt = conn.prepareStatement(vsql); pstmt.setFetchSize(1000); pstmt.setInt(1, lastid); pstmt.setInt(2, pagesize); rs = pstmt.executeQuery(); int col_cnt = rs.getMetaData().getColumnCount(); Object o; while (rs.next()) &#123; for (int j = 1; j &lt;= col_cnt; j++) &#123; o = rs.getObject(j); &#125; lastid = rs.getInt("id"); &#125; rs.close(); pstmt.close();&#125; 以上代码实际执行时间为6.516秒 很多持久层框架为了尽量让程序员使用方便，封装了jdbc通过statement执行数据返回到resultset的细节，导致程序员会想采用分页的方式处理问题。实际上如果我们采用jdbc原始的resultset游标处理记录，在resultset循环读取的过程中处理记录，这样就可以一次从数据库取出所有记录。显著提高性能。 这里需要注意的是，采用resultset游标处理记录时，应该将游标的打开方式设置为FORWARD_READONLY模式(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY)，否则会把结果缓存在JVM里，造成JVM Out of memory问题。 123456789101112//代码示例：String vsql ="select * from t_employee";PreparedStatement pstmt = conn.prepareStatement(vsql,ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);pstmt.setFetchSize(100);ResultSet rs = pstmt.executeQuery(vsql);int col_cnt = rs.getMetaData().getColumnCount();Object o;while (rs.next()) &#123; for (int j = 1; j &lt;= col_cnt; j++) &#123; o = rs.getObject(j); &#125;&#125; 调整后的代码实际执行时间为3.156秒 iBatis等持久层框架考虑到会有这种需求，所以也有相应的解决方案，在iBatis里我们不能采用queryForList的方法，而应用该采用queryWithRowHandler加回调事件的方式处理，如下所示：12345678MyRowHandler myrh=new MyRowHandler();sqlmap.queryWithRowHandler("getAllEmployee", myrh);class MyRowHandler implements RowHandler &#123; public void handleRow(Object o) &#123; //todo something &#125;&#125;//iBatis的queryWithRowHandler很好的封装了resultset遍历的事件处理，效果及性能与resultset遍历一样，也不会产生JVM内存溢出。 使用绑定变量 绑定变量是指SQL中对变化的值采用变量参数的形式提交，而不是在SQL中直接拼写对应的值。 非绑定变量写法：Select * from employee where id=1234567 绑定变量写法： Select * from employee where id=? Preparestatement.setInt(1,1234567) Java中Preparestatement就是为处理绑定变量提供的对像，绑定变量有以下优点： 防止SQL注入 提高SQL可读性 提高SQL解析性能，不使用绑定变更我们一般称为硬解析，使用绑定变量我们称为软解析。 数据库SQL执行原理 当一条SQL发送给数据库服务器后，系统首先会将SQL字符串进行hash运算，得到hash值后再从服务器内存里的SQL缓存区中进行检索，如果有相同的SQL字符，并且确认是同一逻辑的SQL语句，则从共享池缓存中取出SQL对应的执行计划，根据执行计划读取数据并返回结果给客户端。如果在共享池中未发现相同的SQL则根据SQL逻辑生成一条新的执行计划并保存在SQL缓存区中，然后根据执行计划读取数据并返回结果给客户端。 为了更快的检索SQL是否在缓存区中，首先进行的是SQL字符串hash值对比，如果未找到则认为没有缓存，如果存在再进行下一步的准确对比，所以要命中SQL缓存区应保证SQL字符是完全一致，中间有大小写或空格都会认为是不同的SQL。 如果我们不采用绑定变量，采用字符串拼接的模式生成SQL,那么每条SQL都会产生执行计划，这样会导致共享池耗尽，缓存命中率也很低。 ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾. SQL语句总结 创建数据库CREATE DATABASE database-name 删除数据库drop database dbname 创建新表DROP TABLE IF EXISTS zf_jg_statistics;CREATE TABLE zf_jg_statistics (id varchar(50) NOT NULL,corp_id varchar(255) DEFAULT NULL COMMENT ‘企业id’,corp_name varchar(50) DEFAULT NULL COMMENT ‘企业名称’,gname varchar(50) DEFAULT NULL COMMENT ‘行业名称，无默认值’,gmjj varchar(50) DEFAULT NULL COMMENT ‘行业分类’,aname varchar(50) DEFAULT NULL COMMENT ‘地区名称’,area varchar(50) DEFAULT NULL COMMENT ‘地区编号’,total int(50) DEFAULT ‘0’ COMMENT ‘风险防控点数，默认值为0’,type int(2) DEFAULT NULL COMMENT ‘每日查还是月查’,scount int(50) DEFAULT ‘0’ COMMENT ‘应查询点数，默认值为0’,detail_count int(50) DEFAULT ‘0’ COMMENT ‘实查询点数，默认值为0’,warm varchar(50) DEFAULT NULL COMMENT ‘警示标示’,frequency varchar(50) DEFAULT NULL COMMENT ‘覆盖率’,time date DEFAULT NULL COMMENT ‘查询时间，无默认值’,sync_timestamp timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘时间戳’,ybtotal int(255) DEFAULT ‘0’,ybzg int(255) DEFAULT ‘0’,yb varchar(255) DEFAULT NULL,zdtotal int(255) DEFAULT ‘0’,zzgl varchar(255) DEFAULT NULL,PRIMARY KEY (id),KEY corp_id (corp_id),KEY time (time) USING BTREE) ENGINE=MyISAM DEFAULT CHARSET=utf8; 根据已有的表创建新表：A：create table tab_new like tab_oldB：create table tab_new as select col1,col2…from tab_old definition only 删除新表drop table tabname 增加一个列Alter table tabnameadd column col type 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 添加主键：Alter table tabnameadd primary key(col) 删除主键：Alter table tabnamedrop primary key(col) 创建索引：create [unique] index idxnameon tabname(col….) 删除索引：drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 创建视图：create view viewnameas select statement 删除视图：drop view viewname 选择：select *from table1 where 范围 插入：insert into table1(field1,field2) values(value1,value2) 删除：delete from table1 where 范围 更新：update table1 set field1=value1 where 范围 查找：select *from table1 where field1 like ’%value1%’—like的语法很精妙，查资料! 排序：select *from table1 order by field1,field2 [desc] 总数：select count as totalcount from table1 求和：select sum(field1) as sumvalue from table1 平均：select avg(field1) as avgvalue from table1 最大：select max(field1) as maxvalue from table1 最小：select min(field1) as minvalue from table1 高级查询运算词 UNION 运算符通过组合其他两个结果表(例如TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随UNION 一起使用时(即UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自TABLE1 就是来自 TABLE2。 EXCEPT 运算符EXCEPT 运算符通过包括所有在TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随EXCEPT 一起使用时(EXCEPT ALL)，不消除重复行。 INTERSECT 运算符INTERSECT 运算符通过只包括TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随INTERSECT 一起使用时(INTERSECT ALL)，不消除重复行。注：使用运算词的几个查询结果行必须是一致的。 外连接 left (outer)join：左外连接(左连接)：结果集几包括连接表的匹配行，也包括左连接表的所有行。 SQL:select a.a,a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c right (outer)join:右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 full/cross (outer)join：全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 分组:Group by:一张表，一旦分组完成后，查询后只能得到组相关的信息。组相关的信息：(统计信息)count,sum,max,min,avg 分组的标准)在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据在selecte统计函数中的字段，不能和普通的字段放在一起; 修改数据库的名称:sp_renamedb ‘old_name’,’new_name’ 复制表(只复制结构,源表名：a新表名：b) (Access可用) 法一：select *into b from a where 1&lt;&gt;1(仅用于SQlServer) 法二：select top 0 * into b from a 拷贝表(拷贝数据,源表名：a目标表名：b) (Access可用) insert into b(a,b, c) select d,e,f from b; 跨数据库之间表的拷贝(具体数据使用绝对路径)(Access可用) insert into b(a,b, c) select d,e,f from b in ‘具体数据库’ where 条件 例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”‘ where.. 子查询(表名1：a 表名2：b) select a,b,c from a where a IN (select d from b) 或者: select a,b,c from a where a IN (1,2,3) 在线视图查询(表名1：a) select * from (SELECT a,b,c FROM a) T where t.a &gt; 1; between的用法,between限制查询数据范围时包括了边界值,not between不包括 select *from table1 where time between time1 and time2 select a,b,c, from table1 where a not between 数值1 and 数值2 in 的使用方法 select *from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’) 两张关联表，删除主表中已经在副表中没有的信息 delete from table1 where not exists( select *from table2 where table1.field1=table2.field1) 四表联查问题： select *from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where ….. 日程安排提前五分钟提醒 SQL:select *from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5 前10条记录 select top 10 * form table1 where 范围 选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.) select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b) 包括所有在TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表 (select a from tableA) except (select a from tableB)except (select a from tableC) 删除重复记录 delete from tablename where id not in (select max(id) from tablename group by col1,col2,…) select distinct *into temp from tablename 列出数据库里所有的表名 select name from sysobjects where type=’U’ //U代表用户 列出表里的所有的列名 select name from syscolumns where id=object_id(‘TableName’) 初始化表table1 truncate TABLE table1 选择从10到15的记录 select top 5 from (select top 15 from table order by id asc) table_别名 order by id desc 查看与某一个表相关的视图、存储过程、函数 select a.*from sysobjects a, syscomments b where a.id = b.id and b.text like ‘%表名%’ 查看当前数据库中所有存储过程 select name as 存储过程名称 from sysobjects where xtype=’P’ 查询用户创建的所有数据库 select *from master..sysdatabases D where sid not in(select sid from master..syslogins where name=’sa’) select dbid,name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01 查询某一个表的字段和数据类型 select column_name,data_type from information_schema.columns where table_name= ‘表名’ 常识 在SQL查询中：from后最多可以跟多少张表或视图：256 在SQL语句中出现Order by,查询时，先排序，后取 在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Database</tag>
        <tag>MySQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位数组]]></title>
    <url>%2F2017%2F10%2F07%2F%E4%BD%8D%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[位数组]]></content>
      <categories>
        <category>Bit_Aarray</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Aarray</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Concurrency]]></title>
    <url>%2F2017%2F10%2F07%2FConcurrency%2F</url>
    <content type="text"><![CDATA[并发，多线程竞态：一个计算结果的正确性与时间有关的现象叫做竞态竞态产生的条件 read-modify-write（例如i++） check-then-act（if条件语句） 原子性 基础类型（除long/double之外）和引用类型变量的写操作都是原子的，long/double变量由于占64位，所以当32位的java虚拟机对这种变量的写操作会被分成两步，先写高位在写低位（或先写低位在写高位），这样就会出现一个线程写高位，而另一个线程写低位的情况，不具备原子性。 使用Lock实现原子性 利用处理器提供的CAS指令（硬件锁） 有序性 重排序：处理器可能不完全按照目标代码所制定的顺序执行指令（对内存访问读写操作的一种的优化，在不影响单线程程序正确性的情况下提高程序的性能），重排序不是必然出现的。 指令重排序（程序顺序与源代码顺序不一致，执行顺序与程序顺序不一致） java平台编译器有两种，静态（javac）和动态（JIT），前者将java源码编译为字节码class文件，后者将字节码动态编译为虚拟机宿主机的本地代码-机器码 例如 Person p = new Person(); 1. objRef = allocate(Person.class); 分配Pserson实例所需的内存空间，并获得一个指向该空间的引用 2. invokeConstrutor(objRef); 调用Person类的构造器初始化objRef引用指向的Person实例 3. p = objRef;3. 将Person实例引用赋值给实例变量p JIT编译器会将操作3排到操作2之前，即JIT编译器在初始化Person实例之前可能已经将该实例的引用写入p实例变量。 处理器的乱序执行，顺序提交：现代处理器为了提高执行效率，往往不是按照程序顺序逐一执行指令，而是动态调整指令的顺序，做到哪条指令准备就绪就先执行哪条，这就是处理器的乱序执行，这些指令执行的结果会先被写入重排序缓冲器（ROB），而不是直接写入寄存器或者内存，重排序缓冲器会将各个指令的执行结果按照相应的指令被读取的顺序提交，即写入到内存或者寄存器中，这就是处理器的顺序提交。也是因此处理器的指令重排序不会影响到单线程程序的正确性。 处理器的猜测执行：向执行if的语句体并将其结果保存在ROB中，然后在判定if的条件体是否成立，若成立，则将ROB中的结果写入到内存中，否则ROB丢弃其结果来实现语句体没有被执行过的效果。 存储子系统重排序（内存重排序）：是一种现象而不是一种动作，并没有真正的改变指令的执行顺序，其排序对象是内存操作的结果。 LoadLoad重排序：处理器的执行顺序为L1-&gt;L2，其他处理器的感知顺序为L2-&gt;L1 StoreStore重排序 LoadStore重排序 StoreLoad重排序 貌似串行语义：重排序并非是任意的，而是遵循一定的规则，从而给单线程造成一种假象（指令按照程序源码顺序执行），这种假象叫做貌似串行语义，其从单线程的角度保证了重排序后的运行结果不会影响到程序的正确性。为了保证串行语义，存在数据依赖，控制依赖的语句不会被重排序。 线程的活性故障 死锁：线程的生命周期状态永远处于非运行状态，相互等待对方 锁死：解锁条件永远得不到满足 活锁：处于运行状态却不执行任务，处于做无用功状态 饥饿：优先级低的线程一直得不到处理器资源 线程的两种创建方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public interface Runnable &#123; public abstract void run();&#125;public class Thread implements Runnable &#123; private static int threadInitNumber; private static synchronized int nextThreadNum() &#123; return threadInitNumber++; &#125; private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123; init(g, target, name, stackSize, null); &#125; private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) &#123; if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) &#123; /* Determine if it's an applet or not */ /* If there is a security manager, ask the security managerwhat to do. */ if (security != null) &#123; g = security.getThreadGroup(); &#125; /* If the security doesn't have a strong opinion of the matteruse the parent thread group. */ if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; /* checkAccess regardless of whether or not threadgroup isexplicitly passed in. */ g.checkAccess(); //Do we have the required permissions? if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); &#125; //8个构造方法， public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0); &#125; Thread(Runnable target, AccessControlContext acc) &#123; init(null, target, "Thread-" + nextThreadNum(), 0, acc); &#125; public Thread(ThreadGroup group, Runnable target) &#123; init(group, target, "Thread-" + nextThreadNum(), 0); &#125; public Thread(String name) &#123; init(null, null, name, 0); &#125; public Thread(Runnable target, String name) &#123; init(null, target, name, 0); &#125; public Thread(ThreadGroup group, String name) &#123; init(group, null, name, 0); &#125; public Thread(ThreadGroup group, Runnable target, String name) &#123; init(group, target, name, 0); &#125; public Thread(ThreadGroup group, Runnable target, String name,long stackSize) &#123; init(group, target, name, stackSize); &#125; /*run()方法由java虚拟机直接调用，但是，java语言并不阻止我们直接调用，如果我们没有启动线程，而是在应用代码中直接调用线程run()方法，那么这个run()方法其实是运行在当前线程（run()方法的调用代码的执行线程）之中，而不是自身线程中，违背了线程创建的初衷，所以应该避免这样做*/ public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 继承Thread类 12345678public void MyThread extends Thread&#123; public void run()&#123;...&#125;&#125;public static void main(String [] args)&#123; MyThread t = new MyThread(); t.start();&#125; 实现Runnable接口 12345678public void MyThread implements Runnable&#123; public void run()&#123;...&#125;&#125;public static void main(String [] args)&#123; Thread t = new Thread(new MyThread()); t.start();&#125; 线程属于一次性用品，即我们不能通过出重新调用一个已经运行结束的线程的start()方法来使其重新运行，start()方法只能被调用一次，多次调用会导致抛出异常 i++三步走 取i的原值到寄存器r1（load(i,r1)） 执行i+1，即寄存器r1的值加1（increment(r1)） 将结果赋值给i，即将寄存器的值写回i对应的内存空间（store(i,r1)） system.out.println(i++)非线程安全 线程方法 currentThread() 返回代码段正在被那个线程调用 isLive() 判断当前才线程是否处于活跃状态（线程启动尚未终止，正在运行或者准备开始运行） sleep() 在指定的毫秒数内让当前正在执行的线程休眠（如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变成false）不会释放对象锁 geiId() stop()停止,suspend()暂停,resume()恢复 已作废方法 interrupt() 在当前线程中打一个停止符号，并未真正停止线程 this.interrupted() 测试当前线程（运行this.interrupted()方法的线程）是否中断，如果是中断（true），则会将其状态标识更改为false，再一次执行该方法时则返回非中断false this.Isinterrupted() 测试线程是否中断（不会清除状态标识） yield() 放弃当前CPU 资源，让给其它任务，放弃时间不确定，有其他任务则放弃，无则继续自身线程 setPriority() 设置优先级（1~10级，优先级具有继承性，优先级高的线程大部分先执行完，(并不代表一定全部先执行完)，CPU只是尽量将执行资源让给优先级高的线程，同时，代码的执行顺序与线程的优先级无关） setDaemon(true为守护进程)，必须发生在start()调用之前 守护进程/用户进程线程的生命周期状态1234567891011//最好通过抛异常来停止线程public void run()&#123; try()&#123; for()&#123; if(this.interrupted())&#123; //return；不建议 threw new InterruptedException(); &#125; &#125; &#125;catch(InterruptedException e)&#123;&#125;&#125; 内部锁（非公平锁）——synchronized（同步）/asynchronized（异步） 关键字synchronized取得是对象锁，而不是一段代码或者方法的锁 A线程持有O对象的Lock锁，B线程可以以异步的方式调用O对象中的非synchronized方法，对于synchronized方法则需要同步等待 脏读：在读取实例变量时，该值已被其他线程修改 synchronized锁 重入，即自己可以再次获取自己的内部锁，synchronized方法内部可以调用本类的其他synchronized方法 出现异常，锁自动释放 同步不具有继承性，子类中重写的方法还得加关键字synchronized实现同步 synchronized（this）{}同步代码块，与synchronized方法类似，锁定整个对象 任意对象的对象监视器synchronized（Object，非this对象），只有在保证同一对象的前提下才能保证同步 synchronized关键字加到static静态方法上是给class类上锁（对类的所有实例对象起作用，与synchronized（xxx.class）效果一样），加到非static方法上是给对象上锁 String常量池缓存带来的麻烦 采用同步代码块synchronized（Object1）和synchronized（Object2）来避免同步带来的死循环无线等待 可见性 程序中的变量可能会被分配到寄存器中，而不是主内存中。每个处理器都有其寄存器，而一个处理器无法读取另一个处理器上的寄存器中的内容。处理器对主内存的访问也不是直接访问，而是通过高速缓存子系统进行的。一个处理器上运行的线程对变量的更新可能只是更新到该处理器的写缓冲器中，还没有到达该处理器的高速缓存中，更不用说到主内存中了。而一个写缓冲器中的内容无法被另一个处理器读取。 处理器不是直接与主内存(RAM)打交道而执行内存的读写操作，而是通过寄存器，高速缓存，写缓冲器，和无效队列等部件执行内存的读写操作。 缓存同步：一个处理器不能直接从另一个处理器的高度缓存中读取数据，但是可以通过缓存一致协议来读取处理器高速缓存中的数据，这种方式叫做缓存同步。冲刷处理器缓存：是一个处理器对共享变量的更新最终被写入处理器的高速缓存或主内存中，而不是停留在写缓冲器中。 刷新处理器缓存：一个处理器在读取共享变量时，如果其他处理器在此之前更新了该变量，该处理器必须从其他处理器高速缓存或主内存中对相应的变量进行缓存同步。 写入一个volatile关键字修饰的变量，会使得相应的处理器执行冲刷处理器缓存的动作。 可见性的保证是通过写线程冲刷处理器缓存和读线程刷新处理器缓存这两个动作实现的，java平台中，锁的获得隐含着刷新处理器缓存这个动作，这使得读线程在执行临界区代码前可以将写线程对共享变量的更新同步到该线程执行处理器的高速缓存中，而锁的释放隐含着冲刷处理器缓存的动作，这使得写线程对共享变量的更新能够被推送到该执线程执行处理器的高速缓存中，从而对读线程可以同步。 volatile关键字——使变量在多个线程间可见 解决同步/异步死循环，强制从公共堆栈中获取变量的值，而不是从线程私有数据栈中取得变量值 只能修饰变量 不支持原子性（例如i++） 多线程访问不会发生阻塞 synchronized关键字解决的是多个线程间的访问资源的同步性（同步公共堆栈中变量的值与线程私有数据栈中变量值），而volatile关键字解决的是多个线程间的可见性问题 线程间通信 等待/通知机制 使用sleep()结合whlie(true)死循环实现多个线程间通信 ？？？ 123456789//通过抛异常来停止线程public void run()&#123; try()&#123; while(true)&#123; if(条件成立) threw new InterruptedException(); &#125; &#125;catch(InterruptedException e)&#123;&#125;&#125; wait/notify机制，wait()方法和notify()方法都是Object类的方法，无论是wait还是notify，在执行调用之前都必须获得该对象的对象锁（即只能在同步方法或代码块中调用），wait调用发生后，当前线程自动释放锁进入等待队列，notify调用后（当前线程不会马上释放对象锁，要等程序执行完，即退出synchronized代码块后才会释放对象锁），线程规划器随机挑选一个等待同一资源的呈wait状态的线程（即等待队列），对其发出notify通知，并使其获得该资源的对象锁 wait(long) 等待一段时间是否有线程对锁进行唤醒，超过此时间没有，则自动唤醒 生产者/消费者模式 管道通信，字节流（PipeInputStream，PipeOutStream），字符流（PipeReader，PipeWriter） join()方法——等待线程对象销毁（例如线程A需要用到线程B的结果，则要用到join，A阻塞等到B结束之后才能继续执行，类似于使线程排队） join(long)等待一定时间后自动继续执行（内部使用wait(long)来实现，所以具有释放锁的特点） ThreadLocal——解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值，不同的线程中的值可以放入T和readLocal类中进行保存 InheritableThreadLocal类可以使得子线程获取父线程继承下来的值 显示锁（公平/非公平锁）——Lock ReentrantLock类 12345678public void display()&#123; private Lock lock = new ReentrantLock(); //lock()方法获取锁 lock.lock(); ... //unlock()方法释放锁 lock.unlock();&#125; Condition实现等待/通知，一个Lock对象中可以创建多个Conditoin实例（对象监视器），从而实现选择性通知 123456789101112public void display()&#123; private Lock lock = new ReentrantLock(); Conditoin condition1 = lock.newCondition(); //Conditoin condition2 = lock.newCondition(); lock.lock(); condition.await();//等价于Object的wait()方法 //condition.await(long);//等价于Object的wait(long)方法 ... condition.signal();//等价于Object的notify()方法 //condition.signalAll();//等价于Object的notifyAll()方法 lock.unlock();&#125; 公平锁（按照加锁顺序，先来先得），非公平锁（抢占机制，随机分配） getHoldCount() 查询当前线程保持此锁定的个数，也就是调用lock()方法的次数 getQueueLength() 返回正等待获取此锁定的线程估计数 getWaitQueueLength(Condition condition)返回正等待与此锁定相关给定条件Condition的线程估计数 hasQueuedThread(Thread thread) 查询指定线程是否正在等待获取此锁定 hasQueuedThreads() 查询是否有线程正在等待获取此锁定 hasWaiters(Condition condition) 查询是否有线程正在等待获取此锁定有关的condition条件 isFair() 判定是否为公平锁 IsHeldByCurrentThread() 查询当前线程是是否保持此锁定 isLocked() 查询此锁定是否由任意线程保持 tryLock()：尝试申请相应Lock实例锁表示的锁，如果该锁未被其他任何线程所持有，则获得该锁，并返回true，否则什么操作都不做，只是返回false； 123Lock lock = ...if(lock.tryLock())&#123;...&#125;else&#123;...&#125; 使用Condition实现顺序执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; ... int next = 1; private Lock lock = new ReentrantLock(); Conditoin condition1 = lock.newCondition(); Conditoin condition2 = lock.newCondition(); Conditoin condition3 = lock.newCondition(); Thread thread1 = new Thread()&#123; public void run()&#123; try&#123; lock.lock(); while(next!=1)&#123;condition1.await();&#125; System.out.println(1); next = 2; condition2.signalAll(); &#125;catch(InterruptedException e)&#123;&#125; finally&#123;lock.unlock();&#125; &#125; &#125;; Thread thread2 = new Thread()&#123; public void run()&#123; try&#123; lock.lock(); while(next!=2)&#123;condition2.await();&#125; System.out.println(2); next = 3; condition3.signalAll(); &#125;catch(InterruptedException e)&#123;&#125; finally&#123;lock.unlock();&#125; &#125; &#125;; Thread thread3 = new Thread()&#123; public void run()&#123; try&#123; lock.lock(); while(next!=3)&#123;condition3.await();&#125; System.out.println(3); next = 1; condition1.signalAll(); &#125;catch(InterruptedException e)&#123;&#125; finally&#123;lock.unlock();&#125; &#125; &#125;; ...&#125; ReentrantReadWriteLock类-读写锁 读读共享 写写互斥 读写互斥 写读互斥123456private Lock lock = new ReentrantLock();lock.readLock().lock();lock.writeLock().lock();...lock.writeLock().unlock();lock.readLock().unlock();]]></content>
      <categories>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrency</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥Map源码]]></title>
    <url>%2F2017%2F09%2F30%2F%E5%88%9D%E7%AA%A5Map%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[MapHashMap数组+链表+红黑树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //默认容量 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认负载因子为0.75，使性能在空间和时间上达到了平衡，只有当表到达3/4满时才会进行再散列，增大负载因子可以降低所需空间，但会增加查找时间 static final float DEFAULT_LOAD_FACTOR = 0.75f; //当链表长度超过8时转换为红黑树 static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; //内部节点类，实现了map接口内的entry接口，所以hashmap中的每一个键值对都是一个Entry&lt;K,V&gt; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;&#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; ... &#125; static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; //构造方法，自定义容量和负载因子 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; //构造方法，自定义容量和默认负载因子 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; //构造方法，默认负容量和默认负载因子 public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;&#125; public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; //通过key值获取value值 final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; /*判断table数组是否为空，数组长度是否为零，判断所给hash值对应的数组下标中的元素是否为空。它通过 h &amp; (table.length -1) 来得到该对象的保存位，即table数组的下标，而HashMap底层数组的长度总是 2 的 n 次方，这是HashMap在速度上的优化（保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方）。当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。*/ if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null) &#123; //验证数组tab[(n - 1) &amp; hash]中存的第一个节点是否为所需节点，是则返回 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //验证数组table中所存的节点类型是否为红黑树，是则按照红黑树的方式继续查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); /*调用红黑树的查找方法find final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; */ //如果节点类型为链表，则按照链表的方式进行查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; public boolean containsKey(Object key) &#123;return getNode(hash(key), key) != null;&#125; public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //table数组为空或长度为零，重新调整数组大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //hash值对应的数组下标的位置为空，则直接构造节点插入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //如果hash值对应的数组下标的位置中的元素与插入元素相同 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //如果hash值对应的数组下标的位置中的元素类型为红黑树，则按照红黑树方式插入 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //如果hash值对应的数组下标的位置中的元素类型为链表，则按照链表方式插入 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表插入元素后要检验链表大小是否大于8，实则需将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; /*我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。*/ ++modCount; /*threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子，即扩容 */ if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; //直接将table数组大小至为0并将数组元素均至为空，然后交由GC回收 public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; //entrySet遍历 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125;&#125; LinkedHashMap(extends HashMap)继承自HashMap，但是比HashMap多了一组双向链表来维持插入顺序，或者是最近最少使用的次序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class LinkedHashMap&lt;K,V&gt;extends HashMap&lt;K,V&gt;implements Map&lt;K,V&gt;&#123; //节点移除后，双向链表删除该节点 void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; &#125; //节点插入后， void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125; &#125; //节点访问后，移动节点到链表最后 void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p =(LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125; public void clear() &#123; super.clear(); //双向链表首尾指针至空 head = tail = null; &#125; TreeMap基于红黑树，由Comparable或Comparator排序而成]]></content>
      <categories>
        <category>Source_Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
        <tag>Source_Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥Set源码]]></title>
    <url>%2F2017%2F09%2F30%2F%E5%88%9D%E7%AA%A5Set%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[SetHashSet（HashMap的HashMap版本）LinkedHashSet（LinkedHashMap的LinkedHashMap版本）TreeSet（TreeMap的TreeMap版本） 123456789101112131415public class HashSet&lt;E&gt;extends AbstractSet&lt;E&gt;implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); //构造方法，直接调用HashMap的构造方法生成entry&lt;E,Object&gt; //类似的所有其他构造方法均直接调用HashMap的构造方法生成 public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125;]]></content>
      <categories>
        <category>Source_Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Source_Code</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥List源码]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%88%9D%E7%AA%A5List%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ListArrayList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; //Default initial capacity（初始容量为10） private static final int DEFAULT_CAPACITY = 10; //Shared empty array instance used for empty instances. private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //Shared empty array instance used for default sized empty instances. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; // non-private to simplify nested class access private int size; //Constructs an empty list with the specified initial capacity. //带有容量参数的构造方法 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; //Constructs an empty list with an initial capacity of ten. //不含参的构造方法，默认初始化大小为10 public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; //Constructs a list containing the elements of the specifiedcollection //含参构造方法 public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; //Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, ifnecessary, to ensure that it can hold at least the number of elementsspecified by the minimum capacity argument. public void ensureCapacity(int minCapacity) &#123; &#125; private void ensureCapacityInternal(int minCapacity) &#123;&#125; private void ensureExplicitCapacity(int minCapacity) &#123; &#125; //The maximum size of array to allocate.数组分配最大值 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //Increases the capacity to ensure that it can hold at least thenumber of elements specified by the minimum capacity argument. private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; //最大容量 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; //数组大小 public int size() &#123;return size;&#125; //判空 public boolean isEmpty() &#123; return size == 0;&#125; //判包含 public boolean contains(Object o) &#123;return indexOf(o) &gt;= 0; &#125; //获取元素下标 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; //获取最后一次出现的下标 public int lastIndexOf(Object o) &#123; if (o == null) &#123; //倒序循环 for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; //转换成对象数组 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; //转换成具体类型数组 @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; //根据下标获取元素值 public E get(int index) &#123; //边界检查 rangeCheck(index); return elementData(index); &#125; //设置元素值（返回旧值） public E set(int index, E element) &#123; rangeCheck(index); //保留旧值 E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; //添加元素 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; //添加元素到指定位置 public void add(int index, E element) &#123; //检查范围 rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // //数组移动，index之后的元素整体后移一位 System.arraycopy(elementData, index, elementData, index + 1,size - index); elementData[index] = element; size++; &#125; //根据下标移除指定元素，并返回该元素的值 public E remove(int index) &#123; //检查范围 rangeCheck(index); modCount++; E oldValue = elementData(index); //计算需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0)&#123; //数组移动 System.arraycopy(elementData, index+1, elementData, index,numMoved); &#125; elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; //移除指定元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //服务于public boolean remove(Object o) 方法 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index,numMoved); elementData[--size] = null; // clear to let GC do its work &#125;//清空ArrayList，将数组元素全都至为空，数组大小设置为0，然后让GC来回收内存空间 public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; //将一个容器中的元素全部添加到list后 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; //将一个容器中的元素全部插入到list中 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index +numNew,numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; //删除置顶区间的元素 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex,numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); //数组前移后剩下的位置的值至为空，让GC回收该空间 for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; //数组上边界检查 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; //添加元素前的数组上下边界检查 private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; public boolean removeAll(Collection&lt;?&gt; c) &#123; //判空 Objects.requireNonNull(c); return batchRemove(c, false); &#125; /*判空requireNonNull()方法源码如下 public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj; &#125; */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; if (r != size) &#123; System.arraycopy(elementData, r,elementData, w,size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; //元素迭代遍历 public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); &#125; public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //内部类 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123;&#125; public E next() &#123;&#125; public void remove() &#123;&#125; public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; //内部类 private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123;&#125; public int nextIndex() &#123;&#125; public int previousIndex() &#123;&#125; public E previous() &#123;&#125; public void set(E e) &#123;&#125; public void add(E e) &#123;&#125; &#125; //返回子数组 public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; //边界检查 subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; //内部类返回子数组 private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123;&#125; public E get(int index) &#123;&#125; public int size() &#123;&#125; public void add(int index, E e) &#123;&#125; public E remove(int index) &#123;&#125; protected void removeRange(int fromIndex, int toIndex) &#123;&#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;&#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; //匿名内部类 return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123;&#125; public E next() &#123;&#125; public boolean hasPrevious() &#123;&#125; public E previous() &#123;&#125; public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;&#125; public int nextIndex() &#123;&#125; public int previousIndex() &#123;&#125; public void remove() &#123;&#125; public void set(E e) &#123;&#125; public void add(E e) &#123;&#125; final void checkForComodification() &#123;&#125; &#125;; &#125; &#125; //遍历 public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; LinkedList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412public class LinkedList&lt;E&gt;extends AbstractSequentialList&lt;E&gt;implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializabl&#123; transient int size = 0; transient Node&lt;E&gt; first;//链首 transient Node&lt;E&gt; last;//链尾 public LinkedList() &#123;&#125; public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //链首插入元素 private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; &#125; //链尾插入元素 void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; public void addFirst(E e) &#123;linkFirst(e);&#125; public void addLast(E e) &#123;linkLast(e);&#125; public boolean add(E e) &#123;linkLast(e);return true;&#125; //节点前插入 void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; //去链首 private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; //去链尾 private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; //移除链首元素 public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; //移除链尾元素 public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; //去节点 E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; //获取链首元素 public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125; //获取链尾元素 public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125; //判包含 public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; public int size() &#123;return size; &#125; //移除元素o public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;return addAll(size, c);&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;//转成数组循环添加&#125; public void clear() &#123;//循环至空，包括值，前指针，后指针 &#125; public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; public E set(int index, E element) &#123;&#125; public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125; public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size; &#125; private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; //收尾两个指针目的就是加快查找目标元素 Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; public int lastIndexOf(Object o) &#123;&#125; //队列操作，返回队首元素 public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; public E element() &#123; return getFirst(); &#125; //队列操作，去除队首元素 public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; public E remove() &#123; return removeFirst(); &#125; //队列操作，队尾入队列 public boolean offer(E e) &#123; return add(e); &#125; // 队列操作，队头入队列（双向链表） public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; public boolean offerLast(E e) &#123; addLast(e); return true; &#125; public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item; &#125; public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125; public void push(E e) &#123; addFirst(e); &#125; public E pop() &#123; return removeFirst(); &#125; public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index); &#125; //迭代遍历内部类 private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125; public boolean hasPrevious() &#123; return nextIndex &gt; 0; &#125; public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; public void remove() &#123; checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; &#125; public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; &#125; public void add(E e) &#123; checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; //节点内部类，双向链表 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; //反向迭代遍历内部类 private class DescendingIterator implements Iterator&lt;E&gt; &#123; private final ListItr itr = new ListItr(size()); public boolean hasNext() &#123; return itr.hasPrevious(); &#125; public E next() &#123; return itr.previous(); &#125; public void remove() &#123; itr.remove(); &#125; &#125; public Object[] toArray() &#123;&#125; public &lt;T&gt; T[] toArray(T[] a) &#123;&#125;&#125;]]></content>
      <categories>
        <category>Source_Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Source_Code</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射机制]]></title>
    <url>%2F2017%2F09%2F16%2FReflection%2F</url>
    <content type="text"><![CDATA[参考自百度百科-反射机制 反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理。 ClassObject 类作为所有Java 类的继承根源，其内声明了12个方法： public Object() public final Class&lt;?&gt; getClass() public final void notify() public final void notifyAll() public final void wait(long timeout)throws InterruptedException public final void wait(long timeout,int nanos)throws InterruptedException public final void wait() throws InterruptedException public int hashCode() public boolean equals(Object obj) protected Object clone()throws CloneNotSupportedException public String toString() protected void finalize()throws Throwable其中getClass()返回一个Class 对象。Class 类十分特殊。它和一般类一样继承自Object，其实体用以表达Java程序运行时的classes和interfaces，也用来表达enum、array、primitive Java types（boolean, byte, char, short, int, long, float, double）以及关键词void。当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class 对象。如果您想借由“修改Java标准库源码”来观察Class 对象的实际生成时机（例如在Class的constructor内添加一个println()），这样是行不通的！因为Class并没有public constructor。Class是Reflection故事起源。针对任何您想探勘的类，唯有先为它产生一个Class 对象，接下来才能经由后者唤起为数十多个的Reflection APIs。这些APIs将在稍后的探险活动中一一亮相。12345678910public final class Class&lt;T&gt; implements Serializable, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type, java.lang.reflect.AnnotatedElement &#123; //私有构造方法 private Class() &#123;&#125; public String toString() &#123; return ( isInterface() ? "interface " : (isPrimitive() ? "" : "class ")) + getName();&#125; Class object 诞生管道 运用getClass() Class c1 = str.getClass(); ```122. 运用Class.getSuperclass()```java Class c2 = c1.getSuperclass(); 运用static method——Class.forName()（最常被使用） Class c1 = Class.forName ("java.lang.String"); ```1234567894. 运用primitive wrapper classes的TYPE 语法```java Class c1 = Boolean.TYPE Class c3 = Character.TYPE; Class c5 = Integer.TYPE; Class c6 = Long.TYPE; Class c7 = Float.TYPE; Class c8 = Double.TYPE; Class c9 = Void.TYPE; Reflection 的三个动态性质： 运行时生成instances public Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)（同下） public Constructor&lt;?&gt;[] getDeclaredConstructors() public Constructor getConstructor(Class&lt;?&gt;… parameterTypes) public Constructor&lt;?&gt;[] getConstructors()12345678910111213//无参构造函数Class&lt;?&gt; c = Class.forName("DynTest");Object obj = null;obj = c.newInstance(); //有参构造函数， 需要获取响应的构造方法Class&lt;?&gt; c = Class.forName("DynTest");Class&lt;?&gt;[] pTypes = new Class&lt;?&gt;[] &#123; double.class, int.class &#125;;Constructor&lt;?&gt; ctor = c.getConstructor(pTypes);//Constructor&lt;?&gt; ctor = c.getConstructor(double.class, int.class);Object obj = null;Object[] arg = new Object[] &#123;3.14159, 125&#125;; obj = ctor.newInstance(arg);//obj = ctor.newInstance(3.14159, 125); 执行期唤起methods 索取Method object时不需指定回返类型，因为method overloading机制要求signature（署名式）必须唯一，而回返类型并非signature的一个成份。换句话说，只要指定了method名称和参数列，就一定指出了一个独一无二的method。 public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)throws NoSuchMethodException,SecurityException（返回一个Method对象，该对象反映了由此Class对象表示的类或接口的指定已声明方法） public Method getMethod(String name,Class&lt;?&gt;… parameterTypes)throws NoSuchMethodException,SecurityException（返回一个Method对象，该对象反映此Class对象所表示的类或接口的指定公共成员方法） public Method[] getDeclaredMethods()throws SecurityException（返回一个包含Method对象的数组，该对象反映了由此Class对象表示的类或接口的所有已声明方法，包括public，protected，default（package）访问和private方法，但不包括继承方法。） public Method[] getMethods()throws SecurityException（返回一个包含Method对象的数组，该对象反映了由此Class对象表示的类或接口的所有公共方法，包括由类或接口声明的那些以及从超类和超接口继承的那些方法。） 123456789101112131415161718public String func(String s, Hashtable ht)&#123; System.out.println("func invoked"); return s;&#125;public static void main(String args[])&#123; Class c = Class.forName("Test"); Class ptypes[] = new Class[2]; ptypes[0] = Class.forName("java.lang.String"); ptypes[1] = Class.forName("java.util.Hashtable"); //获取指定方法 Method m = c.getMethod("func",ptypes); Test obj = new Test(); //Test obj = (Test)c.newInstance(); Object arg[] = new Object[2]; arg[0] = new String("Hello,world"); arg[1] = null; String r = (String)m.invoke(obj, arg);&#125; 运行时改动fields。 public Field getField(String name)（同上） public Field[] getFields() public Field getDeclaredField(String name) public Field[] getDeclaredFields()1234567891011public class Test &#123; public double d; public static void main(String args[])&#123; Class c = Class.forName("Test"); Field f = c.getField("d"); //指定field 名称 Test obj = new Test(); System.out.println("d= " + (Double)f.get(obj)); f.set(obj, 12.34); System.out.println("d= " + obj.d); &#125;&#125; 12345678910111213141516171819202122232425//实际应用样例Class cname=null;Object theInst = null;try &#123; cname = Class.forName (className); 由字符串找到相应的类 theInst=(Object)cname.newInstance(); 实例化初始类&#125;catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; Method[] methodes = cname.getDeclaredMethods(); 获取类中所有的方法for (int i = 0; i &lt; methodes.length; i++)&#123; Method method = methodes[i]; if (method.getName().equals(methodName)) 查找并判定与既定方法相同的方法 &#123; Object result=null; try&#123; System.out.println(method.getName()); result = method.invoke(theInst, arg);执行相应的方法(agr为方法所需要的参数，不止一个可能) &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Reflection</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节序]]></title>
    <url>%2F2017%2F09%2F09%2F%E5%AD%97%E8%8A%82%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[字节序 顾名思义，字节顺序，又称端序或尾序。在计算机科学领域中，是跨越多字节的程序对象的存储规则。 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。大端模式和小端模式的起源 关于大端小端名词的由来，有一个有趣的故事，来自于Jonathan Swift的《格利佛游记》：Lilliput和Blefuscu这两个强国在过去的36个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可以那时的皇帝的祖父由于小时侯吃鸡蛋，按这种方法把手指弄破了，因此他的父亲，就下令，命令所有的子民吃鸡蛋的时候，必须先打破鸡蛋较小的一端，违令者重罚。然后老百姓对此法令极为反感，期间发生了多次叛乱，其中一个皇帝因此送命，另一个丢了王位，产生叛乱的原因就是另一个国家Blefuscu的国王大臣煽动起来的，叛乱平息后，就逃到这个帝国避难。据估计，先后几次有11000余人情愿死也不肯去打破鸡蛋较小的端吃鸡蛋。这个其实讽刺当时英国和法国之间持续的冲突。Danny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。 ##什么是大端和小端 小端就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 大端就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 比如数字0x12 34 56 78在内存中的表示形式为： 大端模式：(低地址 -&gt; 高地址)0x12 | 0x34 | 0x56 | 0x78 小端模式：(低地址 -&gt; 高地址)0x78 | 0x56 | 0x34 | 0x12 可见，大端模式和字符串的存储模式类似。 大端小端没有谁优谁劣，各自优势便是对方劣势： 小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。 大端模式 ：符号位的判定固定为第一个字节，容易判断正负。 为什么会有大小端模式之分呢？ 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。 如何判断机器的字节序12345678910111213141516171819202122232425BOOL IsBigEndian() &#123; int a = 0x1234; char b = *(char *)&amp;a; //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分 if( b == 0x12) &#123; return TRUE; &#125; return FALSE; &#125;//联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：BOOL IsBigEndian() &#123; union NUM &#123; int a; char b; &#125;num; num.a = 0x1234; if( num.b == 0x12 ) &#123; return TRUE; &#125; return FALSE; &#125;]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建对象]]></title>
    <url>%2F2017%2F09%2F02%2FJava%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[创建对象的四种方式 new语句 Object.clone()方法 序列化、反序列化 反射手段,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法 new语句调用类的构造方法创建对象person p = new person(8); Object.clone()方法### API中定义为protected Object clone() throws CloneNotSupportedException{}，即意味着该方法只对其子类可见！ 与此同时API还强调Throws:CloneNotSupportedException - if the object’s class does not support the Cloneable interface. Subclasses that override the clone method can also throw this exception to indicate that an instance cannot be cloned.即意味着想要实现复制克隆的类必须实现cloneable接口,而该接口中并无任何方法，其作用可以看做是一个标识！ 浅复制，如需实现深拷贝，则需重新实现clone（）；实例1234567891011121314151617public class Person implements Cloneable&#123; public int number; person(int number)&#123; this.number = number; &#125; public person getInstance() throws CloneNotSupportedException&#123; return (Person) this.clone(); &#125;&#125;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Person p = new Person(8); Person temp = p.getInstance(); System.out.println(temp.number); &#125;&#125; 序列化、反序列化ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;Person.java&quot;)); Person p = (Person) in.readObject(); 反射手段,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法 调用java.lang.Class类的newInstance()实例方法 //第一种方式 Person p = (Person) Class.forName(“other.Person”).newInstance(); //第二种方式 Person p1 = Person.class.newInstance(); 调用java.lang.reflect.Constructor 类的newInstance()实例方法 Constructor c = Person.class.getConstructor(); Person p = c.newInstance();]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visitor Pattern]]></title>
    <url>%2F2017%2F08%2F26%2FVisitorPattern%2F</url>
    <content type="text"><![CDATA[Visitor Pattern（访问者模式）Represent an operation to be performed on the elements of an object structure.Visitor lets you define a new operation without changing the classes of the elements on which it operates.（封装一些作用于某种数据结构中的各种元素，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。） 抽象元素（Element）：一个抽象类，定义了接受访问者的accept方法 具体元素（ConcreteElement）：Element的子类 抽象访问者(Visitor)：一个接口，定义了操作具体元素的方法 具体访问者(ConcreteVisitor)：抽象访问者接口的实现类 应用场景：双重分派（数据的存储和操作解耦）,不同的访问者访问同一元素，进行的操作不同，结果也不同，但访问这一动作共同的，只是传入的对象不同，导致操作/结果不同 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Elementpublic abstract class Element&#123; public abstract void accept(Visitor v); public abstract double showElectricAmount(); public abstract void setElectricAmount(double n); &#125;//ConcreteElementpublic class ConcreteElement extends Element&#123; double count; public void accept(Visitor v)&#123; System.out.println(v.visitor(this)); &#125; public double showElectricAmount()&#123; return count; &#125; public void setElectricAmount(double n)&#123; count = n; &#125;&#125;//Visitorpublic interface Visitor&#123; public double visitor(Element element);&#125;//ConcreteVisitorpublic class ConcreteVisitorOne implements Visitor&#123; public double visitor(Element element)&#123; return element.showElectricAmount(); &#125;&#125;public class ConcreteVisitorTwo implements Visitor&#123; public double visitor(Element element)&#123; return element.showElectricAmount()+1; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Element e = new ConcreteElement(); Visitor v = new ConcreteVisitorOne(); e.setElectricAmount(20); e.accept(v); v = new ConcreteVisitorTwo(); e.accept(v); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template Method Pattern]]></title>
    <url>%2F2017%2F08%2F26%2FTemplateMethodPattern%2F</url>
    <content type="text"><![CDATA[Template Method Pattern（模板方法模式）Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclass redefine certain steps of an algorithm without changing the algorithm’s structure. （定义一个操作中的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。） 抽象模板（AbstractTemplate）：一个抽象类,定义若干方法表示一个算法的步骤，有抽象方法也有非抽象方法，抽象方法表示原子操作，非抽象方法表示原子步骤 具体模板（ConcreteTemplate）：抽象模板的子类，实现抽象模板的原子操作 应用场景：非抽象方法负责定义步骤流程，钩子方法，子类可以按照抽象模板的规定步骤进行（用final修饰来强制继承不能改动），也可重写非抽象方法来自己定义步骤流程，或者还可以在确定什么样的条件下去执行算法的哪些步骤（boolean返回类型的钩子方法的用途） javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930//AbstractTemplatepublic abstract class Template&#123; public abstract void first(); public abstract void second(); public abstract void third(); public final void templateMethod()&#123; first(); second(); third(); &#125;&#125;//ConcreteTemplatepublic class ConcreteTemplate extends Template&#123; public void first()&#123; System.out.println("首先"); &#125; public void second()&#123; System.out.println("然后"); &#125; public void third()&#123; System.out.println("其次"); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Template t = new ConcreteTemplate(); t.templateMethod(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Strategy Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FStrategyPattern%2F</url>
    <content type="text"><![CDATA[Strategy Pattern（策略模式）Define a family of algorithms, encapsulate each one, and make them interchangeable.（定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。） 策略（Strategy）：一个接口 上下文（Context）：依赖于策略接口的类（组合关系） 具体策略（ConcreteStrategy）：策略接口的实现类 应用场景：一个类定义了多种行为构成了多个条件分支（封装算法的细节） javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Strategypublic interface Strategy&#123; public double computerAverage(double [] a); &#125;//Contextpublic class AverageScore&#123; //组合 Strategy stratrgy; public void setStrategy(Strategy stratrgy)&#123; this.stratrgy = stratrgy; &#125; public double getAverage(double [] a)&#123; return stratrgy.computerAverage(a); &#125;&#125;//ConcreteStrategypublic class StrategyA implements Strategy &#123; public double computerAverage(double [] a)&#123; double average = 0; for (double i : a) &#123; average += i; &#125; average /=a.length; return average; &#125;&#125;import java.util.Arrays;public class StrategyB implements Strategy &#123; public double computerAverage(double [] a)&#123; double average = 0; Arrays.sort(a); for (int i = 1;i &lt; a.length-1 ;i++ ) &#123; average += a[i]; &#125; average /=(a.length-2); return average; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; double [] tuple = new double[]&#123;90,90,98,87,76,45&#125;; AverageScore ave = new AverageScore(); //策略A ave.setStrategy(new StrategyA()); double score = ave.getAverage(tuple); //策略B ave.setStrategy(new StrategyB()); double score1 = ave.getAverage(tuple); System.out.printf("%10f %10f",score,score1); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[State Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FStatePattern%2F</url>
    <content type="text"><![CDATA[State Pattern（状态模式）Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.（当一个对象在状态改变时允许其改变行为，这个对象看起来像改变了其类。） 抽象状态（State）：一个接口或者抽象类 环境（Context）：依赖于策略接口的类（组合关系） 具体状态（ConcreteState）：状态接口（抽象类）的实现类（扩展类） 应用场景：一个对象的状态依赖于它的行为，状态随着行为的改变为改变 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Statepublic abstract class State&#123; public abstract void shoot(); public abstract void loadBullets();&#125;//Contextpublic class Gun&#123; public State stateThree,stateTwo,stateOne,stateNull; public State state; public Gun()&#123; stateThree = new BulletStateThree(this); stateTwo = new BulletStateTwo(this); stateOne = new BulletStateOne(this); stateNull = new BulletStateNull(this); state = stateThree; &#125; public void setState(State state)&#123; this.state = state; &#125; public void fire()&#123; state.shoot(); &#125; public void load()&#123; state.loadBullets(); &#125;&#125;//ConcreteStatepublic class BulletStateNull extends State&#123; Gun gun; BulletStateNull(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("没有子弹了！"); &#125; public void loadBullets()&#123; System.out.println("装弹-------"); gun.setState(gun.stateThree); &#125;&#125;public class BulletStateOne extends State&#123; Gun gun; BulletStateOne(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("射出一颗子弹！"); gun.setState(gun.stateNull); &#125; public void loadBullets()&#123; System.out.println("无法装弹！"); &#125;&#125;public class BulletStateTwo extends State&#123; Gun gun; BulletStateTwo(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("射出一颗子弹！"); gun.setState(gun.stateOne); &#125; public void loadBullets()&#123; System.out.println("无法装弹！"); &#125;&#125;public class BulletStateThree extends State&#123; Gun gun; BulletStateThree(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("射出一颗子弹！"); gun.setState(gun.stateTwo); //gun,setState(new BulletStateTwo(gun)); &#125; public void loadBullets()&#123; System.out.println("无法装弹！"); &#125;&#125;//Testpublic class Application &#123; public static void main(String[] args) &#123; Gun gun = new Gun(); gun.fire(); gun.fire(); gun.fire(); gun.fire(); gun.load(); gun.fire(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Singleton Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FSingletonPattern%2F</url>
    <content type="text"><![CDATA[Singleton PatternEnsure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。） 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 123456789101112131415161718192021public class Singleton &#123; /* 立即加载/恶汉模式 在使用类的时候就已经将对象创建完毕，在调用方法前，实例已经被创建 private static Singleton instance = new Singleton(); 延迟加载/懒汉模式 在调用get()方法时实例才被创建 public static Singleton getInstance() &#123; instance = new Singleton(); &#125; */ //持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 private static Singleton instance = null; //私有构造方法，防止被实例化 private Singleton() &#123;&#125; //静态工程方法，创建实例 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 上面的类在单线程情况下不会出错，但是如果我们把它放入多线程的环境下，就会出现问题了，如何解决？我们可以对getInstance方法加synchronized关键字，如下：123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 但是，synchronized关键字会锁住整个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都会对对象上锁，事实上，我们只需要在第一次创建对象的时候需要加锁，之后就不需要了，所以，我们进一步改进为：12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (instance) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 如果不了解jvm中指令重排的同学可能认为上面的改进已经算是完善了，但是，在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton()语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例： a&gt;A、B线程同时进入了第一个if判断 b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton(); c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。 d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。 e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。 所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，在写多线程环境下的程序是有一定难度的。我们对该程序做进一步优化：1234567//静态内置类实现单例private static class SingletonFactory&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonFactory.instance; &#125; 实际上，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们可以暂时总结一个完整的单例模式如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Singleton &#123; //私有构造方法，防止被实例化 private Singleton() &#123;&#125; //此处使用一个内部类来维护单例 private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; //获取实例 public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; &#125; //变形，使用static代码块实现public class Singleton &#123; private static Singleton instance = null； //私有构造方法内放置static代码块，里面实例化对象 private Singleton() &#123; static&#123; instance = new Singleton(); &#125; &#125; //获取实例 public static Singleton getInstance() &#123; return instance; &#125; &#125; //扩展，使用枚举enum实现public class Singleton &#123; public enum EnumSingleton&#123; connectionFactory； private Connection connection; private EnumSingleton&#123; ... connection = DriverManager.getConnection(url,username,password); &#125; public Connection getConnection()&#123; return connection; &#125; &#125; public static Connection getConnection() &#123; return EnumSingleton.connectionFactory.getConnection(); &#125; &#125; 静态内置类可以达到线程安全问题，但是当遇到序列化对象时，使用默认的方式运行得到的结果还是多例的12345678910111213141516171819202122232425262728293031323334353637public class MyObject implements Serializable &#123; private static final long serialVersionUID = 888L; private static class MyObjectHandler &#123; private static final MyObject myObject = new MyObject(); &#125; private MyObject() &#123;&#125; public static MyObject getInstance() &#123; return MyObjectHandler.myObject; &#125; //readResolve()方法解决序列化单例模式 protected Object readResolve() throws ObjectStreamException &#123; System.out.println("调用了readResolve方法！"); return MyObjectHandler.myObject; &#125; &#125; //输出hashCode来验证序列化前后对象是否为同一个public class SaveAndRead &#123; public static void main(String[] args) &#123; try &#123; MyObject myObject = MyObject.getInstance(); FileOutputStream fosRef = new FileOutputStream(new File("myObjectFile.txt")); ObjectOutputStream oosRef = new ObjectOutputStream(fosRef); oosRef.writeObject(myObject); oosRef.close(); fosRef.close(); System.out.println(myObject.hashCode()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; FileInputStream fisRef = new FileInputStream(new File("myObjectFile.txt")); ObjectInputStream iosRef = new ObjectInputStream(fisRef); MyObject myObject = (MyObject) iosRef.readObject(); iosRef.close(); fisRef.close(); System.out.println(myObject.hashCode()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FProxypattern%2F</url>
    <content type="text"><![CDATA[Proxy pattern（代理模式）Provide a surrogate (代理) or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。） 抽象主题（Subject）：一个接口 实际主题（RealSubject）：实现了抽象主题接口的类 代理(Proxy)：实现了抽象主题接口的类，含有抽象主题声明的变量，来存放实际主题的实例的引用 应用场景：代理的实例用来控制对他所包含的实际主题的实例的访问，即控制他所代理对象的访问权限（java远程代理RMI同理） javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627//Subjectpublic interface Employee&#123; public String hearPhone();&#125;//RealSubjectpublic class Boss implements Employee&#123; public String hearPhone()&#123; return "面谈吧"; &#125;&#125;//Proxypublic class Secretary implements Employee&#123; Boss boss; Secretary()&#123; boss = new Boss(); &#125; public String hearPhone()&#123; return "我们老板说："+boss.hearPhone(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Secretary s = new Secretary(); System.out.println(s.hearPhone()); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prototype Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FPrototypePattern%2F</url>
    <content type="text"><![CDATA[Prototype Pattern（原型模式）Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。） 抽象原型（Prototype）：一个接口，定义对象复制自身的方法 具体原型（ConcretePrototype）：抽象原型的实现类 应用场景：通过复制原型创建新的对象(序列化/反序列化，Class.clone()克隆，深度克隆) javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Prototypepublic interface Prototype&#123; public Object cloneMe() throws CloneNotSupportedException;&#125;//ConcretePrototypepublic class CloneA implements Prototype,Cloneable &#123; int a; CloneA(int a)&#123; this.a = a; &#125; public Object cloneMe() throws CloneNotSupportedException&#123; CloneA object = (CloneA)clone(); return object; &#125;&#125;import java.io.*;public class CloneB implements Prototype,Serializable &#123; StringBuffer color; public void setColor(StringBuffer c)&#123; color = c; &#125; public StringBuffer getColor()&#123; return color; &#125; public Object cloneMe() throws CloneNotSupportedException&#123; Object object = null; try&#123; ByteArrayOutputStream outOne = new ByteArrayOutputStream(); ObjectOutputStream outTwo = new ObjectOutputStream(outOne); outTwo.writeObject(this); ByteArrayInputStream inOne = new ByteArrayInputStream(outOne.toByteArray()); ObjectInputStream inTwo = new ObjectInputStream(inOne); object = inTwo.readObject(); &#125;catch(Exception e)&#123;&#125; return object; &#125;&#125;//Testpublic class Application &#123; public static void main(String[] args) &#123; try&#123; CloneA c = new CloneA(2); CloneA c1 = (CloneA)c.cloneMe(); System.out.print(c.a+"---"+c1.a); CloneB cc = new CloneB(); cc.setColor(new StringBuffer("A")); CloneB cc1 = (CloneB)cc.cloneMe(); cc1.setColor(new StringBuffer("copyA")); System.out.print(cc.getColor()+"---"+cc1.getColor()); &#125;catch(Exception e)&#123;&#125; &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mediator Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FMediatorPattern%2F</url>
    <content type="text"><![CDATA[Mediator Pattern（中介者模式）Define an object that encapsulates how a set of objects interact.Mediator promotes loose couping by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而使其耦合松散，而且可以独立的改变它们之间的交互。） 中介者（Mediator）：一个接口，定义同事Colleague对象中间用于通信的方法 具体中介者（Invoker）：Mefiator接口的实现类，包含具体同事ConcreteColleague对象的引用 同事（Colleague）：一个接口，定义具体同事要是实现的方法 具体同事（ConcreteColleague）：同事接口的实现类，同事包含中介者的引用，同事之间也可以相互交流 应用场景：避免同事对象之间显示的引用，将同事之间的通信交由中介来负责 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Mediatorpublic interface Mediator&#123; public void registerColleague(Colleague colleague); public void deliverMess(String mess,Colleague... c);&#125;//Invokerimport java.util.ArrayList;public class ConcreteMediator implements Mediator&#123; ArrayList&lt;Colleague&gt; list; ConcreteMediator()&#123; list = new ArrayList&lt;Colleague&gt;(); &#125; public void registerColleague(Colleague colleague)&#123; list.add(colleague); &#125; public void deliverMess(String mess,Colleague... c)&#123; for (Colleague colleague : c) &#123; if(list.contains(colleague)) colleague.receiveMess(mess,colleague); else continue; &#125; &#125;&#125;//Colleaguepublic interface Colleague&#123; public void setName(String name); public String getName(); public void sendMess(String mess,Colleague... c); public void receiveMess(String mess,Colleague c); public void setMediator(Mediator mediator);&#125;//ConcreteColleaguepublic class ConcreteColleague implements Colleague&#123; Mediator mediator; String name; public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125; public void sendMess(String mess,Colleague... c)&#123; mediator.deliverMess(mess,c); &#125; public void receiveMess(String mess,Colleague c)&#123; System.out.println(this.getName()+":来自"+c.getName()+"的消息"); System.out.println("-----------"+mess); &#125; public void setMediator(Mediator mediator)&#123; this.mediator = mediator; mediator.registerColleague(this); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Mediator m = new ConcreteMediator(); Colleague c = new ConcreteColleague(); Colleague c1 = new ConcreteColleague(); Colleague c2 = new ConcreteColleague(); c.setMediator(m); c1.setMediator(m); c2.setMediator(m); c.setName("C"); c1.setName("C1"); c2.setName("C2"); c.sendMess("Hello!",c1,c2); c1.sendMess("Hi",c); c2.sendMess("Hi!",c); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memento Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FMementoPattern%2F</url>
    <content type="text"><![CDATA[Memento Pattern（备忘录模式）Without violating encapsulation， capture and externalize an object’s internal state so that the object can be restored to this state later.（在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原来保存的状态。）Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; //public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; //public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; //Testpublic class Test &#123; public static void main(String[] args) &#123; // 创建原始类 Original origi = new Original("egg"); // 创建备忘录 Storage storage = new Storage(origi.createMemento()); // 修改原始类的状态 System.out.println("初始化状态为：" + origi.getValue()); origi.setValue("niu"); System.out.println("修改后的状态为：" + origi.getValue()); // 回复原始类的状态 origi.restoreMemento(storage.getMemento()); System.out.println("恢复后的状态为：" + origi.getValue()); &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Observer Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FObserverPattern%2F</url>
    <content type="text"><![CDATA[Observer Pattern（观察者模式）Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。） 主题（Subject）：一个接口,规定具体主题需要实现的方法 观察者（Observer）：一个接口，规定了具体观察者用来获取数据的方法 具体主题(ConcreteSubject)：主题接口的实现类，该实例包含观察者所关心的数据（经常变动），含有观察者的引用，以便在数据发生变化时通知观察者更新数据 具体观察者(ConcreteObserver)：观察者接口的实现类，含有具体主题的引用，以便于具体主题将自己添加/删除到其集合中去，成为该主题的观察者 应用场景：观察者对于主题中的数据可采用两种方法——“拉”数据或者——-“推”数据,即主题主动将数据更新推送给观察者，或者只是通知观察者数据已更新，观察者自己调用主题方法实现数据更新，适用于一个对象数据更新时需要通知其他对象（或者让其自行更新） javac -encoding UTF-8 Application.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Subjectpublic interface Subject&#123; public void addObserver(Observer o); public void deleteObserver(Observer o); public void notifyObservers(); public void setDate(String name,String author,String publisher,float price); public String getName(); public float getPrice(); public String getAuthor(); public String getPublisher();&#125;//Observerpublic interface Observer&#123; public void update();&#125;//ConcreteSubjectimport java.util.LinkedList;public class BookStore implements Subject&#123; private String name,author,publisher; private float price; private LinkedList&lt;Observer&gt; list; BookStore()&#123; list = new LinkedList&lt;Observer&gt;(); &#125; public void addObserver(Observer o)&#123; if(!list.contains(o)) list.add(o); &#125; public void deleteObserver(Observer o)&#123; if(list.contains(o)) list.remove(o); &#125; public void notifyObservers()&#123; for (Observer observer : list) &#123; observer.update(); &#125; &#125; public void setDate(String name,String author,String publisher,float price)&#123; this.name = name; this.author = author; this.publisher = publisher; this.price = price; notifyObservers(); //一旦发生数据更新，随即通知各个观察者 &#125; public String getName()&#123; return name; &#125; public float getPrice()&#123; return price; &#125; public String getAuthor()&#123; return author; &#125; public String getPublisher()&#123; return publisher; &#125;&#125;//ConcreteObserverpublic class CustomerOne implements Observer &#123; private Subject subject; private String bookName; private float price; CustomerOne(Subject subject)&#123; this.subject = subject; subject.addObserver(this); &#125; public void update()&#123; bookName = subject.getName(); price = subject.getPrice(); System.out.println(bookName+"和"+price+"更新了"); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Subject s = new BookStore(); Observer o = new CustomerOne(s); s.setDate("设计模式","刘飞","清华出版社",25); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facade Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FFacadePattern%2F</url>
    <content type="text"><![CDATA[Facade Pattern（门面模式）Provide a unified interface to a set of interface in a subsystem.Facede defines a higher-level interface that makes the subsystem easier to use.(要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供了一个高层次的接口，使得子系统更容易使用。) 子系统（Subsystem）:若干类的集合，均不包含外观类的实例引用 外观（Facade）：一个含有子系统中全部或者部分类的实例引用的类 应用场景：跟踪系统使用情况（经过同一个接口），更换系统（只需更改外观接口的代码） javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//Subsystempublic class CPU &#123; public void startup()&#123; System.out.println("cpu startup!"); &#125; public void shutdown()&#123; System.out.println("cpu shutdown!"); &#125; &#125; public class Memory &#123; public void startup()&#123; System.out.println("memory startup!"); &#125; public void shutdown()&#123; System.out.println("memory shutdown!"); &#125; &#125; public class Disk &#123; public void startup()&#123; System.out.println("disk startup!"); &#125; public void shutdown()&#123; System.out.println("disk shutdown!"); &#125; &#125; //Facadepublic class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println("start the computer!"); cpu.startup(); memory.startup(); disk.startup(); System.out.println("start computer finished!"); &#125; public void shutdown()&#123; System.out.println("begin to close the computer!"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println("computer closed!"); &#125; &#125; //Testpublic class Application &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startup(); computer.shutdown(); &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decorator Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FDecoratorPattern%2F</url>
    <content type="text"><![CDATA[Decorator Pattern（装饰模式）Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。） 抽象组件（Component）:抽象类，定义需要进行装饰的方法，被装饰角色 具体组件（ConcreteComponent）:抽象组件的一个子类 装饰（Decorator）：也是抽象组件的一个子类，装饰者角色 具体装饰（ConcreteDecorator）：装饰的一个非抽象子类 应用场景：动态的给对象添加一些额外的方法，改进类的某个对象的功能，调用同样的方法，不一样的结果 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142//Componentpublic abstract class Bird&#123; public abstract int fly();&#125;//ConcreteComponentpublic class Sparrow extends Bird&#123; private final static int DISTANCE = 100; public int fly()&#123; return DISTANCE; &#125;&#125;//Decoratorpublic abstract class Decorator extends Bird&#123; Bird bird; Decorator()&#123;&#125; Decorator(Bird bird)&#123; this.bird = bird; &#125;&#125;//ConcreteDecoratorpublic class ConcreteDecorator extends Decorator&#123; private final static int DISTANCE = 50; ConcreteDecorator(Bird bird)&#123; super(bird); &#125; public int fly()&#123; return bird.fly()+DISTANCE; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Bird bird = new Sparrow(); System.out.println(bird.fly()); bird = new ConcreteDecorator(bird); System.out.println(bird.fly()); bird = new ConcreteDecorator(bird); System.out.println(bird.fly()); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flyweight Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FFlyweightPattern%2F</url>
    <content type="text"><![CDATA[Flyweight Pattern（享元模式）Use sharing to support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细粒度对象。） 享元接口（Flyweight）：一个接口，定义了享元对外公开内部数据的方法以及接受外部数据的方法 具体享元（ConcreteFlyweight）：享元接口的实现类的实例 享元工厂(FlyweightFactory)：一个类，负责创建和管理享元实例，其他对象对享元的请求必须通过工厂才能获得一个享元对象的实例引用 应用场景：利用一个叫做享元的对象来为其他对象提供共享的状态，且保证其他对象不能更改享元中的数据 javac -encoding UTF-8 Application.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Flyweightpublic interface Flyweight&#123; public double getWeight(); public double getWidth(); public double getLength();&#125;//ConcreteFlyweightpublic class Car&#123; Flyweight flyweight; String color; double power; Car(Flyweight flyweight,String color,double power)&#123; this.flyweight = flyweight; this.color = color; this.power = power; &#125; public void print()&#123; System.out.println(color); System.out.println(power); System.out.println(flyweight.getWeight()); System.out.println(flyweight.getWidth()); System.out.println(flyweight.getLength()); &#125;&#125;//FlyweightFactorypublic class FlyweightFactory&#123; static FlyweightFactory factory = new FlyweightFactory(); static Flyweight intrinsic; private FlyweightFactory()&#123;&#125; public static FlyweightFactory getFactory()&#123; return factory; &#125; public Flyweight getFlyweight()&#123; intrinsic = new DateCar(1.43,1.45,5.21); return intrinsic; &#125; //内部类 class DateCar implements Flyweight&#123; private double weight; private double width; private double length; //私有构造方法，不允许其他程序直接使用享元类来直接创建享元对象 private DateCar(double weight,double width,double length)&#123; this.weight = weight; this.width = width; this.length = length; &#125; public double getWeight()&#123; return weight; &#125; public double getWidth()&#123; return width; &#125; public double getLength()&#123; return length; &#125; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; FlyweightFactory factory = FlyweightFactory.getFactory(); Flyweight carIntrinsic = factory.getFlyweight(); Car one = new Car(carIntrinsic,"red",5000); Car two = new Car(carIntrinsic,"blue",3000); one.print(); two.print(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interpreter Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FInterpreterPattern%2F</url>
    <content type="text"><![CDATA[Interpreter Pattern（解释器模式）Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences int the language.（给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445//public interface Expression &#123; public int interpret(Context context); &#125; public class Plus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()+context.getNum2(); &#125; &#125; public class Minus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()-context.getNum2(); &#125; &#125; public class Context &#123; private int num1; private int num2; public Context(int num1, int num2) &#123; this.num1 = num1; this.num2 = num2; &#125; public int getNum1() &#123; return num1; &#125; public void setNum1(int num1) &#123; this.num1 = num1; &#125; public int getNum2() &#123; return num2; &#125; public void setNum2(int num2) &#123; this.num2 = num2; &#125; &#125; //Testpublic class Test &#123; public static void main(String[] args) &#123; // 计算9+2-8的值 int result = new Minus().interpret((new Context(new Plus() .interpret(new Context(9, 2)), 8))); System.out.println(result); &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Command Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FCompositePattern%2F</url>
    <content type="text"><![CDATA[Composite Pattern（组合模式）Compose objects into tree structure to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.（将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。） 抽象组件（Component）:一个接口或者抽象类，定义了个体对象和组合对象需要实现的关于原子操作的方法 Composite节点（Composite Node）:实现了Component接口的类，其中可包含其他Composite节点（组合对象） Leaf节点（Leaf Node）：实现了Component接口的类，不可包含其他Composite节点或者Leaf节点（个体对象） 应用场景：个体对象和组合对象实现于同一接口，形成树形结构（部分-整体层次结构） javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Componentimport java.util.*;public interface MilitaryPerson&#123; public void add(MilitaryPerson person); public void remove(MilitaryPerson person); public MilitaryPerson getChild(int index); public Iterator&lt;MilitaryPerson&gt; getAllChild(); public boolean isLeaf(); public double getSalary(); public void setSalary(double salary); &#125;//Composite Nodeimport java.util.*;public class MilitaryOfficer implements MilitaryPerson&#123; private String name; private double salary; private LinkedList&lt;MilitaryPerson&gt; list; MilitaryOfficer(String name,double salary)&#123; this.name = name; this.salary = salary; list = new LinkedList&lt;MilitaryPerson&gt;(); &#125; public void add(MilitaryPerson person)&#123; list.add(person); &#125; public void remove(MilitaryPerson person)&#123; list.remove(person); &#125; public MilitaryPerson getChild(int index)&#123; return list.get(index); &#125; public Iterator&lt;MilitaryPerson&gt; getAllChild()&#123; return list.iterator(); &#125; public boolean isLeaf()&#123; return false; &#125; public double getSalary()&#123; return salary; &#125; public void setSalary(double salary)&#123; this.salary = salary; &#125;&#125;//Leaf Nodeimport java.util.*;public class MilitarySoldier implements MilitaryPerson&#123; private String name; private double salary; MilitarySoldier(String name,double salary)&#123; this.name = name; this.salary = salary; &#125; public void add(MilitaryPerson person)&#123;&#125; public void remove(MilitaryPerson person)&#123;&#125; public MilitaryPerson getChild(int index)&#123;return null;&#125; public Iterator&lt;MilitaryPerson&gt; getAllChild()&#123;return null;&#125; public boolean isLeaf()&#123; return true; &#125; public double getSalary()&#123; return salary; &#125; public void setSalary(double salary)&#123; this.salary = salary; &#125;&#125;//Testimport java.util.*;public class Application&#123; public static void main(String[] args) &#123; MilitaryPerson 连长 = new MilitaryOfficer("连长",5000); MilitaryPerson 营长 = new MilitaryOfficer("营长",4000); MilitaryPerson 班长 = new MilitaryOfficer("班长",3000); MilitaryPerson 士兵 = new MilitarySoldier("士兵",2000); 连长.add(营长); 营长.add(班长); 班长.add(士兵); System.out.println(computerSalary(连长)); &#125; public static double computerSalary(MilitaryPerson person)&#123; double sum = 0; if(person.isLeaf()==true) sum += person.getSalary(); else&#123; sum += person.getSalary(); Iterator&lt;MilitaryPerson&gt; it = person.getAllChild(); while(it.hasNext())&#123; MilitaryPerson p = it.next(); sum += computerSalary(p); &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Command Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FCommandPattern%2F</url>
    <content type="text"><![CDATA[Command Pattern（命令模式）Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests, and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。） 命令（Command）：一个接口，封装请求的若干方法 请求者（Invoker）：包含Command接口变量的类的实例（组合关系） 接收者（Receiver）：一个类的实例，执行与请求有关的操作 具体命令（ConcreteCommand）：Command接口的实现类 应用场景：请求者与接收者不直接交互，消除彼此的耦合（将命令拆分），命令的撤销（栈的应用）：”\b” 退格键 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Commandpublic interface BattleCommand&#123; abstract void execute();&#125;//Invokerpublic class ArmySuperior&#123; public BattleCommand command; public void setBattleCommand(BattleCommand command)&#123; this.command = command; &#125; public void startExecuteCommand()&#123; command.execute(); &#125;&#125;//Receiverpublic interface Army&#123; public void attack();&#125;public class ArmyA implements Army&#123; public void attack()&#123; System.out.println("炮火攻打县城A外围"); System.out.println("坦克进攻"); System.out.println("步兵进攻"); &#125;&#125;public class ArmyB implements Army&#123; public void attack()&#123; System.out.println("在敌人增援路上埋地雷"); System.out.println("在战壕里射击增援的敌人"); &#125;&#125;public class ArmyC implements Army&#123; public void attack()&#123; System.out.println("佯攻县城B"); &#125;&#125;//ConcreteCommandpublic class CommandA implements BattleCommand&#123; Army army; public CommandA(Army army)&#123; this.army = army; &#125; public void execute()&#123; army.attack(); &#125;&#125;public class CommandB implements BattleCommand&#123; Army army; public CommandB(Army army)&#123; this.army = army; &#125; public void execute()&#123; army.attack(); &#125;&#125;public class CommandC implements BattleCommand&#123; Army army; public CommandC(Army army)&#123; this.army = army; &#125; public void execute()&#123; army.attack(); &#125;&#125;//Testpublic class Application &#123; public static void main(String[] args) &#123; ArmySuperior superior = new ArmySuperior(); Army army = new ArmyA(); BattleCommand command = new CommandA(army); superior.setBattleCommand(command); superior.startExecuteCommand(); army = new ArmyB(); command = new CommandB(army); superior.setBattleCommand(command); superior.startExecuteCommand(); army = new ArmyC(); command = new CommandC(army); superior.setBattleCommand(command); superior.startExecuteCommand(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chain Of Responsibility Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FChainOfResponsibilityPattern%2F</url>
    <content type="text"><![CDATA[Chain Of Responsibility Pattern（责任链模式）Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.（使多个对象有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系 。将这些对象连成一个链，并沿着这条链传递请求，知道有对象处理它为止。） 处理者（Handler）：一个接口,负责规定具体处理者处理用户的请求的方法和具体处理者设置后继对象的方法 具体处理者（ConcreteHandler）：Handler接口的实现类，调用处理者接口规定的方法处理用户的请求，若能处理则进行处理，不能则传给下一节点 应用场景：形成一个处理链，挨个节点判断是否能够进行处理，阶乘的计算（从结果的数据量按需判断那个节点可以容纳结果） javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Handlerpublic interface Handler&#123; public abstract void computerMultiply(String number); public abstract void setNextHandler(Handler handler);&#125;//ConcreteHandlerimport java.util.*;public class UseInt implements Handler&#123; private int result = 1; private Handler handler; public void computerMultiply(String number)&#123; try&#123; int n = Integer.parseInt(number); while(n &gt; 0)&#123; result *=n--; if (result &lt;= 0) &#123; System.out.println("超出int计算范围"); handler.computerMultiply(number); return; &#125; &#125; System.out.println(result); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125;&#125;public class UseLong implements Handler&#123; private long result = 1; private Handler handler; public void computerMultiply(String number)&#123; try&#123; long n = Long.parseLong(number); while(n &gt; 0)&#123; result *=n--; if (result &lt;= 0) &#123; System.out.println("超出long计算范围"); handler.computerMultiply(number); return; &#125; &#125; System.out.println(result); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125;&#125;import java.util.*;import java.math.BigInteger;public class UseBigInteger implements Handler&#123; private BigInteger result = new BigInteger("1"); private Handler handler; public void computerMultiply(String number)&#123; try&#123; BigInteger n = new BigInteger(number); BigInteger ONE = new BigInteger("1"); while(n.compareTo(ONE) &gt; 0)&#123; result = result.multiply(n); n = n.subtract(ONE); &#125; System.out.println(result); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125;&#125;//Testimport java.util.*;public class Application&#123; public static void main(String[] args) &#123; Handler uint,ulong,ubint; uint = new UseInt(); ulong = new UseLong(); ubint = new UseBigInteger(); uint.setNextHandler(ulong); ulong.setNextHandler(ubint); uint.computerMultiply("5"); uint.computerMultiply("19"); uint.computerMultiply("30"); uint.computerMultiply("100"); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Builder Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FBuilderPattern%2F</url>
    <content type="text"><![CDATA[Builder Pattern（建造者模式）Separate the construction of a complex object form its representation so that the same construction process can create different representations.（将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。） 产品（Product）：具体生成器要构造的复杂对象 抽象生成器（Builder）：一个接口，有为创建一个产品对象的各个组件定义的若干方法，还有返回产品对象的方法 具体生成器（ConcreteBuilder）：Builder的实现类 指挥者（Director）：一个类，拥有Builder接口声明的变量，负责向用户提供具体生成器 应用场景：将一个复杂对象的构建与表示分离，使得同样的构建可以创建不同的表示 javac -encoding UTF-8 Application.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Productpublic class Product&#123; //产品假设是一台电脑 public String "主机"； public String "显示器"; public String "键盘";&#125;//Builderpublic interface Builder&#123; public abstract String buildZJ(); public abstract String buildXSQ(); public abstract String buildJP(); public abstract void creat();&#125;//ConcreteBuilderpublic class BuilderOne implements Builder &#123; public String buildZJ()&#123; return "YYY牌主机"; &#125; public String buildXSQ()&#123; return "YYY牌显示器"; &#125; public String buildJP()&#123; return "YYY牌键盘"; &#125; public void creat()&#123; System.out.println(buildZJ()); System.out.println(buildJP()); System.out.println(buildXSQ()); &#125; &#125;public class BuilderTwo implements Builder &#123; public String buildZJ()&#123; return "XXX牌主机"; &#125; public String buildXSQ()&#123; return "XXX牌显示器"; &#125; public String buildJP()&#123; return "XXX牌键盘"; &#125; public void creat()&#123; System.out.println(buildZJ()); System.out.println(buildXSQ()); System.out.println(buildJP()); &#125;&#125;//Directorpublic class Director&#123; private Builder builder; Director(Builder builder)&#123; this.builder = builder; &#125; public void createComputer()&#123; builder.creat(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Builder b = new BuilderOne(); Director d = new Director(b); d.createComputer(); b = new BuilderTwo(); d = new Director(b); d.createComputer(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Abstract Factory Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FAbstractFactoryPattern%2F</url>
    <content type="text"><![CDATA[Abstract Factory Pattern（抽象工厂模式）Provide an interface for creating families of related or dependent objects without specifying their concrete classes.（为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。） 抽象产品（Product）：一个接口或者抽象类，定义、产品必须实现的方法 具体产品（ConcreteProduct）：抽象产品的子类或者实现类 抽象工厂（AbstractFactory）：一个接口或者抽象类，定义若干个抽象方法 具体工厂（ConcreteFactory）：抽象工厂的实现类或者子类，重写抽象方法，使其返回具体产品的实例 应用场景：提供一个创建一系列或相互依赖对象的接口，而无需知道他们具体的类，反射机制+抽象工厂（反射可以灵活地进行实例化） javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Productpublic abstract class Weapon&#123; protected String type; public abstract void loadBullet(Bullet bullet);&#125;public abstract class Bullet&#123; public abstract void load(String type);&#125;//ConcreteProductpublic class JiQiang extends Weapon&#123; JiQiang()&#123; type = "机枪"; &#125; public void loadBullet(Bullet bullet)&#123; bullet.load(type); &#125;&#125;public class ShouQiang extends Weapon&#123; ShouQiang()&#123; type = "手枪"; &#125; public void loadBullet(Bullet bullet)&#123; bullet.load(type); &#125;&#125;public class JiQiangBullet extends Bullet&#123; public void load(String type)&#123; System.out.println(type+"---装载机枪型子弹"); &#125;&#125;public class ShouQiangBullet extends Bullet&#123; public void load(String type)&#123; System.out.println(type+"---装载手枪型子弹"); &#125;&#125;//Creatorpublic abstract class Factory&#123; public abstract Weapon createWeapon(); public abstract Bullet createBullet();&#125;//ConcreteCreatorpublic class ShouQiangFactory extends Factory &#123; public Weapon createWeapon()&#123; return new ShouQiang(); &#125; public Bullet createBullet()&#123; return new ShouQiangBullet(); &#125;&#125;public class JiQiangFactory extends Factory&#123; public Weapon createWeapon()&#123; return new JiQiang(); &#125; public Bullet createBullet()&#123; return new JiQiangBullet(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Factory factory = new ShouQiangFactory(); Weapon gun = factory.createWeapon(); Bullet bullet = factory.createBullet(); gun.loadBullet(bullet); factory = new JiQiangFactory(); gun = factory.createWeapon(); bullet = factory.createBullet(); gun.loadBullet(bullet); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adapter Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FAdapterPattern%2F</url>
    <content type="text"><![CDATA[Adapter Pattern（适配器模式） Convert the inface of a class into another interface clients expect.Adapter lets classes work together that couldn’t otherwise because of incompatible interface.（将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。）“系统的数据和行为都正确，单接口不符时，我们应该考虑使用适配器，目的是是控制范围之外的一个原有对象与某个接口匹配。适配器模式主要用于希望复用一些现存的类，但是接口又与复用环境不一致的情况。”（《大话设计模式》） 目标（Target）：一个接口，客户想要使用的接口 被适配器（Adaptee）：一个已经存在的接口或者抽象类 适配器(Adapter)：一个实现了目标接口并且含有被适配器引用的类 应用场景：目标和被适配器完全解耦，通过适配器来建立联系（单接口适配器） javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233//Targetpublic interface ZhiLiuDian&#123; public String privideZhiLiuDian();&#125;//Adapteepublic interface JiaoLiuDian&#123; public String privideJiaoLiuDian();&#125;public class JiaoLiuDianHost implements JiaoLiuDian&#123; public String privideJiaoLiuDian()&#123; return "交流电"; &#125;&#125;//Adapterpublic class Adapter implements ZhiLiuDian&#123; JiaoLiuDian jiao; Adapter(JiaoLiuDian jiao)&#123; this.jiao = jiao; &#125; public String privideZhiLiuDian()&#123; String s = jiao.privideJiaoLiuDian(); return "转换"+s+"成直流电"; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; JiaoLiuDian jiao = new JiaoLiuDianHost(); System.out.println(jiao.privideJiaoLiuDian()); ZhiLiuDian zhi = new Adapter(jiao); System.out.println(zhi.privideZhiLiuDian()); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bridge Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FBridgePattern%2F</url>
    <content type="text"><![CDATA[Bridge Pattern（桥梁模式）Decouple an abstraction from its implementation so that the two can vary independently.（将抽象和实现解耦，使得两者可以独立的变化。） 抽象（Abstraction）：一个抽象类，含有实现者声明的变量， 实现者（Implementor）：一个接口，定义基本操作 细化抽象（RefinedAbstraction）：抽象的子类 具体实现者（ConcreteImplementor）：实现者的实现类 应用场景：分离实现和抽象，将抽象中方法的重要实现部分交给另外一个抽象类的子类或者接口的类 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Abstractionpublic abstract class BookEdit&#123; BookWriter [] author; String [] seriesBookName; public abstract void planBook(String [] s,String [] a); public abstract void releaseBook();&#125;//Implementorpublic interface BookWriter&#123; public void startWriterBook(String bookName); public String getName();&#125;//RefinedAbstractionpublic class TUBookEdit extends BookEdit&#123; public void planBook(String [] s,String [] a)&#123; seriesBookName = s; author = new BookAuthor[seriesBookName.length]; for (int i = 0;i &lt; seriesBookName.length ;i++ ) &#123; author[i] = new BookAuthor(a[i]); author[i].startWriterBook(seriesBookName[i]); &#125; &#125; public void releaseBook()&#123; System.out.println("图书有关信息"); for (int i = 0;i &lt; seriesBookName.length ;i++ ) &#123; System.out.print("书名："+seriesBookName[i]+"-------"); System.out.println("作者："+author[i].getName()); &#125; &#125;&#125;//ConcreteImplementorpublic class BookAuthor implements BookWriter&#123; String name; BookAuthor(String s)&#123; name = s; &#125; public void startWriterBook(String s)&#123; System.out.println(name+"编著了"+s); &#125; public String getName()&#123; return name; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; TUBookEdit zhang = new TUBookEdit(); String seriesBookName [] = &#123;"C程序设计","Java程序设计","XML程序设计"&#125;; String authorName [] = &#123;"张三","李四","王五"&#125;; zhang.planBook(seriesBookName,authorName); zhang.releaseBook(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Factory Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FFactoryPattern%2F</url>
    <content type="text"><![CDATA[Factory Pattern（工厂模式） Define an interface for creating an object,but let subclass decide which class to instantiate.Factory Method lets a class defer instantiation to subclass.（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到其子类。） 抽象产品（Product）：一个接口或者抽象类，定义、产品必须实现的方法 具体产品（ConcreteProduct）：抽象产品的子类或者实现类 构造者（Creator）：一个接口或者抽象类，定义一个叫做工厂方法的抽象方法，该方法返回具体产品类的实例 具体构造者（ConcreteCreator）：构造者实现类或者子类 应用场景：使一个类的实例化延迟到其子类，或者是想得到某一类的子类的实例，但是却无法直接使用new（不允许与该子类形成耦合），或者不清楚该类有哪些子类可用 javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Productpublic abstract class PenCore&#123; String color; public abstract void writeword(String s);&#125;//ConcreteProductpublic class RedPen extends PenCore&#123; RedPen()&#123; color = "红色"; &#125; public void writeword(String s)&#123; System.out.println("写出"+color+"的字："+s); &#125;&#125;public class BluePen extends PenCore&#123; BluePen()&#123; color = "蓝色"; &#125; public void writeword(String s)&#123; System.out.println("写出"+color+"的字："+s); &#125;&#125;public class BallPen&#123; PenCore core; public void usePenCore(PenCore core)&#123; this.core = core; &#125; public void write(String s)&#123; core.writeword(s); &#125;&#125;//AbstractFactorypublic abstract class Creator&#123; public abstract PenCore getPenCore();&#125;//ConcreteFactorypublic class RedCreator extends Creator&#123; public PenCore getPenCore()&#123; return new RedPen(); &#125;&#125;public class BlueCreator extends Creator&#123; public PenCore getPenCore()&#123; return new BluePen(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; PenCore core; //笔芯 Creator c = new RedCreator(); //笔芯构造者 BallPen b = new BallPen(); //圆珠笔 core = c.getPenCore(); b.usePenCore(core); b.write("哈"); c = new BlueCreator(); core = c.getPenCore(); b.usePenCore(core); b.write("ha"); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java架构学习心得(一)]]></title>
    <url>%2F2017%2F07%2F15%2FJava%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[序言 软件开发从最初的pc单机的人机交互模式到后来局域网的出现开启了软件开发的c/s模式（客户端/服务器模式），在到现在的b/s模式（浏览器/服务器），其实都面临的着相同的问题——代码的冗余，相似代码的大量重复导致整体代码量的庞大，所以为了减少代码的冗余，避免上述情况的产生，框架应用而生！而框架的原理其实主要就只有两部分，流程的抽象和数据类型的抽象，下面我们一一道来！（此文章适合于学过jsp及j2EE的童鞋） 正文首先我们来说流程控制，b/s模式均由浏览器向服务器发出请求，然后服务器响应相关请求并回传结果给浏览器，这是个一成不变的通用过程，所以我要做的就是抽象这个过程，类似于Struts2，把请求和响应的控制流程抽象到框架中去，让框架去拦截掉你的所有请求，然后经过处理后在传递给服务器，服务器的相响应结果同样被框架截获，然后处理后再扔给浏览器去显示，以上是大概流程，下面我们用程序代码详细道来！1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;FlowControl&gt; &lt;Action name="login"&gt; &lt;OperatePoint name="login_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;OperatePoint name="login_check"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;OperatePoint name="login_init"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;Action name="register"&gt; &lt;OperatePoint name="register_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;Action name="xxx"&gt; &lt;OperatePoint name="xxx_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;/FlowControl&gt; 上面的xml配置文件类似于Struts2的struts.xml，用于表明整个项目中所有的请求与对应请求的响应，Action为我自己定义的用于处理相关的请求动作类，OperatePoint为动作类中不同的方法，用于减少过多动作类，将一组相关的动作处理放入到同一个类中，用不同的方法去处理，减少代码的冗余。123456789101112131415161718192021222324252627282930313233343536&lt;filter&gt; &lt;filter-name&gt;FrameFilter&lt;/filter-name&gt; &lt;filter-class&gt;edu.frame.web.core.FrameFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;ExcludedPages&lt;/param-name&gt; &lt;param-value&gt;/authImage,/register&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DataBaseName&lt;/param-name&gt; &lt;param-value&gt;MySql&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DBConfigFile&lt;/param-name&gt; &lt;param-value&gt;DBConfig.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;FlowControlConfigFile&lt;/param-name&gt; &lt;param-value&gt;flowcontrol.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;AppBasePath&lt;/param-name&gt; &lt;param-value&gt;edu.demo.web.flowcontrol&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ConfigPath&lt;/param-name&gt; &lt;param-value&gt;config&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;JspPath&lt;/param-name&gt; &lt;param-value&gt;jsp&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FrameFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 上述代码段来自web.xml，我们用一个名叫FrameFilter的filter来拦截浏览器发送的所有的请求然后判定请求的类别，如果是jsp页面，我们不做处理直接扔给服务器，如果是action类请求，我们获取路径分解出类名和方法名，利用Java反射机制实例化相应的的动作类执行相应的方法，然后返回结果字符串result，在根据结果result找到流程控制配置文件中对应的jsp页面扔给服务器。init-param部分为初始化参数，包括ExcludedPages（请求过滤页面），DataBaseName（选用数据库名称，我们将数据库的统一操作也封装在框架内，应用层通过配置文件来进行数据库的选择和连接），DBConfigFile（数据库配置文件）FlowControlConfigFile（流程控制文件），AppBasePath（action动作类目录），ConfigPath（配置文件地址），JspPath（页面地址）。因此FrameFilter.java为本框架中最核心的部分，下面我们来看一下此文件的具体内容123456789101112131415161718public class FrameFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)&#123;&#125; //前处理，字符的乱码，数据库和流程控制配置文件的解析与实例化封装 public void perpare(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //初始化过滤器，加载web.xml文件中参数 public void init(FilterConfig config) throws ServletException &#123;&#125; //获取物理路径 private String getRealPath(FilterConfig config, String name)&#123;&#125; //请求匹配，判定是action还是jsp页面 public String actionMapping(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //action执行前的准备，action动作类名及方法的提取分离 public void prepareExecute(HttpServletRequest request, HttpServletResponse response,String functionName)&#123;&#125; //根据传来的动作类名和方法名去相应的action中执行相应的方法，返回result public String executeAction(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //根据action类返回的result跳转到相应的jsp页面 public void dispatcher(HttpServletRequest request, HttpServletResponse response,String result)&#123;&#125;&#125; 上述即为流程控制的核心部分，涉及到的细节有xml配置文件的解析（需引入dom4j或者其他的xml解析jar包，例如数据库配置文件和流程控制文件的解析均需要用到），还有就是java的反射机制，已知类名和方法名的字符串实现类的实例化，及方法的执行。]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Struts</tag>
        <tag>JavaWeb</tag>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝MyBatis]]></title>
    <url>%2F2017%2F07%2F08%2F%E6%B5%85%E5%B0%9DMyBatis%2F</url>
    <content type="text"><![CDATA[引言什么是JDBC？ JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 有了JDBC，向各种关系数据发送SQL语句就是一件很容易的事。换言之，有了JDBC API，就不必为访问Sybase数据库专门写一个程序，为访问Oracle数据库又专门写一个程序，或为访问Informix数据库又编写另一个程序等等，程序员只需用JDBC API写一个程序就够了，它可向相应数据库发送SQL调用。同时，将Java语言和JDBC结合起来使程序员不必为不同的平台编写不同的应用程序，只须写一遍程序就可以让它在任何平台上运行，这也是Java语言“编写一次，处处运行”的优势。 JDBC的用途简单地说，JDBC 可做三件事：与数据库建立连接、发送 操作数据库的语句并处理结果。下列代码段给出了以上三步的基本示例：123456789Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");Connection con = DriverManager.getConnection("jdbc:odbc:wombat","login","password");Statement stmt = con.createStatement();ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");while (rs.next()) &#123; int x = rs.getInt("a"); String s = rs.getString("b"); float f = rs.getFloat("c");&#125; 正文MyBatis基本构成 SqlSessionFactoryBuilder：根据配置文件生成SqlSessionFactory 1234567891011public static SqlSessionFactory initSqlSessionFactory() &#123; try &#123; InputStream intputStream = Resources.getResourceAsStream("mybatis_config.xml"); &#125; catch (IOException e) &#123;&#125; synchronized(CLASS_LOCK)&#123; if(sqlSessionFactory == null)&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(intputStream); &#125; &#125; return sqlSessionFactory;&#125; SqlSessionFactory：依靠工厂生成SqlSession会话 123456public static SqlSession openSqlSession()&#123; if(sqlSessionFactory == null)&#123; initSqlSessionFactory(); &#125; return sqlSessionFactory.openSession();&#125; SqlSession(类似于jdbc的Connection对象)：1)发送sql执行并返回结果，2)获取Mapper的接口 12345678910SqlSession session = sqlSessionFactory.openSession();//1)发送sql执行并返回结果，不建议使用try &#123; Role role = session.selectOne("org.mybatis.example.RoleMapper.getRole", 101); &#125; finally &#123; session.close(); &#125;//2)获取Mapper的接口，建议使用try &#123; RoleMapper mapper = session.getMapper(RoleMapper.class); Role role = mapper.getRole(101); &#125; finally &#123; session.close(); &#125; SQL Mapper：由java接口和xml文件或注解构成，需要给出对应的sql和映射规则，发送sql执行并返回结果。 XML配置文件方式实现Mapper 第一步给出java接口 123public interface RoleMapper &#123; public Role getRole(Long id);&#125; 第二步给出XML配置文件 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybtis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.mybatis.demo.mapper.RoleMapper"&gt; &lt;select id="getRole" parameterType="long" resultType="role"&gt; select id,role_name as roleName,role_name from t_role where id=#&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 第三步给出javaBean类 123456789101112131415161718192021222324252627282930public class Role &#123; private Long id; private String roleName; private String note; public Role() &#123;&#125; public Role(Long id, String roleName, String note) &#123; super(); this.id = id; this.roleName = roleName; this.note = note; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125;&#125; 最后获取Mapper执行方法 123RoleMapper mapper = session.getMapper(RoleMapper.class); Role role = mapper.getRole(101); System.out.println(role.getRoleName()); java注解方式实现Mapper（不建议使用）1234public interface BlogMapper &#123; @Select("SELECT * FROM blog WHERE id = #&#123;id&#125;") Blog selectBlog(int id); &#125; MyBatis的配置上面我们用到了一个名为mybatis_config.xml的配置文件，下面我们来看一下文件具体内容123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias = "role" type = "com.mybatis.demo.po.Role"/&gt; &lt;/typeAliases&gt; &lt;typeHandlers&gt; &lt;typeHandler handler="org.mybatis.demo.myTypeHandler.MyStringTypeHandler"/&gt; &lt;/typeHandlers&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/mybatis/demo/mapper/roleMapper.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 首先我们来看数据源dataSource，引入数据源的方式有几种，我们分别介绍一下 第一种就是文件中的形式直接显示在property子元素中 1234&lt;property name="driver" value=""/&gt; &lt;property name="url" value=""/&gt; &lt;property name="username" value=""/&gt; &lt;property name="password" value=""/&gt; 第二种是使用properties配置文件 12345//jdbc.properties文件内容driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=root password=root 12//直接引入配置文件即可&lt;properties resource="jdbc.properties"/&gt; 如果properties配置文件中数据库用户名和密码是密文的形式，系统提供了解密方法DECODE(str)1234567891011121314151617181920212223public static SqlSessionFactory initSqlSessionFactory() &#123; InputStream cfgStream = null; Reader cfgReader = null; InputStream proStream = null; Reader proReader = null; Properties properties = null; try &#123; cfgStream = Resources.getResourceAsStream("mybatis_config.xml"); cfgReader = new InputStreamReader(cfgStream); proStream = Resources.getResourceAsStream("jdbc.properties"); proReader = new InputStreamReader(proStream); properties = new Properties(); properties.load(proReader); properties.setProperty("username", DECODE(properties.getProperty("username"))); properties.setProperty("password", DECODE(properties.getProperty("password"))); &#125; catch (IOException e) &#123;&#125; synchronized(CLASS_LOCK)&#123; if(sqlSessionFactory == null)&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(cfgReader,properties); &#125; &#125; return sqlSessionFactory;&#125; 接下来我们看看typeAliases（别名） 逐个定义别名 123456&lt;typeAliases&gt; &lt;!-- 使用role来代替全路径com.mybatis.demo.po.Role --&gt; &lt;typeAlias alias = "role" type = "com.mybatis.demo.po.Role"/&gt; &lt;typeAlias alias = "a" type = "com.mybatis.demo.po.A"/&gt; ...&lt;/typeAliases&gt; 自动扫描（当定义数量较大时） 123&lt;typeAliases&gt; &lt;package name="com.mybatis.demo.po"&gt;&lt;/typeAliases&gt; 12345//当采用自动扫描方式的时候，配合注解@Alias()使用//若不使用注解则自动扫描按照当前类的首字母自动小写后为别名进行装载import org.apache.ibatis.type.Alias;@Alias("role")public class Role &#123;&#125; typeHandler类型处理器 MyBatis会在预处理语句（PrepareStatement）中设置一个参数时，或者从结果集（ResultSet）中取出一个值时，都会使用注册了的typeHandler进行处理，即实现javaType和jdbcType之间的相互转化。MyBatis中为我们提供了多种基本的typeHandler，同时我们也可以自定义typeHandler！ 自定义typeHandler 首先编写我们自己的typeHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyStringTypeHandlerByInterface implements TypeHandler&lt;String&gt;&#123; private Logger log = Logger.getLogger(MyStringTypeHandler.class); @Override public String getResult(ResultSet rs, String columnName) throws SQLException &#123; // TODO Auto-generated method stub log.info("使用我的typehandler，resultSet列名获取字符串"); return rs.getString(columnName); &#125; @Override public String getResult(ResultSet rs, int columnIndex) throws SQLException &#123; // TODO Auto-generated method stub log.info("使用我的typehandler，resultSet下标获取字符串"); return rs.getString(columnIndex); &#125; @Override public String getResult(CallableStatement cs, int columnIndex) throws SQLException &#123; // TODO Auto-generated method stub log.info("使用我的typehandler，CallableStatement下标获取字符串"); return cs.getString(columnIndex); &#125; @Override public void setParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; // TODO Auto-generated method stub log.info("使用我的typehandler"); ps.setString(i, parameter); &#125;&#125;//GenericTypeHandler.java /*You can create a generic TypeHandler that is able to handle more than one class. For that purpose add a constructor that receives the class as a parameter and MyBatis will pass the actual class when constructing the TypeHandler.*/public class GenericTypeHandler&lt;E extends MyObject&gt; extends BaseTypeHandler&lt;E&gt; &#123; private Class&lt;E&gt; type; public GenericTypeHandler(Class&lt;E&gt; type) &#123; if (type == null) throw new IllegalArgumentException("Type argument cannot be null"); this.type = type; &#125; ...``` - 然后我们有三种方法来使用自定义的typeHandler - 第一种是先在配置文件mybatis_config.xml中声明，然后在映射文件中使用 ```xml //mybatis_config.xml文件 &lt;typeHandlers&gt; &lt;typeHandler handler="com.mybatis.demo.myTypeHandler.MyStringTypeHandler"/&gt; &lt;!-- 自动扫描 &lt;package name="com.mybatis.demo.myTypeHandler"/&gt; --&gt; &lt;/typeHandlers&gt; //roleMapper.xml文件 &lt;resultMap type="role" id="roleMap"&gt; &lt;id column="id" property="id" javaType="long" jdbcType="BIGINT"/&gt; &lt;result column="role_name" property="roleName" javaType="String" jdbcType="VARCHAR"/&gt; &lt;/resultMap&gt; 第二种是直接在映射文件中定义具体typeHandler 12345//roleMapper.xml文件&lt;resultMap type="role" id="roleMap"&gt; &lt;id column="id" property="id" javaType="long" jdbcType="BIGINT"/&gt; &lt;result column="note" property="note" typeHandler="com.mybatis.demo.myTypeHandler.MyStringTypeHandler"/&gt; &lt;/resultMap&gt; 第三种是直接在参数中制定typeHandler 12345//roleMapper.xml文件 &lt;select id="findRole" parameterType="String" resultMap="roleMap"&gt; select id,role_name,role_name from t_role where role_name like concat('%',#&#123;roleName javaType=String, jdbcType=VARCHAR, typeHandler=com.mybatis.demo.myTypeHandler.MyStringTypeHandler&#125;, '%') &lt;/select&gt; 枚举typeHandler 系统枚举类 12345678910111213141516171819202122232425262728293031323334353637//创建性别枚举类Sexpublic enum Sex &#123; MALE(1,"男") , FEMALE(2,"女"); private int id; private String name; private Sex(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //以下为自定义方法，供自定义typeHandler使用 public static Sex getSex(int id)&#123; if(id==1) return MALE; else if(id==2) return FEMALE; return null; &#125; public static Sex getSex(String name)&#123; if(name.equals("男")) return MALE; else if(name.equals("女")) return FEMALE; return null; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344mybatis_config.xml文件配置&lt;!-- 采用枚举字符串名称作为参数传递 --&gt;&lt;typeHandler handler="org.apache.ibatis.type.EnumTypeHandler" javaType="com.mybatis.demo.enums.Sex"/&gt; &lt;!-- 采用整数下标作为参数传递 --&gt;&lt;typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="com.mybatis.demo.enums.Sex"/&gt;roleMapper.xml文件配置&lt;result column="sex" property="sex" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/&gt;&lt;result column="sex" property="sex" typeHandler="org.apache.ibatis.type.EnumOrdinalTypeHandler"/&gt;``` - 自定义枚举类，类似于前面所述的自定义typeHandler```java//创建自定义性别枚举类public class SexEnumTypeHandler implements TypeHandler&lt;Sex&gt;&#123; @Override public Sex getResult(ResultSet rs, String name) throws SQLException &#123; // TODO Auto-generated method stub /*自定义Id作为参数传递 int id = rs.getInt(name); return Sex.getSex(id);*/ //自定义Name作为参数传递 return Sex.getSex(rs.getString(name)); &#125; @Override public Sex getResult(ResultSet rs, int index) throws SQLException &#123; // TODO Auto-generated method stub /*int id = rs.getInt(index); return Sex.getSex(id);*/ return Sex.getSex(rs.getString(index)); &#125; @Override public Sex getResult(CallableStatement cs, int index) throws SQLException &#123; // TODO Auto-generated method stub /*int id = cs.getInt(index); return Sex.getSex(id);*/ return Sex.getSex(cs.getString(index)); &#125; @Override public void setParameter(PreparedStatement ps, int index, Sex sex, JdbcType jdbcType) throws SQLException &#123; // TODO Auto-generated method stub /*ps.setInt(index,sex.getId());*/ ps.setString(index, sex.getName()); &#125;&#125; 123456789101112131415161718192021222324252627 mybatis_config.xml文件配置 &lt;typeHandler handler="com.mybatis.demo.myTypeHandler.SexEnumTypeHandler" javaType="com.mybatis.demo.enums.Sex"/&gt; roleMapper.xml文件配置 &lt;result column="sex" property="sex" typeHandler="com.mybatis.demo.myTypeHandler.SexEnumTypeHandler"/&gt; ``` #### SQL元素的运用```xml&lt;sql id="userColumns"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;&lt;select id="selectUsers" resultType="map"&gt; select &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t1"/&gt;&lt;/include&gt;, &lt;include refid="userColumns"&gt;&lt;property name="alias" value="t2"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2 &lt;/select&gt;&lt;sql id="sometable"&gt; $&#123;prefix&#125;Table &lt;/sql&gt;&lt;sql id="someinclude"&gt; from &lt;include refid="$&#123;include_target&#125;"/&gt; &lt;/sql&gt;&lt;select id="select" resultType="map"&gt; select field1, field2, field3 &lt;include refid="someinclude"&gt; &lt;property name="prefix" value="Some"/&gt; &lt;property name="include_target" value="sometable"/&gt; &lt;/include&gt; &lt;/select&gt; 级联 一对一关联 1234567891011121314151617181920&lt;!-- 方式一 --&gt;&lt;resultMap id="blogResult" type="Blog"&gt; &lt;association property="author" column="author_id" javaType="Author" select="selectAuthor"/&gt; &lt;/resultMap&gt;&lt;select id="selectBlog" resultMap="blogResult"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125; &lt;/select&gt;&lt;!-- 方式二 --&gt;&lt;resultMap id="blogResult" type="Blog"&gt; &lt;id property="id" column="blog_id" /&gt; &lt;result property="title" column="blog_title"/&gt; &lt;association property="author" resultMap="authorResult" /&gt; &lt;/resultMap&gt;&lt;resultMap id="authorResult" type="Author"&gt; &lt;id property="id" column="author_id"/&gt; &lt;result property="username" column="author_username"/&gt; &lt;result property="password" column="author_password"/&gt; &lt;result property="email" column="author_email"/&gt; &lt;result property="bio" column="author_bio"/&gt; &lt;/resultMap&gt; 一对多关联 12345678910111213141516171819&lt;!-- 方式一 --&gt;&lt;!-- javaType可有可无，MyBatis会自动识别返回数据类型 --&gt;&lt;resultMap id="blogResult" type="Blog"&gt; &lt;collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/&gt; &lt;/resultMap&gt;&lt;select id="selectBlog" resultMap="blogResult"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125; &lt;/select&gt;&lt;!-- 方式二 --&gt;&lt;resultMap id="blogResult" type="Blog"&gt; &lt;id property="id" column="blog_id" /&gt; &lt;result property="title" column="blog_title"/&gt; &lt;collection property="posts" ofType="Post" resultMap="blogPostResult" columnPrefix="post_"/&gt; &lt;/resultMap&gt;&lt;resultMap id="blogPostResult" type="Post"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="subject" column="subject"/&gt; &lt;result property="body" column="body"/&gt; &lt;/resultMap&gt; 鉴别器(eg：根据性别属性进行判定去关联不同的对象) 1234567891011121314&lt;discriminator javaType="int" column="sex"&gt; &lt;case value="1" resultType="maleStudentMap"&gt; &lt;result property="" column="" /&gt; &lt;/case&gt; &lt;case value="2" resultType="femaleStudentMap"&gt; &lt;result property="" column="" /&gt; &lt;/case&gt;&lt;/discriminator&gt;&lt;resultMap id="maleStudentMap" type="com.mybatis.demo.po.MaleStudentMap" extends="studentMap"&gt; &lt;result property="" column="" /&gt; &lt;/resultMap&gt;&lt;resultMap id="femaleStudentMap" type="com.mybatis.demo.po.FemaleStudentMap" extends="studentMap"&gt; &lt;result property="" column="" /&gt; &lt;/resultMap&gt; 延迟加载 全局变量lazyLoadingEnabled和aggressiveLazyLoading 开启lazyLoadingEnabled延迟加载，使得关联属性按需加载，而不是自动加载 当aggressiveLazyLoading为true时，MyBatis的内容按照层级加载，我们关闭它，从而实现按照我们调用需求加载 局部变量fetchType123&gt; &lt;association fetchType="lazy"/&gt; &gt; &lt;collection fetchType="lazy"/&gt; &gt; 动态SQL if 123456&lt;select id="findActiveBlogWithTitleLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE 1 = 1 &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;/select&gt; choose (when, otherwise) 1234567891011121314&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE 1 = 1 &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; trim (where, set) 1234567891011121314151617181920212223242526272829303132333435&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;!-- prefix表示前缀为WHERE，prefixOverrides表示要去掉的元素 --&gt;&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt;&lt;!-- set实现动态更新，按需更新 --&gt;&lt;update id="updateAuthorIfNecessary"&gt; update Author &lt;set&gt; &lt;if test="username != null and username！=''"&gt; username=#&#123;username&#125;, &lt;/if&gt; &lt;if test="password != null"&gt; password=#&#123;password&#125;, &lt;/if&gt; &lt;if test="email != null"&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test="bio != null"&gt; bio=#&#123;bio&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; foreach 1234567&lt;select id="selectPostIn" resultType="domain.blog.Post"&gt; SELECT * FROM POST P WHERE ID in &lt;!-- item当前元素,index当前元素下标--&gt; &lt;foreach item="item" index="index" collection="list" open="(" separator=","close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; bind 12345&lt;!-- 不使用concat('%',#&#123;parameter&#125;, '%')实现模糊查询 --&gt;&lt;select id="selectBlogsLike" resultType="Blog"&gt; &lt;bind name="pattern" value="'%' + _parameter.getTitle() + '%'" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125; &lt;/select&gt; GitHub实例——MyBatis_Example]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Database</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重温JavaEE_SSH框架]]></title>
    <url>%2F2017%2F07%2F08%2F%E9%87%8D%E6%B8%A9JavaEE-SSH%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[知识只有当需要书写下来或者讲解出来的时候才显得如此匮乏——菜鸟飞 struts2 hibernate spring ssh整合及项目实例 Struts2 Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。——百度百科 在我看来，struts本质就类似于一个filter，所以在使用前需要在项目lib目录中导入相应的jar包并在项目的web.xml文件中配置如下内容12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置完成后，所有的页面请求便会被截获到struts.xml的配置文件中，如下图所示，Struts2框架中核心组件就是Action、拦截器等，Struts2框架使用包来管理Action和拦截器等。每个包就是多个Action、多个拦截器、多个拦截器引用的集合。在struts.xml文件中package元素用于定义包配置，每个package元素定义了一个包配置。它的常用属性有： name：必填属性，用来指定包的名字。 extends：可选属性，用来指定该包继承其他包。继承其它包，可以继承其它包中的Action定义、拦截器定义等。 namespace：可选属性，用来指定该包的命名空间。(考虑到同一个Web应用中需要同名的Action，Struts2以命名空间的方式来管理Action，同一个命名空间不能有同名的Action。Struts2通过为包指定namespace属性来为包下面的所有Action指定共同的命名空间。) 其中action标签中的name属性表示与你所截获的请求名称进行匹配(也就是说将来你项目的所有页面请求在这里都会有所记录，可以清晰地体现你项目的页面跳转逻辑，同时也极大的方便了以后的更改操作)struts.xml12345678&lt;struts&gt; &lt;package name="default" extends="struts-default"&gt; &lt;action name="index" class="com.action.IndexAction"&gt; &lt;result name="success"&gt;index.jsp&lt;/result&gt; &lt;result name="error"&gt;error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 对应的action标签中的class属性表示该请求所对应的Action处理类，因为Struts2中的Action采用了低侵入式的设计，所以Struts2不要求Action类继承任何的Struts2的基类或实现Struts2接口。但是，我们为了方便实现Action，大多数情况下都会继承com.opensymphony.xwork2.ActionSupport类，并重写此类里的public String execute() throws Exception方法(Action处理类默认执行方法)。（因为此类中实现了很多的实用接口，提供了很多默认方法，这些默认方法包括获取国际化信息的方法、数据校验的方法、默认的处理用户请求的方法等，这样可以大大的简化Action的开发。)，Action处理类的所有方法最后都会返回一个字符串，如SUCCESS给struts.xml，而action标签内的result标签中的name属性负责匹配传回的字符串，从而跳转至不同的页面123456789101112public class IndexAction extends ActionSupport&#123; public String execute()throws Exception&#123; try &#123; &#125; return SUCCESS; &#125; catch (Exception e) &#123; e.printStackTrace(); return ERROR; &#125; &#125; public String ownMethod()throws Exception&#123;&#125;&#125; 当然你也可以去书写并执行自己的方法，这时你只需要在处理类中加入自己的ownMethod()方法，并在struts.xml文件中的对应的action标签中做如下修改即可1&lt;action name="index" class="com.action.IndexAction!ownMethod"&gt; 以下内容为struts.xml配置详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;struts&gt; &lt;!-- include节点是struts2中组件化的方式 可以将每个功能模块独立到一个xml配置文件中 然后用include节点引用 --&gt; &lt;include file="struts-default.xml"&gt;&lt;/include&gt; &lt;!-- 所有匹配*.action的请求都由struts2处理 --&gt; &lt;constant name="struts.action.extension" value="action" /&gt; &lt;!-- 是否启用开发模式 --&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!-- struts配置文件改动后，是否重新加载 --&gt; &lt;constant name="struts.configuration.xml.reload" value="true" /&gt; &lt;!-- 设置浏览器是否缓存静态内容 --&gt; &lt;constant name="struts.serve.static.browserCache" value="false" /&gt; &lt;!-- 请求参数的编码方式 --&gt; &lt;constant name="struts.i18n.encoding" value="utf-8" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件，有助于开发 --&gt; &lt;constant name="struts.i18n.reload" value="true" /&gt; &lt;!-- 文件上传最大值 --&gt; &lt;constant name="struts.multipart.maxSize" value="104857600" /&gt; &lt;!-- 让struts2支持动态方法调用 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; &lt;!-- Action名称中是否还是用斜线 --&gt; &lt;constant name="struts.enable.SlashesInActionNames" value="false" /&gt; &lt;!-- 允许标签中使用表达式语法 --&gt; &lt;constant name="struts.tag.altSyntax" value="true" /&gt; &lt;!-- 对于WebLogic,Orion,OC4J此属性应该设置成true --&gt; &lt;constant name="struts.dispatcher.parametersWorkaround" value="false" /&gt; &lt;package name="basePackage" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!-- 定义拦截器 name:拦截器名称 class:拦截器类路径 --&gt; &lt;interceptor name="timer" class="com.kay.timer"&gt;&lt;/interceptor&gt; &lt;interceptor name="logger" class="com.kay.logger"&gt;&lt;/interceptor&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name="mystack"&gt; &lt;interceptor-ref name="timer"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="logger"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 定义默认的拦截器 每个Action都会自动引用 如果Action中引用了其它的拦截器 默认的拦截器将无效 --&gt; &lt;default-interceptor-ref name="mystack"&gt;&lt;/default-interceptor-ref&gt; &lt;!-- 全局results配置 --&gt; &lt;global-results&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="" class=""&gt; &lt;!-- 引用拦截器 name:拦截器名称或拦截器栈名称 --&gt; &lt;interceptor-ref name="timer"&gt;&lt;/interceptor-ref&gt; &lt;!-- 节点配置 name : result名称 和Action中返回的值相同 type : result类型 不写则选用superpackage的type struts-default.xml中的默认为dispatcher --&gt; &lt;result name="success" type="dispatcher"&gt;/talk.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 允许一个Action内包含多个请求处理方法：动态方法调用是指：表单元素的action不直接等于某个Action的名字，而是以感叹号后加方法名来指定对应的动作名：要使用动态方法调用，必须设置Struts2允许动态方法调用，通过设置struts.enable.DynamicMethodInvocation常量来完成，该常量属性的默认值是true。1234567&lt;struts&gt; &lt;!-- //禁用动态方法调用，默认为true启用，false禁用 constant:name="struts.enable.DynamicMethodInvocation" --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt;&lt;/struts&gt; 默认Action： 在浏览器输入一个不存在的Action，页面将呈现404错误，为了网站更友好，我们可以设置一个默认的Action。1234&lt;default-action-ref name="defaultAction"&gt;&lt;/default-action-ref&gt; &lt;action name="defaultAction"&gt; &lt;result&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; 处理结果类型： Struts2提供了对不同种类返回结果的支持，常见的有JSP，FreeMarker，Velocity等。 Struts2支持的不同类型的返回结果为：(加粗为常用) 名字 说明 chain 用来处理Action链 dispatcher 用来转向页面，通常处理JSP，这是默认的结果类型 freeMarker 处理FreeMarker模板 httpHeader 用来控制特殊的Http行为 redirect 重定向到一个URL redirect-action 重定向到一个Action stream 向浏览器发送InputSream对象，通常用来处理文件下载 velocity 处理Velocity模板 xslt 处理XML/XLST模板 plaintext 显示原始文件内容，例如文件源代码 tiles 结合Tile使用strutsUI页面标签库的引用需在jsp页面加入以下内容（详细介绍链接）1&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt; Hibernate Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。——百度百科 Hibernate的API一共有6个，分别为:Session、SessionFactory、Transaction、Query、Criteria和Configuration。通过这些接口，可以对持久化对象进行存取、事务控制。 SessionSession接口负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的SQL语句)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSession对象称为用户session。 SessionFactorySessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。 TransactionTransaction 接口是一个可选的API，可以选择不使用这个接口，取而代之的是Hibernate 的设计者自己写的底层事务处理代码。 Transaction 接口是对实际事务实现的一个抽象，这些实现包括JDBC的事务、JTA 中的UserTransaction、甚至可以是CORBA 事务。之所以这样设计是能让开发者能够使用一个统一事务的操作界面，使得自己的项目可以在不同的环境和容器之间方便地移植。 QueryQuery接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。Query经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。 CriteriaCriteria接口与Query接口非常类似，允许创建并执行面向对象的标准化查询。值得注意的是Criteria接口也是轻量级的，它不能在Session之外使用。 ConfigurationConfiguration 类的作用是对Hibernate 进行配置，以及对它进行启动。在Hibernate 的启动过程中，Configuration 类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象。虽然Configuration 类在整个Hibernate 项目中只扮演着一个很小的角色，但它是启动hibernate 时所遇到的第一个对象。 Hibernate.xml配置 Hibernate.show_sql：是否在运行时候sql语句输出到控制台，编码阶段便于测试的。（默认设置为true） Hibernate.format_sql：输出在控制台sql语句是否进行排版，便于阅读。（默认设置为true） Hbm2ddl.auto：可帮助由Java代码生成数据库脚本，进而生成具体表结构。如：create/update/create-drop/validate。 hbm2ddl.auto: 生成表结构的策略配置update(最常用的取值): 如果当前数据库中不存在表结构,那么自动创建表结构.如果存在表结构,并且表结构与实体一致,那么不做修改如果存在表结构,并且表结构与实体不一致,那么会修改表结构.会保留原有列.create(很少):无论是否存在表结构.每次启动Hibernate都会重新创建表结构.(数据会丢失)create-drop(极少): 无论是否存在表结构.每次启动Hibernate都会重新创建表结构.每次Hibernate运行结束时,删除表结构.validate(很少):不会自动创建表结构.也不会自动维护表结构.Hibernate只校验表结构. 如果表结构不一致将会抛出异常.12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC"-//Hibernate/Hibernate Configuration DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- property 元素用于配置Hibernate中的属性键:值 --&gt; &lt;!-- hibernate.connection.driver_class : 连接数据库的驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- hibernate.connection.username : 连接数据库的用户名 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!-- hibernate.connection.password : 连接数据库的密码 --&gt; &lt;property name="hibernate.connection.password"&gt;123&lt;/property&gt; &lt;!-- hibernate.connection.url : 连接数据库的地址,路径 --&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hibernatedemｏ&lt;/property&gt; &lt;!-- show_sql: 操作数据库时,会 向控制台打印sql语句 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- format_sql: 打印sql语句前,会将sql语句先格式化 --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 数据库方言配置org.hibernate.dialect.MySQLDialect (选择最短的)--&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- hibernate.connection.autocommit: 事务自动提交 --&gt; &lt;property name="hibernate.connection.autocommit"&gt;true&lt;/property&gt; &lt;!-- 将Session与线程绑定=&gt; 只有配置了该配置,才能使用getCurrentSession --&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 引入ORM 映射文件 填写src之后的路径--&gt; &lt;mapping resource="com/itheima/a_hello/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; XXXX.hbm.xml(ecplise可自动生成)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;!-- &lt;hibernate-mapping&gt;一般不去配置，采用默认即可。 default-cascade="none"：默认的级联风格，表与表联动。 default-lazy="true"：默认延迟加载 --&gt; &lt;hibernate-mapping&gt; &lt;!-- &lt;class&gt;：使用class元素定义一个持久化类。 name="cn.javass.user.vo.UserModel"：持久化类的java全限定名； table="tbl_user"：对应数据库表名； mutable="true"：默认为true，设置为false时则不可以被应用程序更新或删除； dynamic-insert="false"：默认为false，动态修改那些有改变过的字段，而不用修改所有字段； dynamic-update="false"：默认为false，动态插入非空值字段； select-before-update="false"：默认为false，在修改之前先做一次查询，与用户的值进行对比，有变化都会真正更新； optimistic-lock="version"：默认为version(检查version/timestamp字段)，取值：all(检查全部字段)、dirty(只检查修改过的字段)、 none(不使用乐观锁定)，此参数主要用来处理并发，每条值都有固定且唯一的版本，版本为最新时才能执行操作； --&gt; &lt;class name="cn.javass.user.vo.UserModel" table="tbl_user" dynamic-insert="true" dynamic-update="true" optimistic-lock="version"&gt; &lt;!-- &lt;id&gt;：定义了该属性到数据库表主键字段的映射。 name="userId"：标识属性的名字； column="userId"：表主键字段的名字，如果不填写与name一样； --&gt; &lt;id name="userId"&gt; &lt;!-- &lt;generator&gt;：指定主键由什么生成，推荐使用uuid（随机生成唯一通用的表示符，实体类的ID必须是String）， native（让数据库自动选择用什么生成（根据底层数据库的能力选择identity，sequence或hilo中的一种））， assigned（指用户手工填入，默认）。 --&gt; &lt;generator class="uuid"/&gt; &lt;/id&gt; &lt;!-- &lt;version/&gt;：使用版本控制来处理并发，要开启optimistic-lock="version"和dynamic-update="true"。 name="version"：持久化类的属性名，column="version"：指定持有版本号的字段名； --&gt; &lt;version name="version" column="version"/&gt; &lt;!-- &lt;property&gt;：为类定义一个持久化的javaBean风格的属性。 name="name"：标识属性的名字，以小写字母开头； column="name"：表主键字段的名字，如果不填写与name一样； update="true"/insert="true"：默认为true，表示可以被更新或插入； --&gt; &lt;property name="name" column="name" /&gt; &lt;property name="sex" column="sex"/&gt; &lt;property name="age" column="age"/&gt; &lt;!-- 组件映射：把多个属性打包在一起当一个属性使用，用来把类的粒度变小。 &lt;component name="属性，这里指对象"&gt; &lt;property name="name1"&gt;&lt;/property&gt; &lt;property name="name2"&gt;&lt;/property&gt; &lt;/component&gt; --&gt; &lt;!-- &lt;join&gt;:一个对象映射多个表，该元素必须放在所有&lt;property&gt;之后。 &lt;join table="tbl_test：子表名"&gt; &lt;key column="uuid：子表主键"&gt;&lt;/key&gt; &lt;property name="name1：对象属性" column="name：子表字段"&gt;&lt;/property&gt; &lt;/join&gt; --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 实例 post.hbm.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.form.Post" table="post"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="id"/&gt; &lt;generator class="identity"/&gt; &lt;/id&gt; &lt;many-to-one name="admin" class="com.form.Admin" fetch="select" lazy="false"&gt; &lt;column name="aid"/&gt; &lt;/many-to-one&gt; &lt;many-to-one name="user" class="com.form.User" fetch="select" lazy="false"&gt; &lt;column name="uid"/&gt; &lt;/many-to-one&gt; &lt;many-to-one name="board" class="com.form.Board" fetch="select" lazy="false"&gt; &lt;column name="bid"/&gt; &lt;/many-to-one&gt; &lt;property name="name" type="string"&gt; &lt;column name="name"/&gt; &lt;/property&gt; &lt;property name="content" type="string"&gt; &lt;column name="content"/&gt; &lt;/property&gt; &lt;property name="publishTime" type="timestamp"&gt; &lt;column name="publishTime"/&gt; &lt;/property&gt; &lt;property name="count" type="java.lang.Integer"&gt; &lt;column name="count"/&gt; &lt;/property&gt; &lt;property name="photoPath" type="string"&gt; &lt;column name="photoPath"/&gt; &lt;/property&gt; &lt;set name="replies" inverse="true" cascade="all-delete-orphan" lazy="false" order-by="publishTime desc"&gt; &lt;key&gt; &lt;column name="pid" not-null="true"/&gt; &lt;/key&gt; &lt;one-to-many class="com.form.Reply"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;``` ### 说说为什么使用lazy```xml&lt;set name="replies" inverse="true" cascade="all-delete-orphan" lazy="true"&gt; 当使用Hibernate中的one-to-many、many-to one、many-to-many关系映射的时候，一个对象中会包含一个或多个Set来关联其他的对象。例如：user-groups，当程序取user 对象时，如果一个用户有多个自定义组，那么程序将把组的信息也读取出来，在log中可以看到两个sql的输出。但是在页面的显示上，也许并不需要显示这个用户相关组的信息，这样系统的消耗就白白浪费了，于是hibernate提供了lazy（延迟加载）的方法来避免这一情况的发生，我们只需要在 user.hbm.xml中设置lazy=true，就能实现延迟加载。 Spring 是一个非常强大的反转控制(IOC)框架，以帮助分离项目组件之间的依赖关系 控制反转——Spring通过一种称作控制反转（IoC）的技术促进了低耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。 web.xml配置123456789101112131415161718192021&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;filter&gt;&lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.orm.hibernate4.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;init-param&gt; &lt;param-name&gt;org.springframework.orm.hibernate4.LocalSessionFactoryBean&lt;/param-name&gt; &lt;param-value&gt;sessionFactory&lt;/param-value&gt;&lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 说说为什么使用OpenSessionInView1&lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt; 当hibernate+spring配合使用的时候，如果设置了lazy=true,那么在读取数据的时候，当读取了父数据后，hibernate会自动关闭session，这样，当要使用子数据的时候，系统会抛出lazyinit的错误，这时就需要使用spring提供的 OpenSessionInViewFilter,OpenSessionInViewFilter主要是保持Session状态知道request将全部页面发送到客户端，这样就可以解决延迟加载带来的问题 applicationContext.xml配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"? &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" &lt;!-- 自动扫描与装配bean，扫描web包，将带有注解的类纳入spring容器管理 --&gt; &lt;!-- &lt;context:component-scan base-package="cn.itcast.oa"&gt;作用 Spring容器初始化时，会扫描cn.itcast.oa目录下标有@Component；@Service；@Controller；@Repository 注解的类纳入Spring容器管理 在类上，使用以下注解，实现bean的声明： @Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service 用于标注业务层组件 @Controller 用于标注控制层组件（如springMvc的controller，struts中的action） @Repository用于标注数据访问组件，即DAO组件 在类的成员变量上，使用以下注解，实现属性的自动装配 @Autowired ：按类的类型进行装配 @Resource： 1.如果同时指定了name和type，那么从Spring上下文中找到唯一匹配的bean进行装配 2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 3.如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 4.如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； --&gt; &lt;context:component-scan base-package="cn.itcast.oa"&gt;&lt;/context:component-scan&gt; &lt;!-- 加载外部的properties配置文件（引入jdbc的配置文件） -- &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置数据库连接池（c3p0）这个可以在hibernate.cfg.xml中配置 -- &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 基本信息 ：jdbc的url、驱动名、数据库名字、密码-- &lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;!-- 其他配置 -- &lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 -- &lt;property name="initialPoolSize" value="3"&gt;&lt;/property&gt; &lt;!--连接池中保留的最小连接数。Default: 3 -- &lt;property name="minPoolSize" value="3"&gt;&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 -- &lt;property name="maxPoolSize" value="5"&gt;&lt;/property&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 -- &lt;property name="acquireIncrement" value="3"&gt;&lt;/property&gt;&lt;!-- 控制数据源内加载的PreparedStatements数量。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 -- &lt;property name="maxStatements" value="8"&gt;&lt;/property&gt;&lt;!-- maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 -- &lt;property name="maxStatementsPerConnection" value="5"&gt;&lt;/property&gt; &lt;!--最大空闲时间,1800秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 -- &lt;property name="maxIdleTime" value="1800"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory （把数据源注入给session工厂）、配置映射文件将Spring与hibernate初步整合起来 -- &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean" &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置声明式的事务管理（采用基于注解的方式） session工厂注入到事务管理器transactionManager使Spring与Hinbernate整合实现业务逻辑 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager" &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;/beans&gt; 常见问题 自动装配与扫描有问题，context的命名空间的问题1&lt;context:component-scan base-package="cn.itcast.oa"&gt;&lt;/context:component-scan&gt; &lt;beans xmlns=”http://www.springframework.org/schema/beans“ xmlns:context=”http://www.springframework.org/schema/context“ ssh整合及项目实例项目实例链接:https://github.com/LFstefan/JavaEE]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Struts</tag>
        <tag>JavaWeb</tag>
        <tag>Architecture</tag>
        <tag>Hibernate</tag>
        <tag>Spring</tag>
        <tag>Frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2017%2F07%2F01%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树红黑树，一种自平衡二叉查找树，又称之为”对称二叉B树”，虽然复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在logn时间内做查找，插入和删除。 红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。 红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。 性质红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 下面是一个具体的红黑树的图例： 这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。 在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用”nil叶子”或”空（null）叶子”，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。 因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再匹配红黑树的性质。恢复红黑树的性质需要少量的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为logn次。 插入 我们首先以二叉查找树的方法增加节点并标记它为红色。（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换和树旋转来调整。）下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意： 性质1和性质3总是保持着。 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。 在下面的的代码中，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。 通过下列函数，可以找到一个节点的叔父和祖父节点：123456789public node grandparent(node n)&#123; return n.parent.parent;&#125;public node uncle(node n)&#123; if(n.parent == grandparent(n).left) return grandparent (n).right; else return grandparent (n).left;&#125; 情形1:新节点N位于树的根上，没有父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5匹配。123456public void insert_case1(node n)&#123; if(n.parent == NULL) n.color = BLACK; else insert_case2 (n);&#125; 情形2:新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。123456public void insert_case2(node n)&#123; if(n.parent.color == BLACK) return; /* 树仍旧有效*/ else insert_case3 (n);&#125; 注意：在下列情形下我们假定新节点的父节点为红色，所以它有祖父节点；因为如果父节点是根节点，那父节点就应当是黑色。所以新节点总有一个叔父节点，尽管在情形4和5下它可能是叶子节点。 情形3:如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。（把G当成是新加入的节点进行各种情形的检查）12345678910public void insert_case3(node n)&#123; if(uncle(n) != NULL &amp;&amp; uncle (n).color == RED) &#123; n.parent.color = BLACK; uncle (n).color = BLACK; grandparent (n).color = RED; insert_case1(grandparent(n)); &#125; else insert_case4 (n);&#125; 注意：在余下的情形下，我们假定父节点P是其父亲G的左子节点。如果它是右子节点，情形4和情形5中的左和右应当对调。 情形4:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色;接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。12345678910public void insert_case4(node n)&#123; if(n == n.parent.right &amp;&amp; n.parent == grandparent(n).left) &#123; rotate_left(n-&gt;parent); n = n-&gt;left; &#125; else if(n == n.parent.left &amp;&amp; n.parent == grandparent(n).right) &#123; rotate_right(n.parent); n = n.right; &#125; insert_case5 (n);&#125; 情形5：父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。12345678910public void insert_case5(node n)&#123; n.parent.color = BLACK; grandparent (n).color = RED; if(n == n.parent.left &amp;&amp; n.parent == grandparent(n).left) &#123; rotate_right(grandparent(n)); &#125; else &#123; /* Here, n == n.parent.right &amp;&amp; n.parent == grandparent (n).right */ rotate_left(grandparent(n)); &#125;&#125; 注意插入实际上是原地算法，因为上述所有调用都使用了尾部递归。 删除 如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题（为了表述方便，这里所指的儿子，为非叶子节点的儿子）。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。 在本文余下的部分中，我们只需要讨论删除只有一个儿子的节点（如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子）。如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。 需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。我们将使用下述函数找到兄弟节点： 123456public node sibling(node n)&#123; if(n == n-&gt;parent-&gt;left) return n-&gt;parent-&gt;right; else return n-&gt;parent-&gt;left;&#125; 我们可以使用下列代码进行上述的概要步骤，这里的函数replace_node替换child到n在树中的位置。出于方便，在本章节中的代码将假定空叶子被用不是NULL的实际节点对象来表示（在插入章节中的代码可以同任何一种表示一起工作）。 123456789101112public void delete_one_child(struct node *n)&#123; //Precondition: n has at most one non-null child. struct node *child = is_leaf(n-&gt;right)? n-&gt;left : n-&gt;right; replace_node(n, child); if(n-&gt;color == BLACK)&#123; if(child-&gt;color == RED) child-&gt;color = BLACK; else delete_case1 (child); &#125; free (n);&#125; 如果N和它初始的父亲是黑色，则删除它的父亲导致通过N的路径都比不通过它的路径少了一个黑色节点。因为这违反了性质5，树需要被重新平衡。有几种情形需要考虑： 情形1: N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。1234public void delete_case1(struct node *n)&#123; if(n-&gt;parent != NULL) delete_case2 (n);&#125; 注意：在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。 情形2： S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。 注意：N是删除了黑色节点后替换上来的子节点，所以这个过程中由P-&gt;X-&gt;N变成了P-&gt;N，实际上是少了一个黑色节点，也可以理解为Parent(Black)和Silbing(Red)那么他们的孩子黑色节点的数目肯定不等，让他们做新兄弟肯定是不平衡的，还需后面继续处理。 123456789101112public void delete_case2(struct node *n)&#123; struct node *s = sibling (n); if(s-&gt;color == RED)&#123; n-&gt;parent-&gt;color = RED; s-&gt;color = BLACK; if(n == n-&gt;parent-&gt;left) rotate_left(n-&gt;parent); else rotate_right(n-&gt;parent); &#125; delete_case3 (n);&#125; 情形3： N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。123456789public void delete_case3(struct node *n)&#123; struct node *s = sibling (n); if((n-&gt;parent-&gt;color == BLACK)&amp;&amp;(s-&gt;color == BLACK)&amp;&amp;(s-&gt;left-&gt;color == BLACK)&amp;&amp;(s-&gt;right-&gt;color == BLACK)) &#123; s-&gt;color = RED; delete_case1(n-&gt;parent); &#125; else delete_case4 (n);&#125; 情形4： S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。123456789public void delete_case4(struct node *n)&#123; struct node *s = sibling (n); if（(n-&gt;parent-&gt;color == RED)&amp;&amp;(s-&gt;color == BLACK)&amp;&amp;(s-&gt;left-&gt;color == BLACK)&amp;&amp;(s-&gt;right-&gt;color == BLACK)) &#123; s-&gt;color = RED; n-&gt;parent-&gt;color = BLACK; &#125; else delete_case5 (n);&#125; 情形5： S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。123456789101112131415public void delete_case5(struct node *n)&#123; struct node *s = sibling (n); if（s-&gt;color == BLACK)&#123; if((n == n-&gt;parent-&gt;left)&amp;&amp;(s-&gt;right-&gt;color == BLACK)&amp;&amp;(s-&gt;left-&gt;color == RED)) &#123; // this last test is trivial too due to cases 2-4. s-&gt;color = RED; s-&gt;left-&gt;color = BLACK; rotate_right (s); &#125; else if((n == n-&gt;parent-&gt;right)&amp;&amp;(s-&gt;left-&gt;color == BLACK)&amp;&amp;(s-&gt;right-&gt;color == RED)) &#123;// this last test is trivial too due to cases 2-4. s-&gt;color = RED; s-&gt;right-&gt;color = BLACK; rotate_left (s); &#125; &#125; delete_case6 (n);&#125; 情形6： S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。此时，如果一个路径不通过N，则有两种可能性： 它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。 它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。 在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。 123456789101112public void delete_case6(node n)&#123; node s = sibling (n); s.color = n.parent.color; n.parent.color = BLACK; if(n == n.parent.left)&#123; s.right.color = BLACK; rotate_left(n.parent); &#125; else &#123; s.left.color = BLACK; rotate_right(n.parent); &#125;&#125; 同样的，函数调用都使用了尾部递归，所以算法是原地算法。此外，在旋转之后不再做递归调用，所以进行了恒定数目（最多3次）的旋转。]]></content>
      <categories>
        <category>Data_Structure</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Data_Structure</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-3树]]></title>
    <url>%2F2017%2F06%2F24%2F2-3%E6%A0%91%2F</url>
    <content type="text"><![CDATA[2-3查找树 2–3树是一种树型数据结构，内部节点（存在子节点的节点）要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。2–3树是平衡树，意味着右边，左边，中间的子树的元素数量都是相同或接近的。 如果一个内部节点拥有一个数据元素、两个子节点，则此节点为2节点。 如果一个内部节点拥有两个数据元素、三个子节点，则此节点为3节点。 当且仅当以下叙述中有一条成立时，T为2–3树： T为空。即T不包含任何节点。 T为拥有数据元素a的2节点。若T的左孩子为L、右孩子为R，则L和R是等高的非空2–3树； a大于L中的所有数据元素；同时a小于等于R中的所有数据元素。 T为拥有数据元素a和b的3节点，其中a &lt; b。若T的左孩子为L、中孩子为M、右孩子为R，则L、M、和R是等高的非空2–3树； a大于L中的所有数据元素，并且小于等于M中的所有数据元素；同时b大于M中的所有数据元素，并且小于等于R中的所有数据元素。 上面介绍了什么是2-3树，接下来我们看看2-3树有什么用，或者说是为什们会出现这种结构，下面我们先来考虑一个问题： 我们知道二叉搜索树的查找和搜索在平均情况下时间复杂度都能达到O(logn)，而且能保证数据有序。二叉搜索树的中序遍历就是数据的顺序。但是这个效率只是在平均情况下。如果数据是逆序，或者顺序，那么这棵树就会发生一边倒的情况使复杂度直接达到O(n)，就如同快排中选择到糟糕的主元(最大或者最小)。 通过上面的问题我们可以看出2-3树用来弥补二叉查找树在极端条件下的不足，因为2-3树是平衡树，所以不管数据怎么样，查找删除操作时间复杂度都至少能达到O(logn)，比起二叉查找树来有过之而无不及！2-3查找树的性质： 如果中序遍历2-3查找树，就可以得到排好序的序列； 在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。 复杂度分析： 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为log2(N) 在最好的情况下，所有的节点都是3-node节点，查找效率为log3(N) 距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。 对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。 但是2-3树实现比较复杂，需要掌控的情况很多，剥离节点，传递节点等操作，都需要很复杂的代码，且也会耗费不少的时间。所以我们一般不怎么用原始的2-3树，而是用2-3树的变形红黑树.]]></content>
      <categories>
        <category>Data_Structure</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Data_Structure</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2017%2F06%2F17%2FB%E6%A0%91%E5%92%8CB%2B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。 维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。 B树定义： B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。 根节点至少有两个子节点 每个节点有M-1个key，并且以升序排列 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间 其它节点至少有M/2个子节点 可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入 B+树定义： B+树是对B树的一种变形树，它与B树的差异在于： 有k个子结点的结点必然有k个关键码；非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。 B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。 B+ 树的优点在于： 由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如： Windows：HPFS文件系统；Mac：HFS，HFS+文件系统；Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；数据库：ORACLE，MYSQL，SQLSERVER等中。 有关B/B+树在数据库索引中的应用，请看张洋的MySQL索引背后的数据结构及算法原理这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。 树表查找总结： 二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。 除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。]]></content>
      <categories>
        <category>Data_Structure</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Data_Structure</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环]]></title>
    <url>%2F2017%2F06%2F10%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[约瑟夫环问题问题描述 ：这个问题是以弗拉维奥·约瑟夫命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的n个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，他们围成一个圈，从第1个人开始报数，报到m的人自杀，下一个人重新开始报数，如此循环，直到所有人全都自杀为止。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。 我们首先模拟整个过程将自杀顺序打印粗来，n个人用1~N来标号表示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public int showJoseph(int total, int cycle) &#123; boolean[] arr = new boolean[total]; Arrays.fill(arr, true); int kill = 0; int index = 0; int result = 0; while (kill &lt; total) &#123; for (int i = 0; i &lt; cycle; i++) &#123; //过滤掉已经自杀的人 while (!arr[index]) &#123; index = (index + 1) % total; &#125; if (i == cycle - 1) &#123; System.out.print(index + 1); arr[index] = false; kill++; &#125; if(kill==total-1) result = (index+1); index = (index+1) % total; &#125; &#125; return result; &#125; //限定起点位置public int showJoseph(int total, int cycle, int start) &#123; boolean[] arr = new boolean[total]; Arrays.fill(arr, true); int kill = 0; int index = start - 1; int result = 0; while (kill &lt; total) &#123; for (int i = 0; i &lt; cycle; i++) &#123; while (!arr[index]) &#123; index = (index + 1) % total; &#125; if (i == cycle - 1) &#123; System.out.print(index + 1); arr[index] = false; kill++; &#125; if(kill==total-1) result = index+1; index = (index+1) % total; &#125; &#125; return result; &#125; //限定起点位置递归版public int showJoseph(int total, int cycle, int start) &#123; int result = (showJoseph(total, cycle) + (start-1) -1) % total + 1; return result; &#125; //限定起点+限定循环方向private static int showJoseph(int total, int cycle, int start, boolean forward) &#123; boolean[] arr = new boolean[total]; Arrays.fill(arr, true); int kill = 0; int index = start - 1; int result = 0; while (kill &lt; total) &#123; for (int i = 0; i &lt; cycle; i++) &#123; while (!arr[index]) &#123; if (forward) &#123; //正向走 index = (++index + total) % total; &#125; else &#123; //反向走 index = (--index + total) % total; &#125; &#125; if (i == cycle - 1) &#123; System.out.print(index + 1); arr[index] = false; kill++; &#125; if(kill==total-1) result = index+1; if (forward) &#123; index = (++index + total) % total; &#125; else &#123; index = (--index + total) % total; &#125; &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数和最小公倍数]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最大公约数和最小公倍数最大公约数123456789//欧几里德算法public long gcd(long m, long n) &#123; while(n!=0)&#123; long rem = m%n; m = n; n = rem; &#125; return m;&#125; 由于除法代价太大，所以接下来我们用减法来代替除法实现该算法，首先我们需要知道gcd(a,b)=gcd(b,a-b)，即数字A和数字B的最大公因数和数字B和数字(A-B)的最大公因数是相同的，所以我们可以得出以下的算法1234567public long gcd(long m, long n) &#123; if(m==n) return m; else&#123; return m-n&gt;0 ? gcd(n,m-n) : gcd(m,n-m); &#125;&#125; 然而存在一个问题就是减法会导致迭代次数较多，所以我们接下来想办法降低迭代次数，我们知道一个奇数和一个偶数的最大公约数其实等于这个奇数和这个(偶数/2)的最大公约数，所以程序进一步改进为：12345678910111213141516public long gcd(long m, long n) &#123; if(m==n) return m; //m,n均为奇数 else if(m&amp;1==1&amp;&amp;n&amp;1==1) return m-n&gt;0 ? gcd(n,m-n) : gcd(m,n-m); //m为偶数，n为奇数 else if(m&amp;1==0&amp;&amp;n&amp;1==1) return gcd(m&gt;&gt;1,n); //n为偶数，m为奇数 else if(m&amp;1==1&amp;&amp;n&amp;1==0) return gcd(m,n&gt;&gt;1); //m,n均为为偶数 else return 2*gcd(m&gt;&gt;1,n&gt;&gt;1);&#125; 最小公倍数123public long zxgbs(long m, long n) &#123; return m*n/gcd(m,n);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序 堆是具有下列性质的完全二叉树:每个节点的值都大于或等于其左右孩子节点的值,称为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值,称为小顶堆。 堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。 时间复杂度为 O(nlogn)！ 如何由一个无序序列键成一个堆？ 可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？ 怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。 123456789101112131415161718192021222324252627282930313233public void heapAdjust(int[] arr, int start, int end) &#123; int temp = arr[start]; for(int i=2*start+1; i&lt;=end; i*=2) &#123; //左右孩子的节点分别为2*i+1,2*i+2 //选择出左右孩子较小的下标 if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) &#123; i ++; &#125; if(temp &gt;= arr[i]) &#123; break; //已经为大顶堆，=保持稳定性。 &#125; arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 &#125; arr[start] = temp; //插入正确的位置&#125;public void heapSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; //建立大顶堆 for(int i=arr.length/2; i&gt;=0; i--) &#123; heapAdjust(arr, i, arr.length-1); &#125; for(int i=arr.length-1; i&gt;=0; i--) &#123; swap(arr, 0, i); heapAdjust(arr, 0, i-1); &#125;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql_DATE_FORMAT_分组查询]]></title>
    <url>%2F2017%2F05%2F27%2FMySql_DATE_FORMAT_%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[MySql_DATEFORMAT分组查询12345678&lt;!-- 按日查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%m-%d') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按月查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%m') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按年查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按周查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%u') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time DATE_FORMAT(date,format) :根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) …]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySql</tag>
        <tag>Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组打印]]></title>
    <url>%2F2017%2F05%2F27%2F%E6%95%B0%E7%BB%84%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[数组打印 一维数组12345int [] num = &#123;1,2,3,4,5&#125;;System.out.println(num.toString());//输出：[I@15db9742...System.out.println(Arrays.toString(num));//输出：[1, 2, 3, 4, 5] 二维数组123456789101112int [][] nums = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;,&#123;6,7&#125;&#125;;System.out.println(Arrays.toString(nums));//输出：[[I@6d06d69c, [I@7852e922, [I@4e25154f]...System.out.println(Arrays.deepToString(nums));//输出：[[1, 2], [3, 4, 5], [6, 7]]//补充int [][] a = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;int [][] b = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;System.out.println(Arrays.equals(a, b));//输出：FALSESystem.out.println(Arrays.deepEquals(a, b));//输出：TRUE 附上：工具类Arrays部分源码解读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class Arrays &#123; private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13; //排序底层采用快排实现 public static void sort(int[] a) &#123; DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0); &#125; //二分查找 public static int binarySearch(long[] a, long key) &#123; return binarySearch0(a, 0, a.length, key); &#125; //一维数组简单判定相等 public static boolean equals(long[] a, long[] a2) &#123; if (a==a2) return true; if (a==null || a2==null) return false; int length = a.length; if (a2.length != length) return false; for (int i=0; i&lt;length; i++) if (a[i] != a2[i]) return false; return true; &#125; //多维数组或复杂对象深度判定相等 public static boolean deepEquals(Object[] a1, Object[] a2) &#123; if (a1 == a2) return true; if (a1 == null || a2==null) return false; int length = a1.length; if (a2.length != length) return false; for (int i = 0; i &lt; length; i++) &#123; Object e1 = a1[i]; Object e2 = a2[i]; if (e1 == e2) continue; if (e1 == null) return false; // Figure out whether the two elements are equal boolean eq = deepEquals0(e1, e2); if (!eq) return false; &#125; return true; &#125; //数组填充，只能以同一个值填充数组 public static void fill(long[] a, long val) &#123; for (int i = 0, len = a.length; i &lt; len; i++) a[i] = val; &#125; //Arrays.asList()返回的是ArrayList类型，其底层构成仍然是数组 public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;implements RandomAccess, java.io.Serializable&#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; ... &#125; //一维数组打印 public static String toString(int[] a) &#123; if (a == null) return "null"; int iMax = a.length - 1; if (iMax == -1) return "[]"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123; b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(", "); &#125; &#125; //多维数组或对象数组打印 public static String deepToString(Object[] a) &#123; if (a == null) return "null"; int bufLen = 20 * a.length; if (a.length != 0 &amp;&amp; bufLen &lt;= 0) bufLen = Integer.MAX_VALUE; StringBuilder buf = new StringBuilder(bufLen); deepToString(a, buf, new HashSet&lt;Object[]&gt;()); return buf.toString(); &#125; private static void deepToString(Object[] a, StringBuilder buf,Set&lt;Object[]&gt; dejaVu) &#123; if (a == null) &#123; buf.append("null"); return; &#125; int iMax = a.length - 1; if (iMax == -1) &#123; buf.append("[]"); return; &#125; dejaVu.add(a); buf.append('['); for (int i = 0; ; i++) &#123; Object element = a[i]; if (element == null) &#123; buf.append("null"); &#125; else &#123; //获取子元素类型 Class&lt;?&gt; eClass = element.getClass(); //如果子元素类型是数组类型，进而判定是哪一种数组类型 if (eClass.isArray()) &#123; if (eClass == byte[].class) buf.append(toString((byte[]) element)); else if (eClass == short[].class) buf.append(toString((short[]) element)); else if (eClass == int[].class) buf.append(toString((int[]) element)); else if (eClass == long[].class) buf.append(toString((long[]) element)); else if (eClass == char[].class) buf.append(toString((char[]) element)); else if (eClass == float[].class) buf.append(toString((float[]) element)); else if (eClass == double[].class) buf.append(toString((double[]) element)); else if (eClass == boolean[].class) buf.append(toString((boolean[]) element)); else &#123; // element is an array of object references if (dejaVu.contains(element)) buf.append("[...]"); else deepToString((Object[])element, buf, dejaVu); &#125; &#125; else &#123; // element is non-null and not an array buf.append(element.toString()); &#125; &#125; if (i == iMax) break; buf.append(", "); &#125; buf.append(']'); dejaVu.remove(a); &#125;&#125;]]></content>
      <categories>
        <category>Arrays</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桶排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[桶排序桶排序 (Bucket sort)或所谓的箱排序的原理是将数组分到有限数量的桶子里（即基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中），然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。 桶排序是稳定的 桶排序是常见排序里最快的一种,比快排还要快…大多数情况下 桶排序非常快,但是同时也非常耗空间,基本上是最耗空间的一种排序算法 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序 将各个桶中的数据有序的合并起来 桶排序分析：桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。 对N个关键字进行桶排序的时间复杂度分为两个部分： (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。 (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点： (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。 (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：O(N)+O(M(N/M)log(N/M))=O(N+N(logN-logM))=O(N+NlogN-N*logM)，当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。123456789101112131415161718192021222324252627282930public static void bucketSort(int[] arr) &#123; if(arr == null &amp;&amp; arr.length == 0) return ; int bucketNums = 10; //这里默认为10，规定待排数[0,100) List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //桶的索引 for(int i=0; i&lt;10; i++) &#123; buckets.add(new LinkedList&lt;Integer&gt;()); //用链表比较合适 &#125; //划分桶 for(int i=0; i&lt;arr.length; i++) &#123; buckets.get(fun(arr[i])).add(arr[i]); &#125; //对每个桶进行排序 for(int i=0; i&lt;buckets.size(); i++) &#123; if(!buckets.get(i).isEmpty()) &#123; Collections.sort(buckets.get(i)); //对每个桶进行快排 &#125; &#125; //还原排好序的数组 int k = 0; for(List&lt;Integer&gt; bucket : buckets) &#123; for(int ele : bucket) &#123; arr[k++] = ele; &#125; &#125;&#125;//映射函数public int fun(int x) &#123; return x / 10;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序使用了递归分治的思想，其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。 1234567891011121314151617181920212223242526272829303132public static void mergeSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int mid = (left&gt;&gt;1) + (right&gt;&gt;1); mergeSort(arr, left, mid); //递归排序左边 mergeSort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并&#125;//合并两个有序数组public static void merge(int[] arr, int left, int mid, int right) &#123; //左数组[left, mid] 右数组[mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= right) &#123; if(arr[i] &lt;= arr[j]) temp[k++] = arr[i++]; else temp[k++] = arr[j++]; &#125; while(i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; while(j &lt;= right) &#123; temp[k++] = arr[j++]; &#125; for(int p=0; p&lt;temp.length; p++) &#123; arr[left + p] = temp[p]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序一个O(n)时间复杂度的排序算法，我们知道基于比较的排序的下限是O(nlogn)。而计数排序只需线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。如果被排序序列是无重的，即意味着无需统计个数，那么我们可以使用位数组来实现该算法！ 123456789101112131415161718192021222324public void countSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int max = max(arr);//获取被排序序列中的最大值来开辟新数组 int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i&lt;arr.length; i++) &#123; count[arr[i]] ++; &#125; int k = 0; for(int i=0; i&lt;=max; i++) &#123; for(int j=0; j&lt;count[i]; j++) &#123; arr[k++] = i; &#125; &#125;&#125;public int max(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; if(ele &gt; max) max = ele; &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode_最大数]]></title>
    <url>%2F2017%2F05%2F22%2FLintCode-%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述 给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。(注意事项：最后的结果可能很大，所以我们返回一个字符串来代替这个整数。)样例：给出 [1, 20, 23, 4, 8]，返回组合最大的整数应为8423201。 思路拿到题目的第一反应就是比较大小嘛，但是继续往下想发现比较条件有点繁琐，同位数的直接比较大小即可，不同位数就比较麻烦了，需要一位一位进行比较…，然后突然间就想到了全排列，其实数据量比较小的时候是可以的，但是数据量大的情况就不行了，于是我卡在了数据样例[0,0,0,0,0,0,…,0,0,0]上，而且全然做了无用功，所以思路又回到了比较排序上，但是没想到什么好的比较方案，最终还是上网找了找资料，发现一个新思路，去比较两个数字组合后的大小，然后选择结果较大的组合，比如1和20，我们直接去比较120和201的大小，很明显201&gt; 120，所以1应该在20后面。这样一来比较就变得灰常容易，整个算法也瞬间简单明了起来！题解1234567891011121314151617181920212223242526public String largestNumber(int[] num) &#123; String[] A = new String[num.length]; int check = 0; for (int i=0;i&lt;num.length;i++) &#123; A[i] = String.valueOf(num[i]); check = Math.max(check,num[i]); &#125; if (check == 0) &#123; return "0"; &#125; Arrays.sort(A,new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;); StringBuilder s = new StringBuilder(); for (int i=0;i&lt;num.length;i++) &#123; s.append(String.valueOf(A[i])); &#125; return s.toString(); &#125; 收获一：以前只知道Arrays.sort(a[])这一种最简单的用法，今天又收获了两种更高级的用法，其中一种在本题中已用到，总结起来Arrays.sort()排序函数有以下几种用法 Arrays.sort(a[]) 排序a数组，且规则是从小到大，a可以是int,long,double,char,flaat,Object… Arrays.sort(a[], int fromIndex, int toIndex) 排序a数组的部分，从下标fromIndex到toIndex(不包括toIndex) Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) 排序a数组，按照比较器中的规则 12345class MyComparator implements Comparator&lt;Integer&gt;&#123; public int compare(Integer s1, Integer s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125; 二：匿名内部类，think in java中研究了好久，只是一直没怎么使用过，如今又看到了，却也感觉熟悉而陌生，所以再拿出来简单说道说道，看代码1234567Arrays.sort(A,new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;); 完整类为123456789101112public class Main &#123; public static void main(String[] args) &#123; String[] a = &#123;9, 8, 7, 2, 3, 4, 1, 0, 6, 5&#125;; Comparator cmp = new MyComparator(); Arrays.sort(a, cmp); &#125; &#125; class MyComparator implements Comparator&lt;String&gt;&#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序在实际应用当中确实是表现最好的排序算法。但其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面，同时也把大数沉到下面。举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针从尾部找比基准数小的，左指针从头部找比基准数大的，然后交换之。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。时间复杂度为O(nlogn) 12345678910111213141516171819202122232425public int partition(int[] arr, int left, int right) &#123; int pivotKey = arr[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 &#125; arr[left] = pivotKey; //最后把pivot赋值到中间 return left;&#125;public void quickSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right);&#125;public void sort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O(n^3/2),要好于直接插入排序的O(n^2) 1234567891011121314151617181920212223public void shellInsert(int[] arr, int d) &#123; for(int i=d; i&lt;arr.length; i++) &#123; int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&gt;=0&amp;&amp;arr[j]&gt;temp) &#123; //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 j -= d; &#125; if (j != i - d) //存在比其小的数 arr[j+d] = temp; &#125;&#125;public void shellSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &gt;= 1) &#123; shellInsert(arr, d); d&gt;&gt;1; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void radixSort(int[] arr) &#123; if(arr == null &amp;&amp; arr.length == 0) return ; int maxBit = getMaxBit(arr); for(int i=1; i&lt;=maxBit; i++) &#123; List&lt;List&lt;Integer&gt;&gt; buf = distribute(arr, i); //分配 collecte(arr, buf); //收集 &#125;&#125;//待分配数组public List&lt;List&lt;Integer&gt;&gt; distribute(int[] arr, int iBit) &#123; List&lt;List&lt;Integer&gt;&gt; buf = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int j=0; j&lt;10; j++) &#123; buf.add(new LinkedList&lt;Integer&gt;()); &#125; for(int i=0; i&lt;arr.length; i++) &#123; buf.get(getNBit(arr[i], iBit)).add(arr[i]); &#125; return buf;&#125;//把分配的数据收集到arr中public void collecte(int[] arr, List&lt;List&lt;Integer&gt;&gt; buf) &#123; int k = 0; for(List&lt;Integer&gt; bucket : buf) &#123; for(int ele : bucket) &#123; arr[k++] = ele; &#125; &#125;&#125;//获取最大位数public int getMaxBit(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; int len = (ele+"").length(); if(len &gt; max) max = len; &#125; return max;&#125;//获取x的第n位，如果没有则为0public int getNBit(int x, int n) &#123; String sx = x + ""; if(sx.length() &lt; n) return 0; else return sx.charAt(sx.length()-n) - '0';&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2017%2F05%2F13%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 基本思想:两两比较相邻记录的关键字,如果反序则交换 冒泡排序时间复杂度最好的情况为O(n),最坏的情况是O(n^2) 设置标志位，明显如果有一趟没有发生交换（flag = false)，说明排序已经完成 记录一轮下来标记的最后位置，下次从头部遍历到这个位置就Ok 12345678910111213141516171819public void bubbleSort(int[] array)&#123; boolean flag = true; int n = array.length; while(flag)&#123; flag = false; for(int i = 0;i &lt; n-1;i++)&#123; if(array[i] &gt; array[i+1])&#123; //数据交换，将较大的数据换至数组后方 array[i] = array[i]^array[i+1]; array[i+1] = array[i]^array[i+1]; array[i] = array[i]^array[i+1]; //设置标记，当本次循环未发生交换动作时，排序完成 flag = true; &#125; &#125; //每次循环均有一位当前最大值换至正确的位置，故每下一次循环减少一次比较 n--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直接插入排序]]></title>
    <url>%2F2017%2F05%2F13%2F%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[直接插入排序 将一个记录插入到已经排好序的有序表中, 从而得到一个新的,记录数增1的有序表 时间复杂度也为O(n^2), 比冒泡法和选择排序的性能要更好一些 123456789101112131415public void insertSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; for(int i=1; i&lt;arr.length; i++) &#123; //假设第一个数位置时正确的；要往后移，必须要假设第一个。 int j = i; int target = arr[i]; //待插入的 //后移 while(j&gt;0&amp;&amp;target&lt;arr[j-1]) &#123; arr[j] = arr[j-1]; j --; &#125; //插入 arr[j] = target; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2017%2F05%2F13%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序 通过n-i次关键字之间的比较,从n-i+1 个记录中选择关键字最小的记录,并和第i(1&lt;=i&lt;=n)个记录交换之 尽管与冒泡排序同为O(n^2),但简单选择排序的性能要略优于冒泡排序 12345678910111213141516171819202122public static void selectSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int minIndex = 0; for(int i=0; i&lt;arr.length-1; i++) &#123; //只需要比较n-1次 minIndex = i; for(int j=i+1;j&lt;arr.length; j++) &#123; //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。 if(arr[j]&lt;arr[minIndex]) &#123; minIndex = j; &#125; &#125; if(minIndex != i) &#123; //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); &#125; &#125;&#125;public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵相关运算]]></title>
    <url>%2F2017%2F05%2F10%2F%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[矩阵相关运算矩阵加减法（等行等列） 12345678910111213141516171819202122232425262728public int[][] add(int[][] a,int[][] b)&#123; //获取二维数组的行数 int row = a.length; //获取二维数组的列数 int column = a[row-1].length; int[][] c = new int[row][column]; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;column;j++) &#123; c[i][j]=a[i][j]+b[i][j]; &#125; &#125; return c;&#125;public int[][] sub(int[][] a,int[][] b)&#123; int row = a.length; int column = a[row-1].length; int[][] c = new int[row][column]; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;column;j++) &#123; c[i][j]=a[i][j]-b[i][j]; &#125; &#125; return c;&#125; 矩阵相乘（A[m][n]*B[n][k]=C[m][k]）1234567891011121314151617181920public int[][] add(int[][] a,int[][] b)&#123; //获取二维数组a的行数作为c的行数 int row = a.length; //获取二维数组a的列数 int n = a[row-1].length; 获取二维数组b的列数作为c的列数 int column = b[n-1].length; int[][] c = new int[row][column]; Arrays.fill(c,0); for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;column;j++) &#123; for(int k=0;k&lt;n;k++)&#123; c[i][j]+=a[i][k]*b[k][j] &#125; &#125; &#125; return c;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理]]></title>
    <url>%2F2017%2F05%2F10%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[海量数据处理问题 topK问题 重复问题 排序问题 相关算法 topK问题（10亿词中查找出现频率最高的10个） 单机+单核+足够大内存 10亿词（每个词占8B）中查找出现频率最高的10个 首先考虑全部放入内存，需要至少10^9*8=8GB 然后排序，顺序遍历找出结果或者用HashMap统计频率在求出结果 单机+多核（意味着可以多线程）+足够大内存 在内存中用hash将数据分为n个partition，交给n个线程处理，最后有一个线程负责将结果合并 上述有一个瓶颈问题，即（数据倾斜）线程处理速度不一致，所以快的线程必须等慢的线程，速度取决最慢的线程 解决办法，将数据分成c*n个partition（c&gt;1）,依然是n个线程，快的线程处理完后主动取下一个partition进行处理，直到数据全部处理完成，最后合并结果 单机+单核+受限内存 Hash（x）%M将源文件数据切割成M个小文件，然后用（单机+单核+足够大内存）方法处理，最后合并 多机+受限内存 数据分发到各个机器，每台机器用（单机+单核+受限内存）方法进行处理重复问题（电话号码去重求个数，即不同的电话号码有多少个，假设电话号码为8位） 位图法 8位能表示的十进制数最大为99999999，假设每个数字对应位图中的一位，大概需要内存99MB/8=7.375MB排序问题（9亿个不重复的9位整数数排序） 9亿个不重复的9位整数数排序，32位机器中整数占4B，所有数据全放入内存需0.9G*4B=3.6GB 1.利用数据库索引排序 2.分治法，将数据分断放入内存，最后合并（但是每次换入换出浪费时间） 3.位数组，声明一个可包含9位整数的bit数组，需内存大概9亿/8=120MB左右即可，数组内0、1表示是否含有此数，遍历出结果相关算法 1.hash算法 构造函数 冲突处理 2.位图法bit-map 快查，判重，判存 3.bloomfilter（位图+哈希） 判断元素是否属于集合 不属于（绝对正确） 属于（可能错误） m位的位数组+k个不同的hash（判定属于—k个哈希映射后，k位均为1，则可能存在于集合中，有位不为1，则元素肯定不在集合中） K=ln2*（m/n）n个元素，错误率最小 延伸：CBF（counter），SBF 4.倒排索引 单词指向包含他的文档（此单词在那些文档中出现过），例如论文的关键字搜索 5.trie树 利用公共前缀来减少时空消耗 6.堆 前n大/小 中位数（双堆）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用查找算法]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常用查找算法顺序查找 无序或有序队列,按顺序比较每个元素，直到找到关键字为止。 时间复杂度：O(n) 123456789101112131415161718192021222324252627282930313233343536373839//用链表来实现，动态的插入和删除便于维护序列的有序性public class SequentialSearchST&lt;Key,Value&gt; &#123; private Node head; private int size=0; //插入时间复杂度为O(n) public void put(Key key,Value v)&#123; Node p=head; while(p!=null)&#123; if(p.key.equals(key))&#123; p.v=v; return; &#125; p=p.next; &#125; head=new Node(key,v,head); size++; &#125; //查找时间复杂度为O(n) public Value get(Key key)&#123; Node p=head; while (p!=null)&#123; if(p.key.equals(key))&#123; return p.v; &#125; p=p.next; &#125; return null; &#125; //删除时间复杂度为O(n) public void delete(Key key)&#123; Node p=head; while (p!=null)&#123; if(p.key.equals(key))&#123; p.v = p.next.v; p.next = p.next.next; &#125; &#125; &#125;&#125; 二分查找（折半查找） 条件：有序数组 原理： 查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束； 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中重复步骤1。 如果在某一步骤数组为空，则代表找不到。 时间复杂度：O(logn)1234567891011121314public int binarySearach(int[] array,int key)&#123; int low = 0; int high = array.length-1; while(low &lt;= high)&#123; int middle = (low + high) &gt;&gt; 1; if(key &lt; array[middle]) high = middle-1; else if(key &gt; array[middle]) low = middle+1; else return array[middle]; &#125; return -1;//没找到目标值返回-1&#125; 插值查找 插值查找，基于折半查找的优化变种。由于折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。所以插值查找克服了折半查找的傻瓜式，采用自适应查找点，从而让每次所选择的查找点更加接近被查找值，以加快查找速度。 二分查找中查找点计算如下：mid=(low+high)/2, 即mid=low+1/2*(high-low); 插值查找中查找点计算如下：mid=low+(key-a[low])/(a[high]-a[low])*(high-low) 123456789101112131415161718public int insertKeySearch(int [] a, int key)&#123; int low, high, mid; low = 0; high = a.length-1; while(low &lt;= high)&#123; /* 插值查找的计算公式 */ mid = low + (high - low)*(key - a[low])/(a[high] - a[low]); if (key &lt; a[mid])&#123; high = mid - 1; &#125; else if (key &gt; a[mid])&#123; low = mid + 1; &#125; else return mid; &#125; return 0;&#125; 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。斐波那契查找 在介绍斐波那契查找算法之前，先介绍一下很它紧密相连的一个概念——黄金分割。黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。 斐波那契查找也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为Fn，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况： key值与第mid=（low+high）/2相等，mid位置的元素即为所求； key值大于第mid=（low+high）/2，则令 low=mid+1； key值小于第mid=（low+high）/2，则令high=mid-1。斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1；开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1)，比较结果也分为三种： key值与第mid=low+F(k-1)-1相等，则mid位置的元素即为所求； key值大于第mid=low+F(k-1)-1，则low=mid+1，k-=2；说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))=Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。 key值小于第mid=low+F(k-1)-1，则high=mid-1，k-=1。说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归的应用斐波那契查找。 上代码我们来实际操作一番123456789101112131415161718192021222324252627public int FibonacciSearch(int [] a, int key)&#123; int [] F = &#123;0,1,1,2,3,5,8,13,21,34&#125;;//构造一个斐波那契数列 int low, high, mid, k; low = 1; high = a.length-1; k = 0; while (n &gt; F[k]-1) /* 计算n位于斐波那契数列的位置 */ k++; while (low &lt;= high) &#123; mid = low + F[k-1] -1; if (key &lt; a[mid])&#123; high = mid - 1; k -= 1; &#125; else if (key &gt; a[mid])&#123; low = mid + 1; k -= 2; &#125; else &#123; if (mid &lt;= n) return mid; else return n; &#125; &#125; return 0;&#125; 在最坏情况下，斐波那契查找的时间复杂度还是O(log2n)，且其期望复杂度也为O(log2n)，但是与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。二叉排序树查找特性： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。在二叉查找树b中查找x的过程为： 若b是空树，则搜索失败，否则： 若x等于b的根节点的数据域之值，则查找成功；否则： 若x小于b的根节点的数据域之值，则搜索左子树；否则： 查找右子树。时间复杂度：O(log_2(n)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//查找public TreeNode BSTSearach(TreeNode root, Value value) &#123; if(root==null) return null; if(root.value==value) return root; else return root.value&lt;value ? BSTSearach(roo.right,value) : BSTSearach(root.left,value);&#125;//插入节点public void insertNode(TreeNode root,TreeNode node) &#123; if (root == NULL) root = node; else if (root.val &gt; node.val) insertNode(root.left,node); else if(root.val &lt; node.val) insertNode(root.right,node); else return;&#125; //删除二叉查找树的节点public TreeNode removeNode(TreeNode root, int value) &#123; if (root == null)&#123; return null; &#125; if (root.val == value)&#123;//当前节点值等于value值 if (root.left == null &amp;&amp; root.right == null)&#123;//当前节点没有左右孩子节点 root = null; &#125; else if (root.left == null)&#123;//当前节点只有右孩子节点 root = root.right; &#125; else if (root.right == null)&#123;//当前节点只有左孩子节点 root = root.left; &#125; else &#123;//当前节点有左右孩子节点 TreeNode tmp = root; tmp = tmp.left; while(tmp.right != null)&#123; tmp = tmp.right; &#125; root.val = tmp.val; root.left = removeNode(root.left,root.val); &#125; &#125; else if (value &lt; root.val)&#123;//当前节点值大于value if (root.left == null)&#123; return root; &#125; root.left = removeNode(root.left, value); &#125; else &#123;//当前节点值小于value if (root.right == null)&#123; return root; &#125; root.right = removeNode(root.right,value); &#125; return root;&#125; 哈希表法（散列表） 先创建哈希表（散列表） 根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。 时间复杂度：几乎是O(1)，取决于产生冲突的多少。123456789101112131415161718192021222324public int searchHash(int[] hash, int hashLength, int key) &#123; // 哈希函数 int hashAddress = key % hashLength; // 指定hashAdrress对应值存在但不是关键值，则用开放寻址法解决 while (hash[hashAddress] != 0 &amp;&amp; hash[hashAddress] != key) &#123; hashAddress = (++hashAddress) % hashLength; &#125; // 查找到了开放单元，表示查找失败 if (hash[hashAddress] == 0) return -1; return hashAddress; &#125; //数据插入Hash表 public void insertHash(int[] hash, int hashLength, int data) &#123; // 哈希函数 int hashAddress = data % hashLength; // 如果key存在，则说明已经被别人占用，此时必须解决冲突 while (hash[hashAddress] != 0) &#123; // 用开放寻址法找到 hashAddress = (++hashAddress) % hashLength; &#125; // 将data存入字典中 hash[hashAddress] = data; &#125; 分块查找 将n个数据元素”按块有序”划分为m块（m ≤ n）。 每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 然后使用二分查找确定数据所处在哪一块后用顺序查找key。123456789101112131415161718public int blockSearch(int[] index, int[] st, int key, int m) &#123; // 在序列st数组中，用分块查找方法查找关键字为key的记录 // 1.在index[ ] 中折半查找，确定要查找的key属于哪个块中 int i = binarySearch(index, key); if (i &gt;= 0) &#123; int j = i &gt; 0 ? i * m : i; int len = (i + 1) * m; // 在确定的块中用顺序查找方法查找key for (int k = j; k &lt; len; k++) &#123; if (key == st[k]) &#123; System.out.println("查询成功"); return k; &#125; &#125; &#125; System.out.println("查找失败"); return -1; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2017%2F05%2F06%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找非递归版1234567891011121314public int binarySearch(int[] array,int key)&#123; int low = 0; int high = array.length-1; while(low &lt;= high)&#123; int middle = (low + high) &gt;&gt; 1; if(key &lt; array[middle]) high = middle-1; else if(key &gt; array[middle]) low = middle+1; else return array[middle]; &#125; return -1;//没找到目标值返回-1&#125; 递归版12345678910111213public int binarySearch(int[] array,int key,int low,int high)&#123; if(low &gt;= high) return -1; else&#123; int middle = (low + high) &gt;&gt; 1; if(key &lt; array[middle]) binarySearach(array,key,low,middle-1); else if(key &gt; array[middle]) binarySearach(array,key,middle-1,high); else return array[middle]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map的遍历]]></title>
    <url>%2F2017%2F05%2F06%2FMap%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Map的遍历 EntrySet遍历 KeySet/Values遍历 Iterator遍历 foreach遍历 使用EntrySet 1234Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); &#125; 使用keyset或者values 123456789Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //遍历map中的键 for (Integer key : map.keySet()) &#123; System.out.println("Key = " + key); &#125; //遍历map中的值 for (Integer value : map.values()) &#123; System.out.println("Value = " + value); &#125; 使用Iterator(在遍历时调用iterator.remove()可以来删除entries) 123456Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = entries.next(); System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); &#125; 使用foreach遍历 1234567891011121314Map&lt;String, Integer&gt; items = new HashMap&lt;&gt;();items.put("A", 10);items.put("B", 20);items.put("C", 30);items.put("D", 40);items.put("E", 50);items.put("F", 60);items.forEach((k,v)-&gt;System.out.println("Item : " + k + " Count : " + v));items.forEach((k,v)-&gt;&#123; System.out.println("Item : " + k + " Count : " + v); if("E".equals(k))&#123; System.out.println("Hello E"); &#125;&#125;);]]></content>
      <categories>
        <category>Iteration</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Iteration</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初心]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%88%9D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[引言 2017-04-29是我阳历的生日，同时也是我第一个博客的诞辰！初心是为了能有一个可以记录自己在代码中的成长过程的空间，同时也希望能够发挥自己的一些微不足道的能力去帮助一些人，在此过程中不断提高自己。——————一只奋进的小菜鸟 随笔 起因其实可以追溯到一篇微博，内容讲述了为什么程序员要写博客，作者文笔着实不错，让我看着动了心，回想起从前码代码的日子，经历过好多的坑，走过好多的弯路，一直想可以把自己心得或者当时的想法，做法记录下来，以后可以回头看看自己当初犯过那些错，走过那些弯路，警醒一下自己，同时也可以提醒同在路上的人不要重蹈我的覆辙，为他人尽自己的一丝绵薄之力。 本人小小一程序员菜鸟，无意间对编程产生了浓厚的兴趣，遂开始了码代码的日子，由于起步较晚，基础也薄弱，希望以后的日子有幸能看我文章的小伙伴不要吝啬你们的口水，为我提出宝贵的意见，更希望各位大牛心情愉悦之际能指点一二，同路的菜鸟我们相互交流，共同学习，一起奋进！]]></content>
      <categories>
        <category>初心</category>
      </categories>
      <tags>
        <tag>初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>