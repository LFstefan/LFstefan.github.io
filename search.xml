<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F08%2FLamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F08%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F08%2F%E4%BD%8D%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[初窥Set源码]]></title>
    <url>%2F2017%2F09%2F30%2F%E5%88%9D%E7%AA%A5Set%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[SetHashSet（HashMap的HashMap版本）LinkedHashSet（LinkedHashMap的LinkedHashMap版本）TreeSet（TreeMap的TreeMap版本）123456789101112131415public class HashSet&lt;E&gt;extends AbstractSet&lt;E&gt;implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); //构造方法，直接调用HashMap的构造方法生成entry&lt;E,Object&gt; //类似的所有其他构造方法均直接调用HashMap的构造方法生成 public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125;]]></content>
      <categories>
        <category>Source_Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Source_Code</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥Map源码]]></title>
    <url>%2F2017%2F09%2F30%2F%E5%88%9D%E7%AA%A5Map%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[MapHashMap数组+链表+红黑树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //默认容量 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认负载因子为0.75，使性能在空间和时间上达到了平衡，只有当表到达3/4满时才会进行再散列，增大负载因子可以降低所需空间，但会增加查找时间 static final float DEFAULT_LOAD_FACTOR = 0.75f; //当链表长度超过8时转换为红黑树 static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; //内部节点类，实现了map接口内的entry接口，所以hashmap中的每一个键值对都是一个Entry&lt;K,V&gt; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;&#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; ... &#125; static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; //构造方法，自定义容量和负载因子 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; //构造方法，自定义容量和默认负载因子 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; //构造方法，默认负容量和默认负载因子 public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;&#125; public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; //通过key值获取value值 final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; /*判断table数组是否为空，数组长度是否为零，判断所给hash值对应的数组下标中的元素是否为空。它通过 h &amp; (table.length -1) 来得到该对象的保存位，即table数组的下标，而HashMap底层数组的长度总是 2 的 n 次方，这是HashMap在速度上的优化（保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方）。当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。*/ if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null) &#123; //验证数组tab[(n - 1) &amp; hash]中存的第一个节点是否为所需节点，是则返回 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //验证数组table中所存的节点类型是否为红黑树，是则按照红黑树的方式继续查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); /*调用红黑树的查找方法find final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; */ //如果节点类型为链表，则按照链表的方式进行查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; public boolean containsKey(Object key) &#123;return getNode(hash(key), key) != null;&#125; public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //table数组为空或长度为零，重新调整数组大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //hash值对应的数组下标的位置为空，则直接构造节点插入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //如果hash值对应的数组下标的位置中的元素与插入元素相同 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //如果hash值对应的数组下标的位置中的元素类型为红黑树，则按照红黑树方式插入 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //如果hash值对应的数组下标的位置中的元素类型为链表，则按照链表方式插入 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表插入元素后要检验链表大小是否大于8，实则需将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; /*我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。*/ ++modCount; /*threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子，即扩容 */ if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; //直接将table数组大小至为0并将数组元素均至为空，然后交由GC回收 public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; //entrySet遍历 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125;&#125; LinkedHashMap(extends HashMap)继承自HashMap，但是比HashMap多了一组双向链表来维持插入顺序，或者是最近最少使用的次序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class LinkedHashMap&lt;K,V&gt;extends HashMap&lt;K,V&gt;implements Map&lt;K,V&gt;&#123; //节点移除后，双向链表删除该节点 void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; &#125; //节点插入后， void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125; &#125; //节点访问后，移动节点到链表最后 void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p =(LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125; public void clear() &#123; super.clear(); //双向链表首尾指针至空 head = tail = null; &#125; TreeMap基于红黑树，由Comparable或Comparator排序而成]]></content>
      <categories>
        <category>Source_Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
        <tag>Source_Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map的遍历]]></title>
    <url>%2F2017%2F09%2F30%2FMap%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>Iteration</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Iteration</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥List源码]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%88%9D%E7%AA%A5List%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ListArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; //Default initial capacity（初始容量为10） private static final int DEFAULT_CAPACITY = 10; //Shared empty array instance used for empty instances. private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //Shared empty array instance used for default sized empty instances. private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; // non-private to simplify nested class access private int size; //Constructs an empty list with the specified initial capacity. //带有容量参数的构造方法 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; //Constructs an empty list with an initial capacity of ten. //不含参的构造方法，默认初始化大小为10 public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; //Constructs a list containing the elements of the specifiedcollection //含参构造方法 public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; //Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, ifnecessary, to ensure that it can hold at least the number of elementsspecified by the minimum capacity argument. public void ensureCapacity(int minCapacity) &#123; &#125; private void ensureCapacityInternal(int minCapacity) &#123;&#125; private void ensureExplicitCapacity(int minCapacity) &#123; &#125; //The maximum size of array to allocate.数组分配最大值 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //Increases the capacity to ensure that it can hold at least thenumber of elements specified by the minimum capacity argument. private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; //最大容量 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; //数组大小 public int size() &#123;return size;&#125; //判空 public boolean isEmpty() &#123; return size == 0;&#125; //判包含 public boolean contains(Object o) &#123;return indexOf(o) &gt;= 0; &#125; //获取元素下标 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; //获取最后一次出现的下标 public int lastIndexOf(Object o) &#123; if (o == null) &#123; //倒序循环 for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; //转换成对象数组 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; //转换成具体类型数组 @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; //根据下标获取元素值 public E get(int index) &#123; //边界检查 rangeCheck(index); return elementData(index); &#125; //设置元素值（返回旧值） public E set(int index, E element) &#123; rangeCheck(index); //保留旧值 E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; //添加元素 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; //添加元素到指定位置 public void add(int index, E element) &#123; //检查范围 rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // //数组移动，index之后的元素整体后移一位 System.arraycopy(elementData, index, elementData, index + 1,size - index); elementData[index] = element; size++; &#125; //根据下标移除指定元素，并返回该元素的值 public E remove(int index) &#123; //检查范围 rangeCheck(index); modCount++; E oldValue = elementData(index); //计算需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0)&#123; //数组移动 System.arraycopy(elementData, index+1, elementData, index,numMoved); &#125; elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; //移除指定元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //服务于public boolean remove(Object o) 方法 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index,numMoved); elementData[--size] = null; // clear to let GC do its work &#125;//清空ArrayList，将数组元素全都至为空，数组大小设置为0，然后让GC来回收内存空间 public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; //将一个容器中的元素全部添加到list后 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; //将一个容器中的元素全部插入到list中 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index +numNew,numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; //删除置顶区间的元素 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex,numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); //数组前移后剩下的位置的值至为空，让GC回收该空间 for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; //数组上边界检查 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; //添加元素前的数组上下边界检查 private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; public boolean removeAll(Collection&lt;?&gt; c) &#123; //判空 Objects.requireNonNull(c); return batchRemove(c, false); &#125; /*判空requireNonNull()方法源码如下 public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj; &#125; */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; if (r != size) &#123; System.arraycopy(elementData, r,elementData, w,size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; //元素迭代遍历 public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); &#125; public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //内部类 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123;&#125; public E next() &#123;&#125; public void remove() &#123;&#125; public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; //内部类 private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123;&#125; public int nextIndex() &#123;&#125; public int previousIndex() &#123;&#125; public E previous() &#123;&#125; public void set(E e) &#123;&#125; public void add(E e) &#123;&#125; &#125; //返回子数组 public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; //边界检查 subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; //内部类返回子数组 private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123;&#125; public E get(int index) &#123;&#125; public int size() &#123;&#125; public void add(int index, E e) &#123;&#125; public E remove(int index) &#123;&#125; protected void removeRange(int fromIndex, int toIndex) &#123;&#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;&#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; //匿名内部类 return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123;&#125; public E next() &#123;&#125; public boolean hasPrevious() &#123;&#125; public E previous() &#123;&#125; public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;&#125; public int nextIndex() &#123;&#125; public int previousIndex() &#123;&#125; public void remove() &#123;&#125; public void set(E e) &#123;&#125; public void add(E e) &#123;&#125; final void checkForComodification() &#123;&#125; &#125;; &#125; &#125; //遍历 public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; LinkedList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412public class LinkedList&lt;E&gt;extends AbstractSequentialList&lt;E&gt;implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializabl&#123; transient int size = 0; transient Node&lt;E&gt; first;//链首 transient Node&lt;E&gt; last;//链尾 public LinkedList() &#123;&#125; public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //链首插入元素 private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; &#125; //链尾插入元素 void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; public void addFirst(E e) &#123;linkFirst(e);&#125; public void addLast(E e) &#123;linkLast(e);&#125; public boolean add(E e) &#123;linkLast(e);return true;&#125; //节点前插入 void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; //去链首 private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; //去链尾 private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; //移除链首元素 public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; //移除链尾元素 public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; //去节点 E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; //获取链首元素 public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125; //获取链尾元素 public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125; //判包含 public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; public int size() &#123;return size; &#125; //移除元素o public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;return addAll(size, c);&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;//转成数组循环添加&#125; public void clear() &#123;//循环至空，包括值，前指针，后指针 &#125; public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; public E set(int index, E element) &#123;&#125; public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125; public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size; &#125; private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; //收尾两个指针目的就是加快查找目标元素 Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; public int lastIndexOf(Object o) &#123;&#125; //队列操作，返回队首元素 public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; public E element() &#123; return getFirst(); &#125; //队列操作，去除队首元素 public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; public E remove() &#123; return removeFirst(); &#125; //队列操作，队尾入队列 public boolean offer(E e) &#123; return add(e); &#125; // 队列操作，队头入队列（双向链表） public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; public boolean offerLast(E e) &#123; addLast(e); return true; &#125; public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item; &#125; public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125; public void push(E e) &#123; addFirst(e); &#125; public E pop() &#123; return removeFirst(); &#125; public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index); &#125; //迭代遍历内部类 private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125; public boolean hasPrevious() &#123; return nextIndex &gt; 0; &#125; public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; public void remove() &#123; checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; &#125; public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; &#125; public void add(E e) &#123; checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; //节点内部类，双向链表 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; //反向迭代遍历内部类 private class DescendingIterator implements Iterator&lt;E&gt; &#123; private final ListItr itr = new ListItr(size()); public boolean hasNext() &#123; return itr.hasPrevious(); &#125; public E next() &#123; return itr.previous(); &#125; public void remove() &#123; itr.remove(); &#125; &#125; public Object[] toArray() &#123;&#125; public &lt;T&gt; T[] toArray(T[] a) &#123;&#125;&#125;]]></content>
      <categories>
        <category>Source_Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Source_Code</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射机制]]></title>
    <url>%2F2017%2F09%2F16%2FReflection%2F</url>
    <content type="text"><![CDATA[参考自百度百科-反射机制 反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理。 ClassObject 类作为所有Java 类的继承根源，其内声明了12个方法： public Object() public final Class&lt;?&gt; getClass() public final void notify() public final void notifyAll() public final void wait(long timeout)throws InterruptedException public final void wait(long timeout,int nanos)throws InterruptedException public final void wait() throws InterruptedException public int hashCode() public boolean equals(Object obj) protected Object clone()throws CloneNotSupportedException public String toString() protected void finalize()throws Throwable其中getClass()返回一个Class 对象。Class 类十分特殊。它和一般类一样继承自Object，其实体用以表达Java程序运行时的classes和interfaces，也用来表达enum、array、primitive Java types（boolean, byte, char, short, int, long, float, double）以及关键词void。当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class 对象。如果您想借由“修改Java标准库源码”来观察Class 对象的实际生成时机（例如在Class的constructor内添加一个println()），这样是行不通的！因为Class并没有public constructor。Class是Reflection故事起源。针对任何您想探勘的类，唯有先为它产生一个Class 对象，接下来才能经由后者唤起为数十多个的Reflection APIs。这些APIs将在稍后的探险活动中一一亮相。12345678910public final class Class&lt;T&gt; implements Serializable, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type, java.lang.reflect.AnnotatedElement &#123; //私有构造方法 private Class() &#123;&#125; public String toString() &#123; return ( isInterface() ? "interface " : (isPrimitive() ? "" : "class ")) + getName();&#125; Class object 诞生管道 运用getClass() Class c1 = str.getClass(); ```122. 运用Class.getSuperclass()```java Class c2 = c1.getSuperclass(); 运用static method——Class.forName()（最常被使用） Class c1 = Class.forName ("java.lang.String"); ```1234567894. 运用primitive wrapper classes的TYPE 语法```java Class c1 = Boolean.TYPE Class c3 = Character.TYPE; Class c5 = Integer.TYPE; Class c6 = Long.TYPE; Class c7 = Float.TYPE; Class c8 = Double.TYPE; Class c9 = Void.TYPE; Reflection 的三个动态性质： 运行时生成instances public Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)（同下） public Constructor&lt;?&gt;[] getDeclaredConstructors() public Constructor getConstructor(Class&lt;?&gt;… parameterTypes) public Constructor&lt;?&gt;[] getConstructors()12345678910111213//无参构造函数Class&lt;?&gt; c = Class.forName("DynTest");Object obj = null;obj = c.newInstance(); //有参构造函数， 需要获取响应的构造方法Class&lt;?&gt; c = Class.forName("DynTest");Class&lt;?&gt;[] pTypes = new Class&lt;?&gt;[] &#123; double.class, int.class &#125;;Constructor&lt;?&gt; ctor = c.getConstructor(pTypes);//Constructor&lt;?&gt; ctor = c.getConstructor(double.class, int.class);Object obj = null;Object[] arg = new Object[] &#123;3.14159, 125&#125;; obj = ctor.newInstance(arg);//obj = ctor.newInstance(3.14159, 125); 执行期唤起methods 索取Method object时不需指定回返类型，因为method overloading机制要求signature（署名式）必须唯一，而回返类型并非signature的一个成份。换句话说，只要指定了method名称和参数列，就一定指出了一个独一无二的method。 public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)throws NoSuchMethodException,SecurityException（返回一个Method对象，该对象反映了由此Class对象表示的类或接口的指定已声明方法） public Method getMethod(String name,Class&lt;?&gt;… parameterTypes)throws NoSuchMethodException,SecurityException（返回一个Method对象，该对象反映此Class对象所表示的类或接口的指定公共成员方法） public Method[] getDeclaredMethods()throws SecurityException（返回一个包含Method对象的数组，该对象反映了由此Class对象表示的类或接口的所有已声明方法，包括public，protected，default（package）访问和private方法，但不包括继承方法。） public Method[] getMethods()throws SecurityException（返回一个包含Method对象的数组，该对象反映了由此Class对象表示的类或接口的所有公共方法，包括由类或接口声明的那些以及从超类和超接口继承的那些方法。） 123456789101112131415161718public String func(String s, Hashtable ht)&#123; System.out.println("func invoked"); return s;&#125;public static void main(String args[])&#123; Class c = Class.forName("Test"); Class ptypes[] = new Class[2]; ptypes[0] = Class.forName("java.lang.String"); ptypes[1] = Class.forName("java.util.Hashtable"); //获取指定方法 Method m = c.getMethod("func",ptypes); Test obj = new Test(); //Test obj = (Test)c.newInstance(); Object arg[] = new Object[2]; arg[0] = new String("Hello,world"); arg[1] = null; String r = (String)m.invoke(obj, arg);&#125; 运行时改动fields。 public Field getField(String name)（同上） public Field[] getFields() public Field getDeclaredField(String name) public Field[] getDeclaredFields()1234567891011public class Test &#123; public double d; public static void main(String args[])&#123; Class c = Class.forName("Test"); Field f = c.getField("d"); //指定field 名称 Test obj = new Test(); System.out.println("d= " + (Double)f.get(obj)); f.set(obj, 12.34); System.out.println("d= " + obj.d); &#125;&#125; 12345678910111213141516171819202122232425//实际应用样例Class cname=null;Object theInst = null;try &#123; cname = Class.forName (className); 由字符串找到相应的类 theInst=(Object)cname.newInstance(); 实例化初始类&#125;catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; Method[] methodes = cname.getDeclaredMethods(); 获取类中所有的方法for (int i = 0; i &lt; methodes.length; i++)&#123; Method method = methodes[i]; if (method.getName().equals(methodName)) 查找并判定与既定方法相同的方法 &#123; Object result=null; try&#123; System.out.println(method.getName()); result = method.invoke(theInst, arg);执行相应的方法(agr为方法所需要的参数，不止一个可能) &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Reflection</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节序]]></title>
    <url>%2F2017%2F09%2F09%2F%E5%AD%97%E8%8A%82%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[字节序 顾名思义，字节顺序，又称端序或尾序。在计算机科学领域中，是跨越多字节的程序对象的存储规则。 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。大端模式和小端模式的起源 关于大端小端名词的由来，有一个有趣的故事，来自于Jonathan Swift的《格利佛游记》：Lilliput和Blefuscu这两个强国在过去的36个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可以那时的皇帝的祖父由于小时侯吃鸡蛋，按这种方法把手指弄破了，因此他的父亲，就下令，命令所有的子民吃鸡蛋的时候，必须先打破鸡蛋较小的一端，违令者重罚。然后老百姓对此法令极为反感，期间发生了多次叛乱，其中一个皇帝因此送命，另一个丢了王位，产生叛乱的原因就是另一个国家Blefuscu的国王大臣煽动起来的，叛乱平息后，就逃到这个帝国避难。据估计，先后几次有11000余人情愿死也不肯去打破鸡蛋较小的端吃鸡蛋。这个其实讽刺当时英国和法国之间持续的冲突。Danny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。 ##什么是大端和小端 小端就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 大端就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 比如数字0x12 34 56 78在内存中的表示形式为： 大端模式：(低地址 -&gt; 高地址)0x12 | 0x34 | 0x56 | 0x78 小端模式：(低地址 -&gt; 高地址)0x78 | 0x56 | 0x34 | 0x12 可见，大端模式和字符串的存储模式类似。 大端小端没有谁优谁劣，各自优势便是对方劣势： 小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。 大端模式 ：符号位的判定固定为第一个字节，容易判断正负。 为什么会有大小端模式之分呢？ 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。 如何判断机器的字节序12345678910111213141516171819202122232425BOOL IsBigEndian() &#123; int a = 0x1234; char b = *(char *)&amp;a; //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分 if( b == 0x12) &#123; return TRUE; &#125; return FALSE; &#125;//联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：BOOL IsBigEndian() &#123; union NUM &#123; int a; char b; &#125;num; num.a = 0x1234; if( num.b == 0x12 ) &#123; return TRUE; &#125; return FALSE; &#125;]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建对象]]></title>
    <url>%2F2017%2F09%2F02%2FJava%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[创建对象的四种方式 new语句 Object.clone()方法 序列化、反序列化 反射手段,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法 new语句调用类的构造方法创建对象person p = new person(8); Object.clone()方法### API中定义为protected Object clone() throws CloneNotSupportedException{}，即意味着该方法只对其子类可见！ 与此同时API还强调Throws:CloneNotSupportedException - if the object’s class does not support the Cloneable interface. Subclasses that override the clone method can also throw this exception to indicate that an instance cannot be cloned.即意味着想要实现复制克隆的类必须实现cloneable接口,而该接口中并无任何方法，其作用可以看做是一个标识！ 浅复制，如需实现深拷贝，则需重新实现clone（）；实例1234567891011121314151617public class Person implements Cloneable&#123; public int number; person(int number)&#123; this.number = number; &#125; public person getInstance() throws CloneNotSupportedException&#123; return (Person) this.clone(); &#125;&#125;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Person p = new Person(8); Person temp = p.getInstance(); System.out.println(temp.number); &#125;&#125; 序列化、反序列化ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;Person.java&quot;)); Person p = (Person) in.readObject(); 反射手段,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法 调用java.lang.Class类的newInstance()实例方法 //第一种方式 Person p = (Person) Class.forName(“other.Person”).newInstance(); //第二种方式 Person p1 = Person.class.newInstance(); 调用java.lang.reflect.Constructor 类的newInstance()实例方法 Constructor c = Person.class.getConstructor(); Person p = c.newInstance();]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template Method Pattern]]></title>
    <url>%2F2017%2F08%2F26%2FTemplateMethodPattern%2F</url>
    <content type="text"><![CDATA[Template Method Pattern（模板方法模式）Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclass redefine certain steps of an algorithm without changing the algorithm’s structure. （定义一个操作中的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。） 抽象模板（AbstractTemplate）：一个抽象类,定义若干方法表示一个算法的步骤，有抽象方法也有非抽象方法，抽象方法表示原子操作，非抽象方法表示原子步骤 具体模板（ConcreteTemplate）：抽象模板的子类，实现抽象模板的原子操作 应用场景：非抽象方法负责定义步骤流程，钩子方法，子类可以按照抽象模板的规定步骤进行（用final修饰来强制继承不能改动），也可重写非抽象方法来自己定义步骤流程，或者还可以在确定什么样的条件下去执行算法的哪些步骤（boolean返回类型的钩子方法的用途） javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930//AbstractTemplatepublic abstract class Template&#123; public abstract void first(); public abstract void second(); public abstract void third(); public final void templateMethod()&#123; first(); second(); third(); &#125;&#125;//ConcreteTemplatepublic class ConcreteTemplate extends Template&#123; public void first()&#123; System.out.println("首先"); &#125; public void second()&#123; System.out.println("然后"); &#125; public void third()&#123; System.out.println("其次"); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Template t = new ConcreteTemplate(); t.templateMethod(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visitor Pattern]]></title>
    <url>%2F2017%2F08%2F26%2FVisitorPattern%2F</url>
    <content type="text"><![CDATA[Visitor Pattern（访问者模式）Represent an operation to be performed on the elements of an object structure.Visitor lets you define a new operation without changing the classes of the elements on which it operates.（封装一些作用于某种数据结构中的各种元素，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。） 抽象元素（Element）：一个抽象类，定义了接受访问者的accept方法 具体元素（ConcreteElement）：Element的子类 抽象访问者(Visitor)：一个接口，定义了操作具体元素的方法 具体访问者(ConcreteVisitor)：抽象访问者接口的实现类 应用场景：双重分派（数据的存储和操作解耦）,不同的访问者访问同一元素，进行的操作不同，结果也不同，但访问这一动作共同的，只是传入的对象不同，导致操作/结果不同 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Elementpublic abstract class Element&#123; public abstract void accept(Visitor v); public abstract double showElectricAmount(); public abstract void setElectricAmount(double n); &#125;//ConcreteElementpublic class ConcreteElement extends Element&#123; double count; public void accept(Visitor v)&#123; System.out.println(v.visitor(this)); &#125; public double showElectricAmount()&#123; return count; &#125; public void setElectricAmount(double n)&#123; count = n; &#125;&#125;//Visitorpublic interface Visitor&#123; public double visitor(Element element);&#125;//ConcreteVisitorpublic class ConcreteVisitorOne implements Visitor&#123; public double visitor(Element element)&#123; return element.showElectricAmount(); &#125;&#125;public class ConcreteVisitorTwo implements Visitor&#123; public double visitor(Element element)&#123; return element.showElectricAmount()+1; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Element e = new ConcreteElement(); Visitor v = new ConcreteVisitorOne(); e.setElectricAmount(20); e.accept(v); v = new ConcreteVisitorTwo(); e.accept(v); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Strategy Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FStrategyPattern%2F</url>
    <content type="text"><![CDATA[Strategy Pattern（策略模式）Define a family of algorithms, encapsulate each one, and make them interchangeable.（定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。） 策略（Strategy）：一个接口 上下文（Context）：依赖于策略接口的类（组合关系） 具体策略（ConcreteStrategy）：策略接口的实现类 应用场景：一个类定义了多种行为构成了多个条件分支（封装算法的细节） javac -encoding UTF-8 Application.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Strategypublic interface Strategy&#123; public double computerAverage(double [] a); &#125;//Contextpublic class AverageScore&#123; //组合 Strategy stratrgy; public void setStrategy(Strategy stratrgy)&#123; this.stratrgy = stratrgy; &#125; public double getAverage(double [] a)&#123; return stratrgy.computerAverage(a); &#125;&#125;//ConcreteStrategypublic class StrategyA implements Strategy &#123; public double computerAverage(double [] a)&#123; double average = 0; for (double i : a) &#123; average += i; &#125; average /=a.length; return average; &#125;&#125;import java.util.Arrays;public class StrategyB implements Strategy &#123; public double computerAverage(double [] a)&#123; double average = 0; Arrays.sort(a); for (int i = 1;i &lt; a.length-1 ;i++ ) &#123; average += a[i]; &#125; average /=(a.length-2); return average; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; double [] tuple = new double[]&#123;90,90,98,87,76,45&#125;; AverageScore ave = new AverageScore(); //策略A ave.setStrategy(new StrategyA()); double score = ave.getAverage(tuple); //策略B ave.setStrategy(new StrategyB()); double score1 = ave.getAverage(tuple); System.out.printf("%10f %10f",score,score1); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FProxypattern%2F</url>
    <content type="text"><![CDATA[Proxy pattern（代理模式）Provide a surrogate (代理) or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。） 抽象主题（Subject）：一个接口 实际主题（RealSubject）：实现了抽象主题接口的类 代理(Proxy)：实现了抽象主题接口的类，含有抽象主题声明的变量，来存放实际主题的实例的引用 应用场景：代理的实例用来控制对他所包含的实际主题的实例的访问，即控制他所代理对象的访问权限（java远程代理RMI同理） javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627//Subjectpublic interface Employee&#123; public String hearPhone();&#125;//RealSubjectpublic class Boss implements Employee&#123; public String hearPhone()&#123; return "面谈吧"; &#125;&#125;//Proxypublic class Secretary implements Employee&#123; Boss boss; Secretary()&#123; boss = new Boss(); &#125; public String hearPhone()&#123; return "我们老板说："+boss.hearPhone(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Secretary s = new Secretary(); System.out.println(s.hearPhone()); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[State Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FStatePattern%2F</url>
    <content type="text"><![CDATA[State Pattern（状态模式）Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.（当一个对象在状态改变时允许其改变行为，这个对象看起来像改变了其类。） 抽象状态（State）：一个接口或者抽象类 环境（Context）：依赖于策略接口的类（组合关系） 具体状态（ConcreteState）：状态接口（抽象类）的实现类（扩展类） 应用场景：一个对象的状态依赖于它的行为，状态随着行为的改变为改变 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Statepublic abstract class State&#123; public abstract void shoot(); public abstract void loadBullets();&#125;//Contextpublic class Gun&#123; public State stateThree,stateTwo,stateOne,stateNull; public State state; public Gun()&#123; stateThree = new BulletStateThree(this); stateTwo = new BulletStateTwo(this); stateOne = new BulletStateOne(this); stateNull = new BulletStateNull(this); state = stateThree; &#125; public void setState(State state)&#123; this.state = state; &#125; public void fire()&#123; state.shoot(); &#125; public void load()&#123; state.loadBullets(); &#125;&#125;//ConcreteStatepublic class BulletStateNull extends State&#123; Gun gun; BulletStateNull(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("没有子弹了！"); &#125; public void loadBullets()&#123; System.out.println("装弹-------"); gun.setState(gun.stateThree); &#125;&#125;public class BulletStateOne extends State&#123; Gun gun; BulletStateOne(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("射出一颗子弹！"); gun.setState(gun.stateNull); &#125; public void loadBullets()&#123; System.out.println("无法装弹！"); &#125;&#125;public class BulletStateTwo extends State&#123; Gun gun; BulletStateTwo(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("射出一颗子弹！"); gun.setState(gun.stateOne); &#125; public void loadBullets()&#123; System.out.println("无法装弹！"); &#125;&#125;public class BulletStateThree extends State&#123; Gun gun; BulletStateThree(Gun gun)&#123; this.gun = gun; &#125; public void shoot()&#123; System.out.println("射出一颗子弹！"); gun.setState(gun.stateTwo); //gun,setState(new BulletStateTwo(gun)); &#125; public void loadBullets()&#123; System.out.println("无法装弹！"); &#125;&#125;//Testpublic class Application &#123; public static void main(String[] args) &#123; Gun gun = new Gun(); gun.fire(); gun.fire(); gun.fire(); gun.fire(); gun.load(); gun.fire(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Singleton Pattern]]></title>
    <url>%2F2017%2F08%2F19%2FSingletonPattern%2F</url>
    <content type="text"><![CDATA[Singleton PatternEnsure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。） 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 12345678910111213public class Singleton &#123; //持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 private static Singleton instance = null; //私有构造方法，防止被实例化 private Singleton() &#123;&#125; //静态工程方法，创建实例 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 上面的类在单线程情况下不会出错，但是如果我们把它放入多线程的环境下，就会出现问题了，如何解决？我们可以对getInstance方法加synchronized关键字，如下：123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 但是，synchronized关键字会锁住整个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都会对对象上锁，事实上，我们只需要在第一次创建对象的时候需要加锁，之后就不需要了，所以，我们进一步改进为：12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (instance) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 如果不了解jvm中指令重排的同学可能认为上面的改进已经算是完善了，但是，在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton()语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例： a&gt;A、B线程同时进入了第一个if判断 b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton(); c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。 d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。 e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。 所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，在写多线程环境下的程序是有一定难度的。我们对该程序做进一步优化：123456private static class SingletonFactory&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonFactory.instance; &#125; 实际上，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们可以暂时总结一个完整的单例模式如下：123456789101112public class Singleton &#123; //私有构造方法，防止被实例化 private Singleton() &#123;&#125; //此处使用一个内部类来维护单例 private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; //获取实例 public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memento Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FMementoPattern%2F</url>
    <content type="text"><![CDATA[Memento Pattern（备忘录模式）Without violating encapsulation， capture and externalize an object’s internal state so that the object can be restored to this state later.（在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原来保存的状态。）Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; //public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; //public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; //Testpublic class Test &#123; public static void main(String[] args) &#123; // 创建原始类 Original origi = new Original("egg"); // 创建备忘录 Storage storage = new Storage(origi.createMemento()); // 修改原始类的状态 System.out.println("初始化状态为：" + origi.getValue()); origi.setValue("niu"); System.out.println("修改后的状态为：" + origi.getValue()); // 回复原始类的状态 origi.restoreMemento(storage.getMemento()); System.out.println("恢复后的状态为：" + origi.getValue()); &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prototype Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FPrototypePattern%2F</url>
    <content type="text"><![CDATA[Prototype Pattern（原型模式）Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。） 抽象原型（Prototype）：一个接口，定义对象复制自身的方法 具体原型（ConcretePrototype）：抽象原型的实现类 应用场景：通过复制原型创建新的对象(序列化/反序列化，Class.clone()克隆，深度克隆) javac -encoding UTF-8 Application.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Prototypepublic interface Prototype&#123; public Object cloneMe() throws CloneNotSupportedException;&#125;//ConcretePrototypepublic class CloneA implements Prototype,Cloneable &#123; int a; CloneA(int a)&#123; this.a = a; &#125; public Object cloneMe() throws CloneNotSupportedException&#123; CloneA object = (CloneA)clone(); return object; &#125;&#125;import java.io.*;public class CloneB implements Prototype,Serializable &#123; StringBuffer color; public void setColor(StringBuffer c)&#123; color = c; &#125; public StringBuffer getColor()&#123; return color; &#125; public Object cloneMe() throws CloneNotSupportedException&#123; Object object = null; try&#123; ByteArrayOutputStream outOne = new ByteArrayOutputStream(); ObjectOutputStream outTwo = new ObjectOutputStream(outOne); outTwo.writeObject(this); ByteArrayInputStream inOne = new ByteArrayInputStream(outOne.toByteArray()); ObjectInputStream inTwo = new ObjectInputStream(inOne); object = inTwo.readObject(); &#125;catch(Exception e)&#123;&#125; return object; &#125;&#125;//Testpublic class Application &#123; public static void main(String[] args) &#123; try&#123; CloneA c = new CloneA(2); CloneA c1 = (CloneA)c.cloneMe(); System.out.print(c.a+"---"+c1.a); CloneB cc = new CloneB(); cc.setColor(new StringBuffer("A")); CloneB cc1 = (CloneB)cc.cloneMe(); cc1.setColor(new StringBuffer("copyA")); System.out.print(cc.getColor()+"---"+cc1.getColor()); &#125;catch(Exception e)&#123;&#125; &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Observer Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FObserverPattern%2F</url>
    <content type="text"><![CDATA[Observer Pattern（观察者模式）Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。） 主题（Subject）：一个接口,规定具体主题需要实现的方法 观察者（Observer）：一个接口，规定了具体观察者用来获取数据的方法 具体主题(ConcreteSubject)：主题接口的实现类，该实例包含观察者所关心的数据（经常变动），含有观察者的引用，以便在数据发生变化时通知观察者更新数据 具体观察者(ConcreteObserver)：观察者接口的实现类，含有具体主题的引用，以便于具体主题将自己添加/删除到其集合中去，成为该主题的观察者 应用场景：观察者对于主题中的数据可采用两种方法——“拉”数据或者——-“推”数据,即主题主动将数据更新推送给观察者，或者只是通知观察者数据已更新，观察者自己调用主题方法实现数据更新，适用于一个对象数据更新时需要通知其他对象（或者让其自行更新） javac -encoding UTF-8 Application.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Subjectpublic interface Subject&#123; public void addObserver(Observer o); public void deleteObserver(Observer o); public void notifyObservers(); public void setDate(String name,String author,String publisher,float price); public String getName(); public float getPrice(); public String getAuthor(); public String getPublisher();&#125;//Observerpublic interface Observer&#123; public void update();&#125;//ConcreteSubjectimport java.util.LinkedList;public class BookStore implements Subject&#123; private String name,author,publisher; private float price; private LinkedList&lt;Observer&gt; list; BookStore()&#123; list = new LinkedList&lt;Observer&gt;(); &#125; public void addObserver(Observer o)&#123; if(!list.contains(o)) list.add(o); &#125; public void deleteObserver(Observer o)&#123; if(list.contains(o)) list.remove(o); &#125; public void notifyObservers()&#123; for (Observer observer : list) &#123; observer.update(); &#125; &#125; public void setDate(String name,String author,String publisher,float price)&#123; this.name = name; this.author = author; this.publisher = publisher; this.price = price; notifyObservers(); //一旦发生数据更新，随即通知各个观察者 &#125; public String getName()&#123; return name; &#125; public float getPrice()&#123; return price; &#125; public String getAuthor()&#123; return author; &#125; public String getPublisher()&#123; return publisher; &#125;&#125;//ConcreteObserverpublic class CustomerOne implements Observer &#123; private Subject subject; private String bookName; private float price; CustomerOne(Subject subject)&#123; this.subject = subject; subject.addObserver(this); &#125; public void update()&#123; bookName = subject.getName(); price = subject.getPrice(); System.out.println(bookName+"和"+price+"更新了"); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Subject s = new BookStore(); Observer o = new CustomerOne(s); s.setDate("设计模式","刘飞","清华出版社",25); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mediator Pattern]]></title>
    <url>%2F2017%2F08%2F12%2FMediatorPattern%2F</url>
    <content type="text"><![CDATA[Mediator Pattern（中介者模式）Define an object that encapsulates how a set of objects interact.Mediator promotes loose couping by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而使其耦合松散，而且可以独立的改变它们之间的交互。） 中介者（Mediator）：一个接口，定义同事Colleague对象中间用于通信的方法 具体中介者（Invoker）：Mefiator接口的实现类，包含具体同事ConcreteColleague对象的引用 同事（Colleague）：一个接口，定义具体同事要是实现的方法 具体同事（ConcreteColleague）：同事接口的实现类，同事包含中介者的引用，同事之间也可以相互交流 应用场景：避免同事对象之间显示的引用，将同事之间的通信交由中介来负责 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Mediatorpublic interface Mediator&#123; public void registerColleague(Colleague colleague); public void deliverMess(String mess,Colleague... c);&#125;//Invokerimport java.util.ArrayList;public class ConcreteMediator implements Mediator&#123; ArrayList&lt;Colleague&gt; list; ConcreteMediator()&#123; list = new ArrayList&lt;Colleague&gt;(); &#125; public void registerColleague(Colleague colleague)&#123; list.add(colleague); &#125; public void deliverMess(String mess,Colleague... c)&#123; for (Colleague colleague : c) &#123; if(list.contains(colleague)) colleague.receiveMess(mess,colleague); else continue; &#125; &#125;&#125;//Colleaguepublic interface Colleague&#123; public void setName(String name); public String getName(); public void sendMess(String mess,Colleague... c); public void receiveMess(String mess,Colleague c); public void setMediator(Mediator mediator);&#125;//ConcreteColleaguepublic class ConcreteColleague implements Colleague&#123; Mediator mediator; String name; public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125; public void sendMess(String mess,Colleague... c)&#123; mediator.deliverMess(mess,c); &#125; public void receiveMess(String mess,Colleague c)&#123; System.out.println(this.getName()+":来自"+c.getName()+"的消息"); System.out.println("-----------"+mess); &#125; public void setMediator(Mediator mediator)&#123; this.mediator = mediator; mediator.registerColleague(this); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Mediator m = new ConcreteMediator(); Colleague c = new ConcreteColleague(); Colleague c1 = new ConcreteColleague(); Colleague c2 = new ConcreteColleague(); c.setMediator(m); c1.setMediator(m); c2.setMediator(m); c.setName("C"); c1.setName("C1"); c2.setName("C2"); c.sendMess("Hello!",c1,c2); c1.sendMess("Hi",c); c2.sendMess("Hi!",c); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decorator Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FDecoratorPattern%2F</url>
    <content type="text"><![CDATA[Decorator Pattern（装饰模式）Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。） 抽象组件（Component）:抽象类，定义需要进行装饰的方法，被装饰角色 具体组件（ConcreteComponent）:抽象组件的一个子类 装饰（Decorator）：也是抽象组件的一个子类，装饰者角色 具体装饰（ConcreteDecorator）：装饰的一个非抽象子类 应用场景：动态的给对象添加一些额外的方法，改进类的某个对象的功能，调用同样的方法，不一样的结果 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142//Componentpublic abstract class Bird&#123; public abstract int fly();&#125;//ConcreteComponentpublic class Sparrow extends Bird&#123; private final static int DISTANCE = 100; public int fly()&#123; return DISTANCE; &#125;&#125;//Decoratorpublic abstract class Decorator extends Bird&#123; Bird bird; Decorator()&#123;&#125; Decorator(Bird bird)&#123; this.bird = bird; &#125;&#125;//ConcreteDecoratorpublic class ConcreteDecorator extends Decorator&#123; private final static int DISTANCE = 50; ConcreteDecorator(Bird bird)&#123; super(bird); &#125; public int fly()&#123; return bird.fly()+DISTANCE; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Bird bird = new Sparrow(); System.out.println(bird.fly()); bird = new ConcreteDecorator(bird); System.out.println(bird.fly()); bird = new ConcreteDecorator(bird); System.out.println(bird.fly()); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flyweight Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FFlyweightPattern%2F</url>
    <content type="text"><![CDATA[Flyweight Pattern（享元模式）Use sharing to support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细粒度对象。） 享元接口（Flyweight）：一个接口，定义了享元对外公开内部数据的方法以及接受外部数据的方法 具体享元（ConcreteFlyweight）：享元接口的实现类的实例 享元工厂(FlyweightFactory)：一个类，负责创建和管理享元实例，其他对象对享元的请求必须通过工厂才能获得一个享元对象的实例引用 应用场景：利用一个叫做享元的对象来为其他对象提供共享的状态，且保证其他对象不能更改享元中的数据 javac -encoding UTF-8 Application.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Flyweightpublic interface Flyweight&#123; public double getWeight(); public double getWidth(); public double getLength();&#125;//ConcreteFlyweightpublic class Car&#123; Flyweight flyweight; String color; double power; Car(Flyweight flyweight,String color,double power)&#123; this.flyweight = flyweight; this.color = color; this.power = power; &#125; public void print()&#123; System.out.println(color); System.out.println(power); System.out.println(flyweight.getWeight()); System.out.println(flyweight.getWidth()); System.out.println(flyweight.getLength()); &#125;&#125;//FlyweightFactorypublic class FlyweightFactory&#123; static FlyweightFactory factory = new FlyweightFactory(); static Flyweight intrinsic; private FlyweightFactory()&#123;&#125; public static FlyweightFactory getFactory()&#123; return factory; &#125; public Flyweight getFlyweight()&#123; intrinsic = new DateCar(1.43,1.45,5.21); return intrinsic; &#125; //内部类 class DateCar implements Flyweight&#123; private double weight; private double width; private double length; //私有构造方法，不允许其他程序直接使用享元类来直接创建享元对象 private DateCar(double weight,double width,double length)&#123; this.weight = weight; this.width = width; this.length = length; &#125; public double getWeight()&#123; return weight; &#125; public double getWidth()&#123; return width; &#125; public double getLength()&#123; return length; &#125; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; FlyweightFactory factory = FlyweightFactory.getFactory(); Flyweight carIntrinsic = factory.getFlyweight(); Car one = new Car(carIntrinsic,"red",5000); Car two = new Car(carIntrinsic,"blue",3000); one.print(); two.print(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facade Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FFacadePattern%2F</url>
    <content type="text"><![CDATA[Facade Pattern（门面模式）Provide a unified interface to a set of interface in a subsystem.Facede defines a higher-level interface that makes the subsystem easier to use.(要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供了一个高层次的接口，使得子系统更容易使用。) 子系统（Subsystem）:若干类的集合，均不包含外观类的实例引用 外观（Facade）：一个含有子系统中全部或者部分类的实例引用的类 应用场景：跟踪系统使用情况（经过同一个接口），更换系统（只需更改外观接口的代码） javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//Subsystempublic class CPU &#123; public void startup()&#123; System.out.println("cpu startup!"); &#125; public void shutdown()&#123; System.out.println("cpu shutdown!"); &#125; &#125; public class Memory &#123; public void startup()&#123; System.out.println("memory startup!"); &#125; public void shutdown()&#123; System.out.println("memory shutdown!"); &#125; &#125; public class Disk &#123; public void startup()&#123; System.out.println("disk startup!"); &#125; public void shutdown()&#123; System.out.println("disk shutdown!"); &#125; &#125; //Facadepublic class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println("start the computer!"); cpu.startup(); memory.startup(); disk.startup(); System.out.println("start computer finished!"); &#125; public void shutdown()&#123; System.out.println("begin to close the computer!"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println("computer closed!"); &#125; &#125; //Testpublic class Application &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startup(); computer.shutdown(); &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interpreter Pattern]]></title>
    <url>%2F2017%2F08%2F05%2FInterpreterPattern%2F</url>
    <content type="text"><![CDATA[Interpreter Pattern（解释器模式）Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences int the language.（给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。）123456789101112131415161718192021222324252627282930313233343536373839404142434445//public interface Expression &#123; public int interpret(Context context); &#125; public class Plus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()+context.getNum2(); &#125; &#125; public class Minus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()-context.getNum2(); &#125; &#125; public class Context &#123; private int num1; private int num2; public Context(int num1, int num2) &#123; this.num1 = num1; this.num2 = num2; &#125; public int getNum1() &#123; return num1; &#125; public void setNum1(int num1) &#123; this.num1 = num1; &#125; public int getNum2() &#123; return num2; &#125; public void setNum2(int num2) &#123; this.num2 = num2; &#125; &#125; //Testpublic class Test &#123; public static void main(String[] args) &#123; // 计算9+2-8的值 int result = new Minus().interpret((new Context(new Plus() .interpret(new Context(9, 2)), 8))); System.out.println(result); &#125; &#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Command Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FCommandPattern%2F</url>
    <content type="text"><![CDATA[Command Pattern（命令模式）Encapsulate a request as an object,thereby letting you parameterize clients with different requests,queue or log requests, and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。） 命令（Command）：一个接口，封装请求的若干方法 请求者（Invoker）：包含Command接口变量的类的实例（组合关系） 接收者（Receiver）：一个类的实例，执行与请求有关的操作 具体命令（ConcreteCommand）：Command接口的实现类 应用场景：请求者与接收者不直接交互，消除彼此的耦合（将命令拆分），命令的撤销（栈的应用）：”\b” 退格键 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//Commandpublic interface BattleCommand&#123; abstract void execute();&#125;//Invokerpublic class ArmySuperior&#123; public BattleCommand command; public void setBattleCommand(BattleCommand command)&#123; this.command = command; &#125; public void startExecuteCommand()&#123; command.execute(); &#125;&#125;//Receiverpublic interface Army&#123; public void attack();&#125;public class ArmyA implements Army&#123; public void attack()&#123; System.out.println("炮火攻打县城A外围"); System.out.println("坦克进攻"); System.out.println("步兵进攻"); &#125;&#125;public class ArmyB implements Army&#123; public void attack()&#123; System.out.println("在敌人增援路上埋地雷"); System.out.println("在战壕里射击增援的敌人"); &#125;&#125;public class ArmyC implements Army&#123; public void attack()&#123; System.out.println("佯攻县城B"); &#125;&#125;//ConcreteCommandpublic class CommandA implements BattleCommand&#123; Army army; public CommandA(Army army)&#123; this.army = army; &#125; public void execute()&#123; army.attack(); &#125;&#125;public class CommandB implements BattleCommand&#123; Army army; public CommandB(Army army)&#123; this.army = army; &#125; public void execute()&#123; army.attack(); &#125;&#125;public class CommandC implements BattleCommand&#123; Army army; public CommandC(Army army)&#123; this.army = army; &#125; public void execute()&#123; army.attack(); &#125;&#125;//Testpublic class Application &#123; public static void main(String[] args) &#123; ArmySuperior superior = new ArmySuperior(); Army army = new ArmyA(); BattleCommand command = new CommandA(army); superior.setBattleCommand(command); superior.startExecuteCommand(); army = new ArmyB(); command = new CommandB(army); superior.setBattleCommand(command); superior.startExecuteCommand(); army = new ArmyC(); command = new CommandC(army); superior.setBattleCommand(command); superior.startExecuteCommand(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chain Of Responsibility Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FChainOfResponsibilityPattern%2F</url>
    <content type="text"><![CDATA[Chain Of Responsibility Pattern（责任链模式）Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.（使多个对象有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系 。将这些对象连成一个链，并沿着这条链传递请求，知道有对象处理它为止。） 处理者（Handler）：一个接口,负责规定具体处理者处理用户的请求的方法和具体处理者设置后继对象的方法 具体处理者（ConcreteHandler）：Handler接口的实现类，调用处理者接口规定的方法处理用户的请求，若能处理则进行处理，不能则传给下一节点 应用场景：形成一个处理链，挨个节点判断是否能够进行处理，阶乘的计算（从结果的数据量按需判断那个节点可以容纳结果） javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Handlerpublic interface Handler&#123; public abstract void computerMultiply(String number); public abstract void setNextHandler(Handler handler);&#125;//ConcreteHandlerimport java.util.*;public class UseInt implements Handler&#123; private int result = 1; private Handler handler; public void computerMultiply(String number)&#123; try&#123; int n = Integer.parseInt(number); while(n &gt; 0)&#123; result *=n--; if (result &lt;= 0) &#123; System.out.println("超出int计算范围"); handler.computerMultiply(number); return; &#125; &#125; System.out.println(result); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125;&#125;public class UseLong implements Handler&#123; private long result = 1; private Handler handler; public void computerMultiply(String number)&#123; try&#123; long n = Long.parseLong(number); while(n &gt; 0)&#123; result *=n--; if (result &lt;= 0) &#123; System.out.println("超出long计算范围"); handler.computerMultiply(number); return; &#125; &#125; System.out.println(result); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125;&#125;import java.util.*;import java.math.BigInteger;public class UseBigInteger implements Handler&#123; private BigInteger result = new BigInteger("1"); private Handler handler; public void computerMultiply(String number)&#123; try&#123; BigInteger n = new BigInteger(number); BigInteger ONE = new BigInteger("1"); while(n.compareTo(ONE) &gt; 0)&#123; result = result.multiply(n); n = n.subtract(ONE); &#125; System.out.println(result); &#125;catch(Exception e)&#123; System.out.println(e.toString()); &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler = handler; &#125;&#125;//Testimport java.util.*;public class Application&#123; public static void main(String[] args) &#123; Handler uint,ulong,ubint; uint = new UseInt(); ulong = new UseLong(); ubint = new UseBigInteger(); uint.setNextHandler(ulong); ulong.setNextHandler(ubint); uint.computerMultiply("5"); uint.computerMultiply("19"); uint.computerMultiply("30"); uint.computerMultiply("100"); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Behavioral_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Command Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FCompositePattern%2F</url>
    <content type="text"><![CDATA[Composite Pattern（组合模式）Compose objects into tree structure to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly.（将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。） 抽象组件（Component）:一个接口或者抽象类，定义了个体对象和组合对象需要实现的关于原子操作的方法 Composite节点（Composite Node）:实现了Component接口的类，其中可包含其他Composite节点（组合对象） Leaf节点（Leaf Node）：实现了Component接口的类，不可包含其他Composite节点或者Leaf节点（个体对象） 应用场景：个体对象和组合对象实现于同一接口，形成树形结构（部分-整体层次结构） javac -encoding UTF-8 Application.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//Componentimport java.util.*;public interface MilitaryPerson&#123; public void add(MilitaryPerson person); public void remove(MilitaryPerson person); public MilitaryPerson getChild(int index); public Iterator&lt;MilitaryPerson&gt; getAllChild(); public boolean isLeaf(); public double getSalary(); public void setSalary(double salary); &#125;//Composite Nodeimport java.util.*;public class MilitaryOfficer implements MilitaryPerson&#123; private String name; private double salary; private LinkedList&lt;MilitaryPerson&gt; list; MilitaryOfficer(String name,double salary)&#123; this.name = name; this.salary = salary; list = new LinkedList&lt;MilitaryPerson&gt;(); &#125; public void add(MilitaryPerson person)&#123; list.add(person); &#125; public void remove(MilitaryPerson person)&#123; list.remove(person); &#125; public MilitaryPerson getChild(int index)&#123; return list.get(index); &#125; public Iterator&lt;MilitaryPerson&gt; getAllChild()&#123; return list.iterator(); &#125; public boolean isLeaf()&#123; return false; &#125; public double getSalary()&#123; return salary; &#125; public void setSalary(double salary)&#123; this.salary = salary; &#125;&#125;//Leaf Nodeimport java.util.*;public class MilitarySoldier implements MilitaryPerson&#123; private String name; private double salary; MilitarySoldier(String name,double salary)&#123; this.name = name; this.salary = salary; &#125; public void add(MilitaryPerson person)&#123;&#125; public void remove(MilitaryPerson person)&#123;&#125; public MilitaryPerson getChild(int index)&#123;return null;&#125; public Iterator&lt;MilitaryPerson&gt; getAllChild()&#123;return null;&#125; public boolean isLeaf()&#123; return true; &#125; public double getSalary()&#123; return salary; &#125; public void setSalary(double salary)&#123; this.salary = salary; &#125;&#125;//Testimport java.util.*;public class Application&#123; public static void main(String[] args) &#123; MilitaryPerson 连长 = new MilitaryOfficer("连长",5000); MilitaryPerson 营长 = new MilitaryOfficer("营长",4000); MilitaryPerson 班长 = new MilitaryOfficer("班长",3000); MilitaryPerson 士兵 = new MilitarySoldier("士兵",2000); 连长.add(营长); 营长.add(班长); 班长.add(士兵); System.out.println(computerSalary(连长)); &#125; public static double computerSalary(MilitaryPerson person)&#123; double sum = 0; if(person.isLeaf()==true) sum += person.getSalary(); else&#123; sum += person.getSalary(); Iterator&lt;MilitaryPerson&gt; it = person.getAllChild(); while(it.hasNext())&#123; MilitaryPerson p = it.next(); sum += computerSalary(p); &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Builder Pattern]]></title>
    <url>%2F2017%2F07%2F29%2FBuilderPattern%2F</url>
    <content type="text"><![CDATA[Builder Pattern（建造者模式）Separate the construction of a complex object form its representation so that the same construction process can create different representations.（将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。） 产品（Product）：具体生成器要构造的复杂对象 抽象生成器（Builder）：一个接口，有为创建一个产品对象的各个组件定义的若干方法，还有返回产品对象的方法 具体生成器（ConcreteBuilder）：Builder的实现类 指挥者（Director）：一个类，拥有Builder接口声明的变量，负责向用户提供具体生成器 应用场景：将一个复杂对象的构建与表示分离，使得同样的构建可以创建不同的表示 javac -encoding UTF-8 Application.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Productpublic class Product&#123; //产品假设是一台电脑 public String "主机"； public String "显示器"; public String "键盘";&#125;//Builderpublic interface Builder&#123; public abstract String buildZJ(); public abstract String buildXSQ(); public abstract String buildJP(); public abstract void creat();&#125;//ConcreteBuilderpublic class BuilderOne implements Builder &#123; public String buildZJ()&#123; return "YYY牌主机"; &#125; public String buildXSQ()&#123; return "YYY牌显示器"; &#125; public String buildJP()&#123; return "YYY牌键盘"; &#125; public void creat()&#123; System.out.println(buildZJ()); System.out.println(buildJP()); System.out.println(buildXSQ()); &#125; &#125;public class BuilderTwo implements Builder &#123; public String buildZJ()&#123; return "XXX牌主机"; &#125; public String buildXSQ()&#123; return "XXX牌显示器"; &#125; public String buildJP()&#123; return "XXX牌键盘"; &#125; public void creat()&#123; System.out.println(buildZJ()); System.out.println(buildXSQ()); System.out.println(buildJP()); &#125;&#125;//Directorpublic class Director&#123; private Builder builder; Director(Builder builder)&#123; this.builder = builder; &#125; public void createComputer()&#123; builder.creat(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Builder b = new BuilderOne(); Director d = new Director(b); d.createComputer(); b = new BuilderTwo(); d = new Director(b); d.createComputer(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adapter Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FAdapterPattern%2F</url>
    <content type="text"><![CDATA[Adapter Pattern（适配器模式） Convert the inface of a class into another interface clients expect.Adapter lets classes work together that couldn’t otherwise because of incompatible interface.（将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。）“系统的数据和行为都正确，单接口不符时，我们应该考虑使用适配器，目的是是控制范围之外的一个原有对象与某个接口匹配。适配器模式主要用于希望复用一些现存的类，但是接口又与复用环境不一致的情况。”（《大话设计模式》） 目标（Target）：一个接口，客户想要使用的接口 被适配器（Adaptee）：一个已经存在的接口或者抽象类 适配器(Adapter)：一个实现了目标接口并且含有被适配器引用的类 应用场景：目标和被适配器完全解耦，通过适配器来建立联系（单接口适配器） javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233//Targetpublic interface ZhiLiuDian&#123; public String privideZhiLiuDian();&#125;//Adapteepublic interface JiaoLiuDian&#123; public String privideJiaoLiuDian();&#125;public class JiaoLiuDianHost implements JiaoLiuDian&#123; public String privideJiaoLiuDian()&#123; return "交流电"; &#125;&#125;//Adapterpublic class Adapter implements ZhiLiuDian&#123; JiaoLiuDian jiao; Adapter(JiaoLiuDian jiao)&#123; this.jiao = jiao; &#125; public String privideZhiLiuDian()&#123; String s = jiao.privideJiaoLiuDian(); return "转换"+s+"成直流电"; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; JiaoLiuDian jiao = new JiaoLiuDianHost(); System.out.println(jiao.privideJiaoLiuDian()); ZhiLiuDian zhi = new Adapter(jiao); System.out.println(zhi.privideZhiLiuDian()); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Structural_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bridge Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FBridgePattern%2F</url>
    <content type="text"><![CDATA[Bridge Pattern（桥梁模式）Decouple an abstraction from its implementation so that the two can vary independently.（将抽象和实现解耦，使得两者可以独立的变化。） 抽象（Abstraction）：一个抽象类，含有实现者声明的变量， 实现者（Implementor）：一个接口，定义基本操作 细化抽象（RefinedAbstraction）：抽象的子类 具体实现者（ConcreteImplementor）：实现者的实现类 应用场景：分离实现和抽象，将抽象中方法的重要实现部分交给另外一个抽象类的子类或者接口的类 javac -encoding UTF-8 Application.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Abstractionpublic abstract class BookEdit&#123; BookWriter [] author; String [] seriesBookName; public abstract void planBook(String [] s,String [] a); public abstract void releaseBook();&#125;//Implementorpublic interface BookWriter&#123; public void startWriterBook(String bookName); public String getName();&#125;//RefinedAbstractionpublic class TUBookEdit extends BookEdit&#123; public void planBook(String [] s,String [] a)&#123; seriesBookName = s; author = new BookAuthor[seriesBookName.length]; for (int i = 0;i &lt; seriesBookName.length ;i++ ) &#123; author[i] = new BookAuthor(a[i]); author[i].startWriterBook(seriesBookName[i]); &#125; &#125; public void releaseBook()&#123; System.out.println("图书有关信息"); for (int i = 0;i &lt; seriesBookName.length ;i++ ) &#123; System.out.print("书名："+seriesBookName[i]+"-------"); System.out.println("作者："+author[i].getName()); &#125; &#125;&#125;//ConcreteImplementorpublic class BookAuthor implements BookWriter&#123; String name; BookAuthor(String s)&#123; name = s; &#125; public void startWriterBook(String s)&#123; System.out.println(name+"编著了"+s); &#125; public String getName()&#123; return name; &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; TUBookEdit zhang = new TUBookEdit(); String seriesBookName [] = &#123;"C程序设计","Java程序设计","XML程序设计"&#125;; String authorName [] = &#123;"张三","李四","王五"&#125;; zhang.planBook(seriesBookName,authorName); zhang.releaseBook(); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Abstract Factory Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FAbstractFactoryPattern%2F</url>
    <content type="text"><![CDATA[Abstract Factory Pattern（抽象工厂模式）Provide an interface for creating families of related or dependent objects without specifying their concrete classes.（为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。） 抽象产品（Product）：一个接口或者抽象类，定义、产品必须实现的方法 具体产品（ConcreteProduct）：抽象产品的子类或者实现类 抽象工厂（AbstractFactory）：一个接口或者抽象类，定义若干个抽象方法 具体工厂（ConcreteFactory）：抽象工厂的实现类或者子类，重写抽象方法，使其返回具体产品的实例 应用场景：提供一个创建一系列或相互依赖对象的接口，而无需知道他们具体的类，反射机制+抽象工厂（反射可以灵活地进行实例化） javac -encoding UTF-8 Application.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Productpublic abstract class Weapon&#123; protected String type; public abstract void loadBullet(Bullet bullet);&#125;public abstract class Bullet&#123; public abstract void load(String type);&#125;//ConcreteProductpublic class JiQiang extends Weapon&#123; JiQiang()&#123; type = "机枪"; &#125; public void loadBullet(Bullet bullet)&#123; bullet.load(type); &#125;&#125;public class ShouQiang extends Weapon&#123; ShouQiang()&#123; type = "手枪"; &#125; public void loadBullet(Bullet bullet)&#123; bullet.load(type); &#125;&#125;public class JiQiangBullet extends Bullet&#123; public void load(String type)&#123; System.out.println(type+"---装载机枪型子弹"); &#125;&#125;public class ShouQiangBullet extends Bullet&#123; public void load(String type)&#123; System.out.println(type+"---装载手枪型子弹"); &#125;&#125;//Creatorpublic abstract class Factory&#123; public abstract Weapon createWeapon(); public abstract Bullet createBullet();&#125;//ConcreteCreatorpublic class ShouQiangFactory extends Factory &#123; public Weapon createWeapon()&#123; return new ShouQiang(); &#125; public Bullet createBullet()&#123; return new ShouQiangBullet(); &#125;&#125;public class JiQiangFactory extends Factory&#123; public Weapon createWeapon()&#123; return new JiQiang(); &#125; public Bullet createBullet()&#123; return new JiQiangBullet(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; Factory factory = new ShouQiangFactory(); Weapon gun = factory.createWeapon(); Bullet bullet = factory.createBullet(); gun.loadBullet(bullet); factory = new JiQiangFactory(); gun = factory.createWeapon(); bullet = factory.createBullet(); gun.loadBullet(bullet); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Factory Pattern]]></title>
    <url>%2F2017%2F07%2F22%2FFactoryPattern%2F</url>
    <content type="text"><![CDATA[Factory Pattern（工厂模式） Define an interface for creating an object,but let subclass decide which class to instantiate.Factory Method lets a class defer instantiation to subclass.（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到其子类。） 抽象产品（Product）：一个接口或者抽象类，定义、产品必须实现的方法 具体产品（ConcreteProduct）：抽象产品的子类或者实现类 构造者（Creator）：一个接口或者抽象类，定义一个叫做工厂方法的抽象方法，该方法返回具体产品类的实例 具体构造者（ConcreteCreator）：构造者实现类或者子类 应用场景：使一个类的实例化延迟到其子类，或者是想得到某一类的子类的实例，但是却无法直接使用new（不允许与该子类形成耦合），或者不清楚该类有哪些子类可用 javac -encoding UTF-8 Application.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Productpublic abstract class PenCore&#123; String color; public abstract void writeword(String s);&#125;//ConcreteProductpublic class RedPen extends PenCore&#123; RedPen()&#123; color = "红色"; &#125; public void writeword(String s)&#123; System.out.println("写出"+color+"的字："+s); &#125;&#125;public class BluePen extends PenCore&#123; BluePen()&#123; color = "蓝色"; &#125; public void writeword(String s)&#123; System.out.println("写出"+color+"的字："+s); &#125;&#125;public class BallPen&#123; PenCore core; public void usePenCore(PenCore core)&#123; this.core = core; &#125; public void write(String s)&#123; core.writeword(s); &#125;&#125;//AbstractFactorypublic abstract class Creator&#123; public abstract PenCore getPenCore();&#125;//ConcreteFactorypublic class RedCreator extends Creator&#123; public PenCore getPenCore()&#123; return new RedPen(); &#125;&#125;public class BlueCreator extends Creator&#123; public PenCore getPenCore()&#123; return new BluePen(); &#125;&#125;//Testpublic class Application&#123; public static void main(String[] args) &#123; PenCore core; //笔芯 Creator c = new RedCreator(); //笔芯构造者 BallPen b = new BallPen(); //圆珠笔 core = c.getPenCore(); b.usePenCore(core); b.write("哈"); c = new BlueCreator(); core = c.getPenCore(); b.usePenCore(core); b.write("ha"); &#125;&#125;]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
        <tag>Creational_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java架构学习心得(一)]]></title>
    <url>%2F2017%2F07%2F15%2FJava%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[序言 软件开发从最初的pc单机的人机交互模式到后来局域网的出现开启了软件开发的c/s模式（客户端/服务器模式），在到现在的b/s模式（浏览器/服务器），其实都面临的着相同的问题——代码的冗余，相似代码的大量重复导致整体代码量的庞大，所以为了减少代码的冗余，避免上述情况的产生，框架应用而生！而框架的原理其实主要就只有两部分，流程的抽象和数据类型的抽象，下面我们一一道来！（此文章适合于学过jsp及j2EE的童鞋） 正文首先我们来说流程控制，b/s模式均由浏览器向服务器发出请求，然后服务器响应相关请求并回传结果给浏览器，这是个一成不变的通用过程，所以我要做的就是抽象这个过程，类似于Struts2，把请求和响应的控制流程抽象到框架中去，让框架去拦截掉你的所有请求，然后经过处理后在传递给服务器，服务器的相响应结果同样被框架截获，然后处理后再扔给浏览器去显示，以上是大概流程，下面我们用程序代码详细道来！1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;FlowControl&gt; &lt;Action name="login"&gt; &lt;OperatePoint name="login_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;OperatePoint name="login_check"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;OperatePoint name="login_init"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;Action name="register"&gt; &lt;OperatePoint name="register_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;Action name="xxx"&gt; &lt;OperatePoint name="xxx_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;/FlowControl&gt; 上面的xml配置文件类似于Struts2的struts.xml，用于表明整个项目中所有的请求与对应请求的响应，Action为我自己定义的用于处理相关的请求动作类，OperatePoint为动作类中不同的方法，用于减少过多动作类，将一组相关的动作处理放入到同一个类中，用不同的方法去处理，减少代码的冗余。123456789101112131415161718192021222324252627282930313233343536&lt;filter&gt; &lt;filter-name&gt;FrameFilter&lt;/filter-name&gt; &lt;filter-class&gt;edu.frame.web.core.FrameFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;ExcludedPages&lt;/param-name&gt; &lt;param-value&gt;/authImage,/register&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DataBaseName&lt;/param-name&gt; &lt;param-value&gt;MySql&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DBConfigFile&lt;/param-name&gt; &lt;param-value&gt;DBConfig.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;FlowControlConfigFile&lt;/param-name&gt; &lt;param-value&gt;flowcontrol.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;AppBasePath&lt;/param-name&gt; &lt;param-value&gt;edu.demo.web.flowcontrol&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ConfigPath&lt;/param-name&gt; &lt;param-value&gt;config&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;JspPath&lt;/param-name&gt; &lt;param-value&gt;jsp&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FrameFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 上述代码段来自web.xml，我们用一个名叫FrameFilter的filter来拦截浏览器发送的所有的请求然后判定请求的类别，如果是jsp页面，我们不做处理直接扔给服务器，如果是action类请求，我们获取路径分解出类名和方法名，利用Java反射机制实例化相应的的动作类执行相应的方法，然后返回结果字符串result，在根据结果result找到流程控制配置文件中对应的jsp页面扔给服务器。init-param部分为初始化参数，包括ExcludedPages（请求过滤页面），DataBaseName（选用数据库名称，我们将数据库的统一操作也封装在框架内，应用层通过配置文件来进行数据库的选择和连接），DBConfigFile（数据库配置文件）FlowControlConfigFile（流程控制文件），AppBasePath（action动作类目录），ConfigPath（配置文件地址），JspPath（页面地址）。因此FrameFilter.java为本框架中最核心的部分，下面我们来看一下此文件的具体内容123456789101112131415161718public class FrameFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)&#123;&#125; //前处理，字符的乱码，数据库和流程控制配置文件的解析与实例化封装 public void perpare(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //初始化过滤器，加载web.xml文件中参数 public void init(FilterConfig config) throws ServletException &#123;&#125; //获取物理路径 private String getRealPath(FilterConfig config, String name)&#123;&#125; //请求匹配，判定是action还是jsp页面 public String actionMapping(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //action执行前的准备，action动作类名及方法的提取分离 public void prepareExecute(HttpServletRequest request, HttpServletResponse response,String functionName)&#123;&#125; //根据传来的动作类名和方法名去相应的action中执行相应的方法，返回result public String executeAction(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //根据action类返回的result跳转到相应的jsp页面 public void dispatcher(HttpServletRequest request, HttpServletResponse response,String result)&#123;&#125;&#125; 上述即为流程控制的核心部分，涉及到的细节有xml配置文件的解析（需引入dom4j或者其他的xml解析jar包，例如数据库配置文件和流程控制文件的解析均需要用到），还有就是java的反射机制，已知类名和方法名的字符串实现类的实例化，及方法的执行。]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Struts</tag>
        <tag>JavaWeb</tag>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重温JavaEE_SSH框架]]></title>
    <url>%2F2017%2F07%2F08%2F%E9%87%8D%E6%B8%A9JavaEE-SSH%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[知识只有当需要书写下来或者讲解出来的时候才显得如此匮乏——菜鸟飞 struts2 hibernate spring ssh整合及项目实例 Struts2 Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。——百度百科 在我看来，struts本质就类似于一个filter，所以在使用前需要在项目lib目录中导入相应的jar包并在项目的web.xml文件中配置如下内容12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置完成后，所有的页面请求便会被截获到struts.xml的配置文件中，如下图所示，Struts2框架中核心组件就是Action、拦截器等，Struts2框架使用包来管理Action和拦截器等。每个包就是多个Action、多个拦截器、多个拦截器引用的集合。在struts.xml文件中package元素用于定义包配置，每个package元素定义了一个包配置。它的常用属性有： name：必填属性，用来指定包的名字。 extends：可选属性，用来指定该包继承其他包。继承其它包，可以继承其它包中的Action定义、拦截器定义等。 namespace：可选属性，用来指定该包的命名空间。(考虑到同一个Web应用中需要同名的Action，Struts2以命名空间的方式来管理Action，同一个命名空间不能有同名的Action。Struts2通过为包指定namespace属性来为包下面的所有Action指定共同的命名空间。) 其中action标签中的name属性表示与你所截获的请求名称进行匹配(也就是说将来你项目的所有页面请求在这里都会有所记录，可以清晰地体现你项目的页面跳转逻辑，同时也极大的方便了以后的更改操作)struts.xml12345678&lt;struts&gt; &lt;package name="default" extends="struts-default"&gt; &lt;action name="index" class="com.action.IndexAction"&gt; &lt;result name="success"&gt;index.jsp&lt;/result&gt; &lt;result name="error"&gt;error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 对应的action标签中的class属性表示该请求所对应的Action处理类，因为Struts2中的Action采用了低侵入式的设计，所以Struts2不要求Action类继承任何的Struts2的基类或实现Struts2接口。但是，我们为了方便实现Action，大多数情况下都会继承com.opensymphony.xwork2.ActionSupport类，并重写此类里的public String execute() throws Exception方法(Action处理类默认执行方法)。（因为此类中实现了很多的实用接口，提供了很多默认方法，这些默认方法包括获取国际化信息的方法、数据校验的方法、默认的处理用户请求的方法等，这样可以大大的简化Action的开发。)，Action处理类的所有方法最后都会返回一个字符串，如SUCCESS给struts.xml，而action标签内的result标签中的name属性负责匹配传回的字符串，从而跳转至不同的页面123456789101112public class IndexAction extends ActionSupport&#123; public String execute()throws Exception&#123; try &#123; &#125; return SUCCESS; &#125; catch (Exception e) &#123; e.printStackTrace(); return ERROR; &#125; &#125; public String ownMethod()throws Exception&#123;&#125;&#125; 当然你也可以去书写并执行自己的方法，这时你只需要在处理类中加入自己的ownMethod()方法，并在struts.xml文件中的对应的action标签中做如下修改即可1&lt;action name="index" class="com.action.IndexAction!ownMethod"&gt; 以下内容为struts.xml配置详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;struts&gt; &lt;!-- include节点是struts2中组件化的方式 可以将每个功能模块独立到一个xml配置文件中 然后用include节点引用 --&gt; &lt;include file="struts-default.xml"&gt;&lt;/include&gt; &lt;!-- 所有匹配*.action的请求都由struts2处理 --&gt; &lt;constant name="struts.action.extension" value="action" /&gt; &lt;!-- 是否启用开发模式 --&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!-- struts配置文件改动后，是否重新加载 --&gt; &lt;constant name="struts.configuration.xml.reload" value="true" /&gt; &lt;!-- 设置浏览器是否缓存静态内容 --&gt; &lt;constant name="struts.serve.static.browserCache" value="false" /&gt; &lt;!-- 请求参数的编码方式 --&gt; &lt;constant name="struts.i18n.encoding" value="utf-8" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件，有助于开发 --&gt; &lt;constant name="struts.i18n.reload" value="true" /&gt; &lt;!-- 文件上传最大值 --&gt; &lt;constant name="struts.multipart.maxSize" value="104857600" /&gt; &lt;!-- 让struts2支持动态方法调用 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; &lt;!-- Action名称中是否还是用斜线 --&gt; &lt;constant name="struts.enable.SlashesInActionNames" value="false" /&gt; &lt;!-- 允许标签中使用表达式语法 --&gt; &lt;constant name="struts.tag.altSyntax" value="true" /&gt; &lt;!-- 对于WebLogic,Orion,OC4J此属性应该设置成true --&gt; &lt;constant name="struts.dispatcher.parametersWorkaround" value="false" /&gt; &lt;package name="basePackage" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!-- 定义拦截器 name:拦截器名称 class:拦截器类路径 --&gt; &lt;interceptor name="timer" class="com.kay.timer"&gt;&lt;/interceptor&gt; &lt;interceptor name="logger" class="com.kay.logger"&gt;&lt;/interceptor&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name="mystack"&gt; &lt;interceptor-ref name="timer"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="logger"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 定义默认的拦截器 每个Action都会自动引用 如果Action中引用了其它的拦截器 默认的拦截器将无效 --&gt; &lt;default-interceptor-ref name="mystack"&gt;&lt;/default-interceptor-ref&gt; &lt;!-- 全局results配置 --&gt; &lt;global-results&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="" class=""&gt; &lt;!-- 引用拦截器 name:拦截器名称或拦截器栈名称 --&gt; &lt;interceptor-ref name="timer"&gt;&lt;/interceptor-ref&gt; &lt;!-- 节点配置 name : result名称 和Action中返回的值相同 type : result类型 不写则选用superpackage的type struts-default.xml中的默认为dispatcher --&gt; &lt;result name="success" type="dispatcher"&gt;/talk.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 允许一个Action内包含多个请求处理方法：动态方法调用是指：表单元素的action不直接等于某个Action的名字，而是以感叹号后加方法名来指定对应的动作名：要使用动态方法调用，必须设置Struts2允许动态方法调用，通过设置struts.enable.DynamicMethodInvocation常量来完成，该常量属性的默认值是true。1234567&lt;struts&gt; &lt;!-- //禁用动态方法调用，默认为true启用，false禁用 constant:name="struts.enable.DynamicMethodInvocation" --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt;&lt;/struts&gt; 默认Action： 在浏览器输入一个不存在的Action，页面将呈现404错误，为了网站更友好，我们可以设置一个默认的Action。1234&lt;default-action-ref name="defaultAction"&gt;&lt;/default-action-ref&gt; &lt;action name="defaultAction"&gt; &lt;result&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; 处理结果类型： Struts2提供了对不同种类返回结果的支持，常见的有JSP，FreeMarker，Velocity等。 Struts2支持的不同类型的返回结果为：(加粗为常用) 名字 说明 chain 用来处理Action链 dispatcher 用来转向页面，通常处理JSP，这是默认的结果类型 freeMarker 处理FreeMarker模板 httpHeader 用来控制特殊的Http行为 redirect 重定向到一个URL redirect-action 重定向到一个Action stream 向浏览器发送InputSream对象，通常用来处理文件下载 velocity 处理Velocity模板 xslt 处理XML/XLST模板 plaintext 显示原始文件内容，例如文件源代码 tiles 结合Tile使用strutsUI页面标签库的引用需在jsp页面加入以下内容（详细介绍链接）1&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt; Hibernate Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。——百度百科 Hibernate的API一共有6个，分别为:Session、SessionFactory、Transaction、Query、Criteria和Configuration。通过这些接口，可以对持久化对象进行存取、事务控制。 SessionSession接口负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的SQL语句)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSession对象称为用户session。 SessionFactorySessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。 TransactionTransaction 接口是一个可选的API，可以选择不使用这个接口，取而代之的是Hibernate 的设计者自己写的底层事务处理代码。 Transaction 接口是对实际事务实现的一个抽象，这些实现包括JDBC的事务、JTA 中的UserTransaction、甚至可以是CORBA 事务。之所以这样设计是能让开发者能够使用一个统一事务的操作界面，使得自己的项目可以在不同的环境和容器之间方便地移植。 QueryQuery接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。Query经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。 CriteriaCriteria接口与Query接口非常类似，允许创建并执行面向对象的标准化查询。值得注意的是Criteria接口也是轻量级的，它不能在Session之外使用。 ConfigurationConfiguration 类的作用是对Hibernate 进行配置，以及对它进行启动。在Hibernate 的启动过程中，Configuration 类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象。虽然Configuration 类在整个Hibernate 项目中只扮演着一个很小的角色，但它是启动hibernate 时所遇到的第一个对象。 Hibernate.xml配置 Hibernate.show_sql：是否在运行时候sql语句输出到控制台，编码阶段便于测试的。（默认设置为true） Hibernate.format_sql：输出在控制台sql语句是否进行排版，便于阅读。（默认设置为true） Hbm2ddl.auto：可帮助由Java代码生成数据库脚本，进而生成具体表结构。如：create/update/create-drop/validate。 hbm2ddl.auto: 生成表结构的策略配置update(最常用的取值): 如果当前数据库中不存在表结构,那么自动创建表结构.如果存在表结构,并且表结构与实体一致,那么不做修改如果存在表结构,并且表结构与实体不一致,那么会修改表结构.会保留原有列.create(很少):无论是否存在表结构.每次启动Hibernate都会重新创建表结构.(数据会丢失)create-drop(极少): 无论是否存在表结构.每次启动Hibernate都会重新创建表结构.每次Hibernate运行结束时,删除表结构.validate(很少):不会自动创建表结构.也不会自动维护表结构.Hibernate只校验表结构. 如果表结构不一致将会抛出异常.12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC"-//Hibernate/Hibernate Configuration DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- property 元素用于配置Hibernate中的属性键:值 --&gt; &lt;!-- hibernate.connection.driver_class : 连接数据库的驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- hibernate.connection.username : 连接数据库的用户名 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!-- hibernate.connection.password : 连接数据库的密码 --&gt; &lt;property name="hibernate.connection.password"&gt;123&lt;/property&gt; &lt;!-- hibernate.connection.url : 连接数据库的地址,路径 --&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hibernatedemｏ&lt;/property&gt; &lt;!-- show_sql: 操作数据库时,会 向控制台打印sql语句 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- format_sql: 打印sql语句前,会将sql语句先格式化 --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 数据库方言配置org.hibernate.dialect.MySQLDialect (选择最短的)--&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- hibernate.connection.autocommit: 事务自动提交 --&gt; &lt;property name="hibernate.connection.autocommit"&gt;true&lt;/property&gt; &lt;!-- 将Session与线程绑定=&gt; 只有配置了该配置,才能使用getCurrentSession --&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 引入ORM 映射文件 填写src之后的路径--&gt; &lt;mapping resource="com/itheima/a_hello/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; XXXX.hbm.xml(ecplise可自动生成)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;!-- &lt;hibernate-mapping&gt;一般不去配置，采用默认即可。 default-cascade="none"：默认的级联风格，表与表联动。 default-lazy="true"：默认延迟加载 --&gt; &lt;hibernate-mapping&gt; &lt;!-- &lt;class&gt;：使用class元素定义一个持久化类。 name="cn.javass.user.vo.UserModel"：持久化类的java全限定名； table="tbl_user"：对应数据库表名； mutable="true"：默认为true，设置为false时则不可以被应用程序更新或删除； dynamic-insert="false"：默认为false，动态修改那些有改变过的字段，而不用修改所有字段； dynamic-update="false"：默认为false，动态插入非空值字段； select-before-update="false"：默认为false，在修改之前先做一次查询，与用户的值进行对比，有变化都会真正更新； optimistic-lock="version"：默认为version(检查version/timestamp字段)，取值：all(检查全部字段)、dirty(只检查修改过的字段)、 none(不使用乐观锁定)，此参数主要用来处理并发，每条值都有固定且唯一的版本，版本为最新时才能执行操作； --&gt; &lt;class name="cn.javass.user.vo.UserModel" table="tbl_user" dynamic-insert="true" dynamic-update="true" optimistic-lock="version"&gt; &lt;!-- &lt;id&gt;：定义了该属性到数据库表主键字段的映射。 name="userId"：标识属性的名字； column="userId"：表主键字段的名字，如果不填写与name一样； --&gt; &lt;id name="userId"&gt; &lt;!-- &lt;generator&gt;：指定主键由什么生成，推荐使用uuid（随机生成唯一通用的表示符，实体类的ID必须是String）， native（让数据库自动选择用什么生成（根据底层数据库的能力选择identity，sequence或hilo中的一种））， assigned（指用户手工填入，默认）。 --&gt; &lt;generator class="uuid"/&gt; &lt;/id&gt; &lt;!-- &lt;version/&gt;：使用版本控制来处理并发，要开启optimistic-lock="version"和dynamic-update="true"。 name="version"：持久化类的属性名，column="version"：指定持有版本号的字段名； --&gt; &lt;version name="version" column="version"/&gt; &lt;!-- &lt;property&gt;：为类定义一个持久化的javaBean风格的属性。 name="name"：标识属性的名字，以小写字母开头； column="name"：表主键字段的名字，如果不填写与name一样； update="true"/insert="true"：默认为true，表示可以被更新或插入； --&gt; &lt;property name="name" column="name" /&gt; &lt;property name="sex" column="sex"/&gt; &lt;property name="age" column="age"/&gt; &lt;!-- 组件映射：把多个属性打包在一起当一个属性使用，用来把类的粒度变小。 &lt;component name="属性，这里指对象"&gt; &lt;property name="name1"&gt;&lt;/property&gt; &lt;property name="name2"&gt;&lt;/property&gt; &lt;/component&gt; --&gt; &lt;!-- &lt;join&gt;:一个对象映射多个表，该元素必须放在所有&lt;property&gt;之后。 &lt;join table="tbl_test：子表名"&gt; &lt;key column="uuid：子表主键"&gt;&lt;/key&gt; &lt;property name="name1：对象属性" column="name：子表字段"&gt;&lt;/property&gt; &lt;/join&gt; --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 实例 post.hbm.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.form.Post" table="post"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="id"/&gt; &lt;generator class="identity"/&gt; &lt;/id&gt; &lt;many-to-one name="admin" class="com.form.Admin" fetch="select" lazy="false"&gt; &lt;column name="aid"/&gt; &lt;/many-to-one&gt; &lt;many-to-one name="user" class="com.form.User" fetch="select" lazy="false"&gt; &lt;column name="uid"/&gt; &lt;/many-to-one&gt; &lt;many-to-one name="board" class="com.form.Board" fetch="select" lazy="false"&gt; &lt;column name="bid"/&gt; &lt;/many-to-one&gt; &lt;property name="name" type="string"&gt; &lt;column name="name"/&gt; &lt;/property&gt; &lt;property name="content" type="string"&gt; &lt;column name="content"/&gt; &lt;/property&gt; &lt;property name="publishTime" type="timestamp"&gt; &lt;column name="publishTime"/&gt; &lt;/property&gt; &lt;property name="count" type="java.lang.Integer"&gt; &lt;column name="count"/&gt; &lt;/property&gt; &lt;property name="photoPath" type="string"&gt; &lt;column name="photoPath"/&gt; &lt;/property&gt; &lt;set name="replies" inverse="true" cascade="all-delete-orphan" lazy="false" order-by="publishTime desc"&gt; &lt;key&gt; &lt;column name="pid" not-null="true"/&gt; &lt;/key&gt; &lt;one-to-many class="com.form.Reply"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;``` ### 说说为什么使用lazy```xml&lt;set name="replies" inverse="true" cascade="all-delete-orphan" lazy="true"&gt; 当使用Hibernate中的one-to-many、many-to one、many-to-many关系映射的时候，一个对象中会包含一个或多个Set来关联其他的对象。例如：user-groups，当程序取user 对象时，如果一个用户有多个自定义组，那么程序将把组的信息也读取出来，在log中可以看到两个sql的输出。但是在页面的显示上，也许并不需要显示这个用户相关组的信息，这样系统的消耗就白白浪费了，于是hibernate提供了lazy（延迟加载）的方法来避免这一情况的发生，我们只需要在 user.hbm.xml中设置lazy=true，就能实现延迟加载。 Spring 是一个非常强大的反转控制(IOC)框架，以帮助分离项目组件之间的依赖关系 控制反转——Spring通过一种称作控制反转（IoC）的技术促进了低耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。 web.xml配置123456789101112131415161718192021&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;filter&gt;&lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.orm.hibernate4.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;init-param&gt; &lt;param-name&gt;org.springframework.orm.hibernate4.LocalSessionFactoryBean&lt;/param-name&gt; &lt;param-value&gt;sessionFactory&lt;/param-value&gt;&lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 说说为什么使用OpenSessionInView1&lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt; 当hibernate+spring配合使用的时候，如果设置了lazy=true,那么在读取数据的时候，当读取了父数据后，hibernate会自动关闭session，这样，当要使用子数据的时候，系统会抛出lazyinit的错误，这时就需要使用spring提供的 OpenSessionInViewFilter,OpenSessionInViewFilter主要是保持Session状态知道request将全部页面发送到客户端，这样就可以解决延迟加载带来的问题 applicationContext.xml配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"? &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" &lt;!-- 自动扫描与装配bean，扫描web包，将带有注解的类纳入spring容器管理 --&gt; &lt;!-- &lt;context:component-scan base-package="cn.itcast.oa"&gt;作用 Spring容器初始化时，会扫描cn.itcast.oa目录下标有@Component；@Service；@Controller；@Repository 注解的类纳入Spring容器管理 在类上，使用以下注解，实现bean的声明： @Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service 用于标注业务层组件 @Controller 用于标注控制层组件（如springMvc的controller，struts中的action） @Repository用于标注数据访问组件，即DAO组件 在类的成员变量上，使用以下注解，实现属性的自动装配 @Autowired ：按类的类型进行装配 @Resource： 1.如果同时指定了name和type，那么从Spring上下文中找到唯一匹配的bean进行装配 2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 3.如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 4.如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； --&gt; &lt;context:component-scan base-package="cn.itcast.oa"&gt;&lt;/context:component-scan&gt; &lt;!-- 加载外部的properties配置文件（引入jdbc的配置文件） -- &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置数据库连接池（c3p0）这个可以在hibernate.cfg.xml中配置 -- &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 基本信息 ：jdbc的url、驱动名、数据库名字、密码-- &lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;!-- 其他配置 -- &lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 -- &lt;property name="initialPoolSize" value="3"&gt;&lt;/property&gt; &lt;!--连接池中保留的最小连接数。Default: 3 -- &lt;property name="minPoolSize" value="3"&gt;&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 -- &lt;property name="maxPoolSize" value="5"&gt;&lt;/property&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 -- &lt;property name="acquireIncrement" value="3"&gt;&lt;/property&gt;&lt;!-- 控制数据源内加载的PreparedStatements数量。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 -- &lt;property name="maxStatements" value="8"&gt;&lt;/property&gt;&lt;!-- maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 -- &lt;property name="maxStatementsPerConnection" value="5"&gt;&lt;/property&gt; &lt;!--最大空闲时间,1800秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 -- &lt;property name="maxIdleTime" value="1800"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory （把数据源注入给session工厂）、配置映射文件将Spring与hibernate初步整合起来 -- &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean" &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置声明式的事务管理（采用基于注解的方式） session工厂注入到事务管理器transactionManager使Spring与Hinbernate整合实现业务逻辑 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager" &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;/beans&gt; 常见问题 自动装配与扫描有问题，context的命名空间的问题1&lt;context:component-scan base-package="cn.itcast.oa"&gt;&lt;/context:component-scan&gt; &lt;beans xmlns=”http://www.springframework.org/schema/beans“ xmlns:context=”http://www.springframework.org/schema/context“ ssh整合及项目实例项目实例链接:https://github.com/LFstefan/JavaEE]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Struts</tag>
        <tag>JavaWeb</tag>
        <tag>Architecture</tag>
        <tag>Hibernate</tag>
        <tag>Spring</tag>
        <tag>Frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2017%2F07%2F01%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树红黑树，一种自平衡二叉查找树，又称之为”对称二叉B树”，虽然复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在logn时间内做查找，插入和删除。 红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。 红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。 性质红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 下面是一个具体的红黑树的图例： 这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。 在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用”nil叶子”或”空（null）叶子”，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。 因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再匹配红黑树的性质。恢复红黑树的性质需要少量的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为logn次。 插入 我们首先以二叉查找树的方法增加节点并标记它为红色。（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换和树旋转来调整。）下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意： 性质1和性质3总是保持着。 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。 在下面的的代码中，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。 通过下列函数，可以找到一个节点的叔父和祖父节点：123456789public node grandparent(node n)&#123; return n.parent.parent;&#125;public node uncle(node n)&#123; if(n.parent == grandparent(n).left) return grandparent (n).right; else return grandparent (n).left;&#125; 情形1:新节点N位于树的根上，没有父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5匹配。123456public void insert_case1(node n)&#123; if(n.parent == NULL) n.color = BLACK; else insert_case2 (n);&#125; 情形2:新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。123456public void insert_case2(node n)&#123; if(n.parent.color == BLACK) return; /* 树仍旧有效*/ else insert_case3 (n);&#125; 注意：在下列情形下我们假定新节点的父节点为红色，所以它有祖父节点；因为如果父节点是根节点，那父节点就应当是黑色。所以新节点总有一个叔父节点，尽管在情形4和5下它可能是叶子节点。 情形3:如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。（把G当成是新加入的节点进行各种情形的检查）12345678910public void insert_case3(node n)&#123; if(uncle(n) != NULL &amp;&amp; uncle (n).color == RED) &#123; n.parent.color = BLACK; uncle (n).color = BLACK; grandparent (n).color = RED; insert_case1(grandparent(n)); &#125; else insert_case4 (n);&#125; 注意：在余下的情形下，我们假定父节点P是其父亲G的左子节点。如果它是右子节点，情形4和情形5中的左和右应当对调。 情形4:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色;接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。12345678910public void insert_case4(node n)&#123; if(n == n.parent.right &amp;&amp; n.parent == grandparent(n).left) &#123; rotate_left(n-&gt;parent); n = n-&gt;left; &#125; else if(n == n.parent.left &amp;&amp; n.parent == grandparent(n).right) &#123; rotate_right(n.parent); n = n.right; &#125; insert_case5 (n);&#125; 情形5：父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。12345678910public void insert_case5(node n)&#123; n.parent.color = BLACK; grandparent (n).color = RED; if(n == n.parent.left &amp;&amp; n.parent == grandparent(n).left) &#123; rotate_right(grandparent(n)); &#125; else &#123; /* Here, n == n.parent.right &amp;&amp; n.parent == grandparent (n).right */ rotate_left(grandparent(n)); &#125;&#125; 注意插入实际上是原地算法，因为上述所有调用都使用了尾部递归。 删除 如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题（为了表述方便，这里所指的儿子，为非叶子节点的儿子）。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。 在本文余下的部分中，我们只需要讨论删除只有一个儿子的节点（如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子）。如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。 需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。我们将使用下述函数找到兄弟节点： 123456public node sibling(node n)&#123; if(n == n-&gt;parent-&gt;left) return n-&gt;parent-&gt;right; else return n-&gt;parent-&gt;left;&#125; 我们可以使用下列代码进行上述的概要步骤，这里的函数replace_node替换child到n在树中的位置。出于方便，在本章节中的代码将假定空叶子被用不是NULL的实际节点对象来表示（在插入章节中的代码可以同任何一种表示一起工作）。 123456789101112public void delete_one_child(struct node *n)&#123; //Precondition: n has at most one non-null child. struct node *child = is_leaf(n-&gt;right)? n-&gt;left : n-&gt;right; replace_node(n, child); if(n-&gt;color == BLACK)&#123; if(child-&gt;color == RED) child-&gt;color = BLACK; else delete_case1 (child); &#125; free (n);&#125; 如果N和它初始的父亲是黑色，则删除它的父亲导致通过N的路径都比不通过它的路径少了一个黑色节点。因为这违反了性质5，树需要被重新平衡。有几种情形需要考虑： 情形1: N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。1234public void delete_case1(struct node *n)&#123; if(n-&gt;parent != NULL) delete_case2 (n);&#125; 注意：在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。 情形2： S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。 注意：N是删除了黑色节点后替换上来的子节点，所以这个过程中由P-&gt;X-&gt;N变成了P-&gt;N，实际上是少了一个黑色节点，也可以理解为Parent(Black)和Silbing(Red)那么他们的孩子黑色节点的数目肯定不等，让他们做新兄弟肯定是不平衡的，还需后面继续处理。 123456789101112public void delete_case2(struct node *n)&#123; struct node *s = sibling (n); if(s-&gt;color == RED)&#123; n-&gt;parent-&gt;color = RED; s-&gt;color = BLACK; if(n == n-&gt;parent-&gt;left) rotate_left(n-&gt;parent); else rotate_right(n-&gt;parent); &#125; delete_case3 (n);&#125; 情形3： N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。123456789public void delete_case3(struct node *n)&#123; struct node *s = sibling (n); if((n-&gt;parent-&gt;color == BLACK)&amp;&amp;(s-&gt;color == BLACK)&amp;&amp;(s-&gt;left-&gt;color == BLACK)&amp;&amp;(s-&gt;right-&gt;color == BLACK)) &#123; s-&gt;color = RED; delete_case1(n-&gt;parent); &#125; else delete_case4 (n);&#125; 情形4： S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。123456789public void delete_case4(struct node *n)&#123; struct node *s = sibling (n); if（(n-&gt;parent-&gt;color == RED)&amp;&amp;(s-&gt;color == BLACK)&amp;&amp;(s-&gt;left-&gt;color == BLACK)&amp;&amp;(s-&gt;right-&gt;color == BLACK)) &#123; s-&gt;color = RED; n-&gt;parent-&gt;color = BLACK; &#125; else delete_case5 (n);&#125; 情形5： S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。123456789101112131415public void delete_case5(struct node *n)&#123; struct node *s = sibling (n); if（s-&gt;color == BLACK)&#123; if((n == n-&gt;parent-&gt;left)&amp;&amp;(s-&gt;right-&gt;color == BLACK)&amp;&amp;(s-&gt;left-&gt;color == RED)) &#123; // this last test is trivial too due to cases 2-4. s-&gt;color = RED; s-&gt;left-&gt;color = BLACK; rotate_right (s); &#125; else if((n == n-&gt;parent-&gt;right)&amp;&amp;(s-&gt;left-&gt;color == BLACK)&amp;&amp;(s-&gt;right-&gt;color == RED)) &#123;// this last test is trivial too due to cases 2-4. s-&gt;color = RED; s-&gt;right-&gt;color = BLACK; rotate_left (s); &#125; &#125; delete_case6 (n);&#125; 情形6： S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。此时，如果一个路径不通过N，则有两种可能性： 它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。 它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。 在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。 123456789101112public void delete_case6(node n)&#123; node s = sibling (n); s.color = n.parent.color; n.parent.color = BLACK; if(n == n.parent.left)&#123; s.right.color = BLACK; rotate_left(n.parent); &#125; else &#123; s.left.color = BLACK; rotate_right(n.parent); &#125;&#125; 同样的，函数调用都使用了尾部递归，所以算法是原地算法。此外，在旋转之后不再做递归调用，所以进行了恒定数目（最多3次）的旋转。]]></content>
      <categories>
        <category>查找</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tree</tag>
        <tag>算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-3树]]></title>
    <url>%2F2017%2F06%2F24%2F2-3%E6%A0%91%2F</url>
    <content type="text"><![CDATA[2-3查找树 2–3树是一种树型数据结构，内部节点（存在子节点的节点）要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。2–3树是平衡树，意味着右边，左边，中间的子树的元素数量都是相同或接近的。 如果一个内部节点拥有一个数据元素、两个子节点，则此节点为2节点。 如果一个内部节点拥有两个数据元素、三个子节点，则此节点为3节点。 当且仅当以下叙述中有一条成立时，T为2–3树： T为空。即T不包含任何节点。 T为拥有数据元素a的2节点。若T的左孩子为L、右孩子为R，则L和R是等高的非空2–3树； a大于L中的所有数据元素；同时a小于等于R中的所有数据元素。 T为拥有数据元素a和b的3节点，其中a &lt; b。若T的左孩子为L、中孩子为M、右孩子为R，则L、M、和R是等高的非空2–3树； a大于L中的所有数据元素，并且小于等于M中的所有数据元素；同时b大于M中的所有数据元素，并且小于等于R中的所有数据元素。 上面介绍了什么是2-3树，接下来我们看看2-3树有什么用，或者说是为什们会出现这种结构，下面我们先来考虑一个问题： 我们知道二叉搜索树的查找和搜索在平均情况下时间复杂度都能达到O(logn)，而且能保证数据有序。二叉搜索树的中序遍历就是数据的顺序。但是这个效率只是在平均情况下。如果数据是逆序，或者顺序，那么这棵树就会发生一边倒的情况使复杂度直接达到O(n)，就如同快排中选择到糟糕的主元(最大或者最小)。 通过上面的问题我们可以看出2-3树用来弥补二叉查找树在极端条件下的不足，因为2-3树是平衡树，所以不管数据怎么样，查找删除操作时间复杂度都至少能达到O(logn)，比起二叉查找树来有过之而无不及！2-3查找树的性质： 如果中序遍历2-3查找树，就可以得到排好序的序列； 在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。 复杂度分析： 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为log2(N) 在最好的情况下，所有的节点都是3-node节点，查找效率为log3(N) 距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。 对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。 但是2-3树实现比较复杂，需要掌控的情况很多，剥离节点，传递节点等操作，都需要很复杂的代码，且也会耗费不少的时间。所以我们一般不怎么用原始的2-3树，而是用2-3树的变形红黑树.]]></content>
      <categories>
        <category>Data_Structure</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Data_Structure</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2017%2F06%2F17%2FB%E6%A0%91%E5%92%8CB%2B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。 维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。 B树定义： B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。 根节点至少有两个子节点 每个节点有M-1个key，并且以升序排列 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间 其它节点至少有M/2个子节点 可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入 B+树定义： B+树是对B树的一种变形树，它与B树的差异在于： 有k个子结点的结点必然有k个关键码；非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。 B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。 B+ 树的优点在于： 由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如： Windows：HPFS文件系统；Mac：HFS，HFS+文件系统；Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；数据库：ORACLE，MYSQL，SQLSERVER等中。 有关B/B+树在数据库索引中的应用，请看张洋的MySQL索引背后的数据结构及算法原理这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。 树表查找总结： 二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。 除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。]]></content>
      <categories>
        <category>Data_Structure</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Data_Structure</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环]]></title>
    <url>%2F2017%2F06%2F10%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[约瑟夫环问题问题描述 ：这个问题是以弗拉维奥·约瑟夫命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的n个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，他们围成一个圈，从第1个人开始报数，报到m的人自杀，下一个人重新开始报数，如此循环，直到所有人全都自杀为止。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。我们首先模拟整个过程将自杀顺序打印粗来，n个人用1~N来标号表示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public int showJoseph(int total, int cycle) &#123; boolean[] arr = new boolean[total]; Arrays.fill(arr, true); int kill = 0; int index = 0; int result = 0; while (kill &lt; total) &#123; for (int i = 0; i &lt; cycle; i++) &#123; //过滤掉已经自杀的人 while (!arr[index]) &#123; index = (index + 1) % total; &#125; if (i == cycle - 1) &#123; System.out.print(index + 1); arr[index] = false; kill++; &#125; if(kill==total-1) result = (index+1); index = (index+1) % total; &#125; &#125; return result; &#125; //限定起点位置public int showJoseph(int total, int cycle, int start) &#123; boolean[] arr = new boolean[total]; Arrays.fill(arr, true); int kill = 0; int index = start - 1; int result = 0; while (kill &lt; total) &#123; for (int i = 0; i &lt; cycle; i++) &#123; while (!arr[index]) &#123; index = (index + 1) % total; &#125; if (i == cycle - 1) &#123; System.out.print(index + 1); arr[index] = false; kill++; &#125; if(kill==total-1) result = index+1; index = (index+1) % total; &#125; &#125; return result; &#125; //限定起点位置递归版public int showJoseph(int total, int cycle, int start) &#123; int result = (showJoseph(total, cycle) + (start-1) -1) % total + 1; return result; &#125; //限定起点+限定循环方向private static int showJoseph(int total, int cycle, int start, boolean forward) &#123; boolean[] arr = new boolean[total]; Arrays.fill(arr, true); int kill = 0; int index = start - 1; int result = 0; while (kill &lt; total) &#123; for (int i = 0; i &lt; cycle; i++) &#123; while (!arr[index]) &#123; if (forward) &#123; //正向走 index = (++index + total) % total; &#125; else &#123; //反向走 index = (--index + total) % total; &#125; &#125; if (i == cycle - 1) &#123; System.out.print(index + 1); arr[index] = false; kill++; &#125; if(kill==total-1) result = index+1; if (forward) &#123; index = (++index + total) % total; &#125; else &#123; index = (--index + total) % total; &#125; &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数和最小公倍数]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最大公约数和最小公倍数最大公约数123456789//欧几里德算法public long gcd(long m, long n) &#123; while(n!=0)&#123; long rem = m%n; m = n; n = rem; &#125; return m;&#125; 由于除法代价太大，所以接下来我们用减法来代替除法实现该算法，首先我们需要知道gcd(a,b)=gcd(b,a-b)，即数字A和数字B的最大公因数和数字B和数字(A-B)的最大公因数是相同的，所以我们可以得出以下的算法1234567public long gcd(long m, long n) &#123; if(m==n) return m; else&#123; return m-n&gt;0 ? gcd(n,m-n) : gcd(m,n-m); &#125;&#125; 然而存在一个问题就是减法会导致迭代次数较多，所以我们接下来想办法降低迭代次数，我们知道一个奇数和一个偶数的最大公约数其实等于这个奇数和这个(偶数/2)的最大公约数，所以程序进一步改进为：12345678910111213141516public long gcd(long m, long n) &#123; if(m==n) return m; //m,n均为奇数 else if(m&amp;1==1&amp;&amp;n&amp;1==1) return m-n&gt;0 ? gcd(n,m-n) : gcd(m,n-m); //m为偶数，n为奇数 else if(m&amp;1==0&amp;&amp;n&amp;1==1) return gcd(m&gt;&gt;1,n); //n为偶数，m为奇数 else if(m&amp;1==1&amp;&amp;n&amp;1==0) return gcd(m,n&gt;&gt;1); //m,n均为为偶数 else return 2*gcd(m&gt;&gt;1,n&gt;&gt;1);&#125; 最小公倍数123public long zxgbs(long m, long n) &#123; return m*n/gcd(m,n);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序一个O(n)时间复杂度的排序算法，我们知道基于比较的排序的下限是O(nlogn)。而计数排序只需线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。如果被排序序列是无重的，即意味着无需统计个数，那么我们可以使用位数组来实现该算法！123456789101112131415161718192021222324public void countSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int max = max(arr);//获取被排序序列中的最大值来开辟新数组 int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i&lt;arr.length; i++) &#123; count[arr[i]] ++; &#125; int k = 0; for(int i=0; i&lt;=max; i++) &#123; for(int j=0; j&lt;count[i]; j++) &#123; arr[k++] = i; &#125; &#125;&#125;public int max(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; if(ele &gt; max) max = ele; &#125; return max;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序 堆是具有下列性质的完全二叉树:每个节点的值都大于或等于其左右孩子节点的值,称为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值,称为小顶堆。 堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。 时间复杂度为 O(nlogn)！ 如何由一个无序序列键成一个堆？ 可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？ 怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。 123456789101112131415161718192021222324252627282930313233public void heapAdjust(int[] arr, int start, int end) &#123; int temp = arr[start]; for(int i=2*start+1; i&lt;=end; i*=2) &#123; //左右孩子的节点分别为2*i+1,2*i+2 //选择出左右孩子较小的下标 if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) &#123; i ++; &#125; if(temp &gt;= arr[i]) &#123; break; //已经为大顶堆，=保持稳定性。 &#125; arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 &#125; arr[start] = temp; //插入正确的位置&#125;public void heapSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; //建立大顶堆 for(int i=arr.length/2; i&gt;=0; i--) &#123; heapAdjust(arr, i, arr.length-1); &#125; for(int i=arr.length-1; i&gt;=0; i--) &#123; swap(arr, 0, i); heapAdjust(arr, 0, i-1); &#125;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序使用了递归分治的思想，其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。1234567891011121314151617181920212223242526272829303132public static void mergeSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int mid = (left&gt;&gt;1) + (right&gt;&gt;1); mergeSort(arr, left, mid); //递归排序左边 mergeSort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并&#125;//合并两个有序数组public static void merge(int[] arr, int left, int mid, int right) &#123; //左数组[left, mid] 右数组[mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= right) &#123; if(arr[i] &lt;= arr[j]) temp[k++] = arr[i++]; else temp[k++] = arr[j++]; &#125; while(i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; while(j &lt;= right) &#123; temp[k++] = arr[j++]; &#125; for(int p=0; p&lt;temp.length; p++) &#123; arr[left + p] = temp[p]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桶排序]]></title>
    <url>%2F2017%2F05%2F27%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[桶排序桶排序 (Bucket sort)或所谓的箱排序的原理是将数组分到有限数量的桶子里（即基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中），然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。 桶排序是稳定的 桶排序是常见排序里最快的一种,比快排还要快…大多数情况下 桶排序非常快,但是同时也非常耗空间,基本上是最耗空间的一种排序算法 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序 将各个桶中的数据有序的合并起来 桶排序分析：桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。 对N个关键字进行桶排序的时间复杂度分为两个部分： (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。 (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点： (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。 (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：O(N)+O(M(N/M)log(N/M))=O(N+N(logN-logM))=O(N+NlogN-N*logM)，当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。123456789101112131415161718192021222324252627282930public static void bucketSort(int[] arr) &#123; if(arr == null &amp;&amp; arr.length == 0) return ; int bucketNums = 10; //这里默认为10，规定待排数[0,100) List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //桶的索引 for(int i=0; i&lt;10; i++) &#123; buckets.add(new LinkedList&lt;Integer&gt;()); //用链表比较合适 &#125; //划分桶 for(int i=0; i&lt;arr.length; i++) &#123; buckets.get(fun(arr[i])).add(arr[i]); &#125; //对每个桶进行排序 for(int i=0; i&lt;buckets.size(); i++) &#123; if(!buckets.get(i).isEmpty()) &#123; Collections.sort(buckets.get(i)); //对每个桶进行快排 &#125; &#125; //还原排好序的数组 int k = 0; for(List&lt;Integer&gt; bucket : buckets) &#123; for(int ele : bucket) &#123; arr[k++] = ele; &#125; &#125;&#125;//映射函数public int fun(int x) &#123; return x / 10;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode_最大数]]></title>
    <url>%2F2017%2F05%2F22%2FLintCode-%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述 给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。(注意事项：最后的结果可能很大，所以我们返回一个字符串来代替这个整数。)样例：给出 [1, 20, 23, 4, 8]，返回组合最大的整数应为8423201。 思路拿到题目的第一反应就是比较大小嘛，但是继续往下想发现比较条件有点繁琐，同位数的直接比较大小即可，不同位数就比较麻烦了，需要一位一位进行比较…，然后突然间就想到了全排列，其实数据量比较小的时候是可以的，但是数据量大的情况就不行了，于是我卡在了数据样例[0,0,0,0,0,0,…,0,0,0]上，而且全然做了无用功，所以思路又回到了比较排序上，但是没想到什么好的比较方案，最终还是上网找了找资料，发现一个新思路，去比较两个数字组合后的大小，然后选择结果较大的组合，比如1和20，我们直接去比较120和201的大小，很明显201&gt; 120，所以1应该在20后面。这样一来比较就变得灰常容易，整个算法也瞬间简单明了起来！题解1234567891011121314151617181920212223242526public String largestNumber(int[] num) &#123; String[] A = new String[num.length]; int check = 0; for (int i=0;i&lt;num.length;i++) &#123; A[i] = String.valueOf(num[i]); check = Math.max(check,num[i]); &#125; if (check == 0) &#123; return "0"; &#125; Arrays.sort(A,new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;); StringBuilder s = new StringBuilder(); for (int i=0;i&lt;num.length;i++) &#123; s.append(String.valueOf(A[i])); &#125; return s.toString(); &#125; 收获一：以前只知道Arrays.sort(a[])这一种最简单的用法，今天又收获了两种更高级的用法，其中一种在本题中已用到，总结起来Arrays.sort()排序函数有以下几种用法 Arrays.sort(a[]) 排序a数组，且规则是从小到大，a可以是int,long,double,char,flaat,Object… Arrays.sort(a[], int fromIndex, int toIndex) 排序a数组的部分，从下标fromIndex到toIndex(不包括toIndex) Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) 排序a数组，按照比较器中的规则 12345class MyComparator implements Comparator&lt;Integer&gt;&#123; public int compare(Integer s1, Integer s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125; 二：匿名内部类，think in java中研究了好久，只是一直没怎么使用过，如今又看到了，却也感觉熟悉而陌生，所以再拿出来简单说道说道，看代码1234567Arrays.sort(A,new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;); 完整类为123456789101112public class Main &#123; public static void main(String[] args) &#123; String[] a = &#123;9, 8, 7, 2, 3, 4, 1, 0, 6, 5&#125;; Comparator cmp = new MyComparator(); Arrays.sort(a, cmp); &#125; &#125; class MyComparator implements Comparator&lt;String&gt;&#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序在实际应用当中确实是表现最好的排序算法。但其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面，同时也把大数沉到下面。举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针从尾部找比基准数小的，左指针从头部找比基准数大的，然后交换之。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。时间复杂度为O(nlogn)12345678910111213141516171819202122232425public int partition(int[] arr, int left, int right) &#123; int pivotKey = arr[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 &#125; arr[left] = pivotKey; //最后把pivot赋值到中间 return left;&#125;public void quickSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right);&#125;public void sort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O(n^3/2),要好于直接插入排序的O(n^2)1234567891011121314151617181920212223public void shellInsert(int[] arr, int d) &#123; for(int i=d; i&lt;arr.length; i++) &#123; int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&gt;=0&amp;&amp;arr[j]&gt;temp) &#123; //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 j -= d; &#125; if (j != i - d) //存在比其小的数 arr[j+d] = temp; &#125;&#125;public void shellSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &gt;= 1) &#123; shellInsert(arr, d); d&gt;&gt;1; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void radixSort(int[] arr) &#123; if(arr == null &amp;&amp; arr.length == 0) return ; int maxBit = getMaxBit(arr); for(int i=1; i&lt;=maxBit; i++) &#123; List&lt;List&lt;Integer&gt;&gt; buf = distribute(arr, i); //分配 collecte(arr, buf); //收集 &#125;&#125;//待分配数组public List&lt;List&lt;Integer&gt;&gt; distribute(int[] arr, int iBit) &#123; List&lt;List&lt;Integer&gt;&gt; buf = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int j=0; j&lt;10; j++) &#123; buf.add(new LinkedList&lt;Integer&gt;()); &#125; for(int i=0; i&lt;arr.length; i++) &#123; buf.get(getNBit(arr[i], iBit)).add(arr[i]); &#125; return buf;&#125;//把分配的数据收集到arr中public void collecte(int[] arr, List&lt;List&lt;Integer&gt;&gt; buf) &#123; int k = 0; for(List&lt;Integer&gt; bucket : buf) &#123; for(int ele : bucket) &#123; arr[k++] = ele; &#125; &#125;&#125;//获取最大位数public int getMaxBit(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; int len = (ele+"").length(); if(len &gt; max) max = len; &#125; return max;&#125;//获取x的第n位，如果没有则为0public int getNBit(int x, int n) &#123; String sx = x + ""; if(sx.length() &lt; n) return 0; else return sx.charAt(sx.length()-n) - '0';&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2017%2F05%2F13%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 基本思想:两两比较相邻记录的关键字,如果反序则交换 冒泡排序时间复杂度最好的情况为O(n),最坏的情况是O(n^2) 设置标志位，明显如果有一趟没有发生交换（flag = false)，说明排序已经完成 记录一轮下来标记的最后位置，下次从头部遍历到这个位置就Ok12345678910111213141516171819public void bubbleSort(int[] array)&#123; boolean flag = true; int n = array.length; while(flag)&#123; flag = false; for(int i = 0;i &lt; n-1;i++)&#123; if(array[i] &gt; array[i+1])&#123; //数据交换，将较大的数据换至数组后方 array[i] = array[i]^array[i+1]; array[i+1] = array[i]^array[i+1]; array[i] = array[i]^array[i+1]; //设置标记，当本次循环未发生交换动作时，排序完成 flag = true; &#125; &#125; //每次循环均有一位当前最大值换至正确的位置，故每下一次循环减少一次比较 n--; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直接插入排序]]></title>
    <url>%2F2017%2F05%2F13%2F%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[直接插入排序 将一个记录插入到已经排好序的有序表中, 从而得到一个新的,记录数增1的有序表 时间复杂度也为O(n^2), 比冒泡法和选择排序的性能要更好一些 123456789101112131415public void insertSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; for(int i=1; i&lt;arr.length; i++) &#123; //假设第一个数位置时正确的；要往后移，必须要假设第一个。 int j = i; int target = arr[i]; //待插入的 //后移 while(j&gt;0&amp;&amp;target&lt;arr[j-1]) &#123; arr[j] = arr[j-1]; j --; &#125; //插入 arr[j] = target; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2017%2F05%2F13%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序 通过n-i次关键字之间的比较,从n-i+1 个记录中选择关键字最小的记录,并和第i(1&lt;=i&lt;=n)个记录交换之 尽管与冒泡排序同为O(n^2),但简单选择排序的性能要略优于冒泡排序12345678910111213141516171819202122public static void selectSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int minIndex = 0; for(int i=0; i&lt;arr.length-1; i++) &#123; //只需要比较n-1次 minIndex = i; for(int j=i+1;j&lt;arr.length; j++) &#123; //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。 if(arr[j]&lt;arr[minIndex]) &#123; minIndex = j; &#125; &#125; if(minIndex != i) &#123; //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); &#125; &#125;&#125;public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理]]></title>
    <url>%2F2017%2F05%2F10%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[海量数据处理问题topK问题（10亿词中查找出现频率最高的10个） 单机+单核+足够大内存 10亿词（每个词占8B）中查找出现频率最高的10个 首先考虑全部放入内存，需要至少10^9*8=8GB 然后排序，顺序遍历找出结果或者用HashMap统计频率在求出结果 单机+多核（意味着可以多线程）+足够大内存 在内存中用hash将数据分为n个partition，交给n个线程处理，最后有一个线程负责将结果合并 上述有一个瓶颈问题，即（数据倾斜）线程处理速度不一致，所以快的线程必须等慢的线程，速度取决最慢的线程 解决办法，将数据分成c*n个partition（c&gt;1）,依然是n个线程，快的线程处理完后主动取下一个partition进行处理，直到数据全部处理完成，最后合并结果 单机+单核+受限内存 Hash（x）%M将源文件数据切割成M个小文件，然后用（单机+单核+足够大内存）方法处理，最后合并 多机+受限内存 数据分发到各个机器，每台机器用（单机+单核+受限内存）方法进行处理重复问题（电话号码去重求个数，即不同的电话号码有多少个，假设电话号码为8位） 位图法 8位能表示的十进制数最大为99999999，假设每个数字对应位图中的一位，大概需要内存99MB/8=7.375MB排序问题（9亿个不重复的9位整数数排序） 9亿个不重复的9位整数数排序，32位机器中整数占4B，所有数据全放入内存需0.9G*4B=3.6GB 1.利用数据库索引排序 2.分治法，将数据分断放入内存，最后合并（但是每次换入换出浪费时间） 3.位数组，声明一个可包含9位整数的bit数组，需内存大概9亿/8=120MB左右即可，数组内0、1表示是否含有此数，遍历出结果相关算法 1.hash算法 构造函数 冲突处理 2.位图法bit-map 快查，判重，判存 3.bloomfilter（位图+哈希） 判断元素是否属于集合 不属于（绝对正确） 属于（可能错误） m位的位数组+k个不同的hash（判定属于—k个哈希映射后，k位均为1，则可能存在于集合中，有位不为1，则元素肯定不在集合中） K=ln2*（m/n）n个元素，错误率最小 延伸：CBF（counter），SBF 4.倒排索引 单词指向包含他的文档（此单词在那些文档中出现过），例如论文的关键字搜索 5.trie树 利用公共前缀来减少时空消耗 6.堆 前n大/小 中位数（双堆）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵相关运算]]></title>
    <url>%2F2017%2F05%2F10%2F%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[矩阵相关运算矩阵加减法（等行等列）12345678910111213141516171819202122232425262728public int[][] add(int[][] a,int[][] b)&#123; //获取二维数组的行数 int row = a.length; //获取二维数组的列数 int column = a[row-1].length; int[][] c = new int[row][column]; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;column;j++) &#123; c[i][j]=a[i][j]+b[i][j]; &#125; &#125; return c;&#125;public int[][] sub(int[][] a,int[][] b)&#123; int row = a.length; int column = a[row-1].length; int[][] c = new int[row][column]; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;column;j++) &#123; c[i][j]=a[i][j]-b[i][j]; &#125; &#125; return c;&#125; 矩阵相乘（A[m][n]*B[n][k]=C[m][k]）1234567891011121314151617181920public int[][] add(int[][] a,int[][] b)&#123; //获取二维数组a的行数作为c的行数 int row = a.length; //获取二维数组a的列数 int n = a[row-1].length; 获取二维数组b的列数作为c的列数 int column = b[n-1].length; int[][] c = new int[row][column]; Arrays.fill(c,0); for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;column;j++) &#123; for(int k=0;k&lt;n;k++)&#123; c[i][j]+=a[i][k]*b[k][j] &#125; &#125; &#125; return c;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用查找算法]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常用查找算法顺序查找 无序或有序队列,按顺序比较每个元素，直到找到关键字为止。 时间复杂度：O(n)123456789101112131415161718192021222324252627282930313233343536373839//用链表来实现，动态的插入和删除便于维护序列的有序性public class SequentialSearchST&lt;Key,Value&gt; &#123; private Node head; private int size=0; //插入时间复杂度为O(n) public void put(Key key,Value v)&#123; Node p=head; while(p!=null)&#123; if(p.key.equals(key))&#123; p.v=v; return; &#125; p=p.next; &#125; head=new Node(key,v,head); size++; &#125; //查找时间复杂度为O(n) public Value get(Key key)&#123; Node p=head; while (p!=null)&#123; if(p.key.equals(key))&#123; return p.v; &#125; p=p.next; &#125; return null; &#125; //删除时间复杂度为O(n) public void delete(Key key)&#123; Node p=head; while (p!=null)&#123; if(p.key.equals(key))&#123; p.v = p.next.v; p.next = p.next.next; &#125; &#125; &#125;&#125; 二分查找（折半查找） 条件：有序数组 原理： 查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束； 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中重复步骤1。 如果在某一步骤数组为空，则代表找不到。 时间复杂度：O(logn)1234567891011121314public int binarySearach(int[] array,int key)&#123; int low = 0; int high = array.length-1; while(low &lt;= high)&#123; int middle = (low + high) &gt;&gt; 1; if(key &lt; array[middle]) high = middle-1; else if(key &gt; array[middle]) low = middle+1; else return array[middle]; &#125; return -1;//没找到目标值返回-1&#125; 插值查找 插值查找，基于折半查找的优化变种。由于折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。所以插值查找克服了折半查找的傻瓜式，采用自适应查找点，从而让每次所选择的查找点更加接近被查找值，以加快查找速度。 二分查找中查找点计算如下：mid=(low+high)/2, 即mid=low+1/2*(high-low); 插值查找中查找点计算如下：mid=low+(key-a[low])/(a[high]-a[low])*(high-low) 123456789101112131415161718public int insertKeySearch(int [] a, int key)&#123; int low, high, mid; low = 0; high = a.length-1; while(low &lt;= high)&#123; /* 插值查找的计算公式 */ mid = low + (high - low)*(key - a[low])/(a[high] - a[low]); if (key &lt; a[mid])&#123; high = mid - 1; &#125; else if (key &gt; a[mid])&#123; low = mid + 1; &#125; else return mid; &#125; return 0;&#125; 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。斐波那契查找 在介绍斐波那契查找算法之前，先介绍一下很它紧密相连的一个概念——黄金分割。黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。 斐波那契查找也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为Fn，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况： key值与第mid=（low+high）/2相等，mid位置的元素即为所求； key值大于第mid=（low+high）/2，则令 low=mid+1； key值小于第mid=（low+high）/2，则令high=mid-1。斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1；开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1)，比较结果也分为三种： key值与第mid=low+F(k-1)-1相等，则mid位置的元素即为所求； key值大于第mid=low+F(k-1)-1，则low=mid+1，k-=2；说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))=Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。 key值小于第mid=low+F(k-1)-1，则high=mid-1，k-=1。说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归的应用斐波那契查找。 上代码我们来实际操作一番123456789101112131415161718192021222324252627public int FibonacciSearch(int [] a, int key)&#123; int [] F = &#123;0,1,1,2,3,5,8,13,21,34&#125;;//构造一个斐波那契数列 int low, high, mid, k; low = 1; high = a.length-1; k = 0; while (n &gt; F[k]-1) /* 计算n位于斐波那契数列的位置 */ k++; while (low &lt;= high) &#123; mid = low + F[k-1] -1; if (key &lt; a[mid])&#123; high = mid - 1; k -= 1; &#125; else if (key &gt; a[mid])&#123; low = mid + 1; k -= 2; &#125; else &#123; if (mid &lt;= n) return mid; else return n; &#125; &#125; return 0;&#125; 在最坏情况下，斐波那契查找的时间复杂度还是O(log2n)，且其期望复杂度也为O(log2n)，但是与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。二叉排序树查找特性： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。在二叉查找树b中查找x的过程为： 若b是空树，则搜索失败，否则： 若x等于b的根节点的数据域之值，则查找成功；否则： 若x小于b的根节点的数据域之值，则搜索左子树；否则： 查找右子树。时间复杂度：O(log_2(n)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//查找public TreeNode BSTSearach(TreeNode root, Value value) &#123; if(root==null) return null; if(root.value==value) return root; else return root.value&lt;value ? BSTSearach(roo.right,value) : BSTSearach(root.left,value);&#125;//插入节点public void insertNode(TreeNode root,TreeNode node) &#123; if (root == NULL) root = node; else if (root.val &gt; node.val) insertNode(root.left,node); else if(root.val &lt; node.val) insertNode(root.right,node); else return;&#125; //删除二叉查找树的节点public TreeNode removeNode(TreeNode root, int value) &#123; if (root == null)&#123; return null; &#125; if (root.val == value)&#123;//当前节点值等于value值 if (root.left == null &amp;&amp; root.right == null)&#123;//当前节点没有左右孩子节点 root = null; &#125; else if (root.left == null)&#123;//当前节点只有右孩子节点 root = root.right; &#125; else if (root.right == null)&#123;//当前节点只有左孩子节点 root = root.left; &#125; else &#123;//当前节点有左右孩子节点 TreeNode tmp = root; tmp = tmp.left; while(tmp.right != null)&#123; tmp = tmp.right; &#125; root.val = tmp.val; root.left = removeNode(root.left,root.val); &#125; &#125; else if (value &lt; root.val)&#123;//当前节点值大于value if (root.left == null)&#123; return root; &#125; root.left = removeNode(root.left, value); &#125; else &#123;//当前节点值小于value if (root.right == null)&#123; return root; &#125; root.right = removeNode(root.right,value); &#125; return root;&#125; 哈希表法（散列表） 先创建哈希表（散列表） 根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。 时间复杂度：几乎是O(1)，取决于产生冲突的多少。123456789101112131415161718192021222324public int searchHash(int[] hash, int hashLength, int key) &#123; // 哈希函数 int hashAddress = key % hashLength; // 指定hashAdrress对应值存在但不是关键值，则用开放寻址法解决 while (hash[hashAddress] != 0 &amp;&amp; hash[hashAddress] != key) &#123; hashAddress = (++hashAddress) % hashLength; &#125; // 查找到了开放单元，表示查找失败 if (hash[hashAddress] == 0) return -1; return hashAddress; &#125; //数据插入Hash表 public void insertHash(int[] hash, int hashLength, int data) &#123; // 哈希函数 int hashAddress = data % hashLength; // 如果key存在，则说明已经被别人占用，此时必须解决冲突 while (hash[hashAddress] != 0) &#123; // 用开放寻址法找到 hashAddress = (++hashAddress) % hashLength; &#125; // 将data存入字典中 hash[hashAddress] = data; &#125; 分块查找 将n个数据元素”按块有序”划分为m块（m ≤ n）。 每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 然后使用二分查找确定数据所处在哪一块后用顺序查找key。123456789101112131415161718public int blockSearch(int[] index, int[] st, int key, int m) &#123; // 在序列st数组中，用分块查找方法查找关键字为key的记录 // 1.在index[ ] 中折半查找，确定要查找的key属于哪个块中 int i = binarySearch(index, key); if (i &gt;= 0) &#123; int j = i &gt; 0 ? i * m : i; int len = (i + 1) * m; // 在确定的块中用顺序查找方法查找key for (int k = j; k &lt; len; k++) &#123; if (key == st[k]) &#123; System.out.println("查询成功"); return k; &#125; &#125; &#125; System.out.println("查找失败"); return -1; &#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2017%2F05%2F06%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找非递归版public int binarySearch(int[] array,int key){ int low = 0; int high = array.length-1; while(low &lt;= high){ int middle = (low + high) &gt;&gt; 1; if(key &lt; array[middle]) high = middle-1; else if(key &gt; array[middle]) low = middle+1; else return array[middle]; } return -1;//没找到目标值返回-1 } 递归版public int binarySearch(int[] array,int key,int low,int high){ if(low &gt;= high) return -1; else{ int middle = (low + high) &gt;&gt; 1; if(key &lt; array[middle]) binarySearach(array,key,low,middle-1); else if(key &gt; array[middle]) binarySearach(array,key,middle-1,high); else return array[middle]; } }]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初心]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%88%9D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[引言 2017-04-29是我阳历的生日，同时也是我第一个博客的诞辰！初心是为了能有一个可以记录自己在代码中的成长过程的空间，同时也希望能够发挥自己的一些微不足道的能力去帮助一些人，在此过程中不断提高自己。——————一只奋进的小菜鸟 随笔 起因其实可以追溯到一篇微博，内容讲述了为什么程序员要写博客，作者文笔着实不错，让我看着动了心，回想起从前码代码的日子，经历过好多的坑，走过好多的弯路，一直想可以把自己心得或者当时的想法，做法记录下来，以后可以回头看看自己当初犯过那些错，走过那些弯路，警醒一下自己，同时也可以提醒同在路上的人不要重蹈我的覆辙，为他人尽自己的一丝绵薄之力。 本人小小一程序员菜鸟，无意间对编程产生了浓厚的兴趣，遂开始了码代码的日子，由于起步较晚，基础也薄弱，希望以后的日子有幸能看我文章的小伙伴不要吝啬你们的口水，为我提出宝贵的意见，更希望各位大牛心情愉悦之际能指点一二，同路的菜鸟我们相互交流，共同学习，一起奋进！]]></content>
      <categories>
        <category>初心</category>
      </categories>
      <tags>
        <tag>初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>