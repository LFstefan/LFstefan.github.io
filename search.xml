<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java架构学习心得(一)]]></title>
    <url>%2F2017%2F07%2F06%2FJava%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[序言 软件开发从最初的pc单机的人机交互模式到后来局域网的出现开启了软件开发的c/s模式（客户端/服务器模式），在到现在的b/s模式（浏览器/服务器），其实都面临的着相同的问题——代码的冗余，相似代码的大量重复导致整体代码量的庞大，所以为了减少代码的冗余，避免上述情况的产生，框架应用而生！而框架的原理其实主要就只有两部分，流程的抽象和数据类型的抽象，下面我们一一道来！（此文章适合于学过jsp及j2EE的童鞋） 正文首先我们来说流程控制，b/s模式均由浏览器向服务器发出请求，然后服务器响应相关请求并回传结果给浏览器，这是个一成不变的通用过程，所以我要做的就是抽象这个过程，类似于Struts2，把请求和响应的控制流程抽象到框架中去，让框架去拦截掉你的所有请求，然后经过处理后在传递给服务器，服务器的相响应结果同样被框架截获，然后处理后再扔给浏览器去显示，以上是大概流程，下面我们用程序代码详细道来！1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;FlowControl&gt; &lt;Action name="login"&gt; &lt;OperatePoint name="login_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;OperatePoint name="login_check"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;OperatePoint name="login_init"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;Action name="register"&gt; &lt;OperatePoint name="register_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;Action name="xxx"&gt; &lt;OperatePoint name="xxx_execute"&gt; &lt;Result name="success"&gt;success.jsp&lt;/Result&gt; &lt;Result name="error"&gt;error.jsp&lt;/Result&gt; &lt;/OperatePoint&gt; &lt;/Action&gt; &lt;/FlowControl&gt; 上面的xml配置文件类似于Struts2的struts.xml，用于表明整个项目中所有的请求与对应请求的响应，Action为我自己定义的用于处理相关的请求动作类，OperatePoint为动作类中不同的方法，用于减少过多动作类，将一组相关的动作处理放入到同一个类中，用不同的方法去处理，减少代码的冗余。123456789101112131415161718192021222324252627282930313233343536&lt;filter&gt; &lt;filter-name&gt;FrameFilter&lt;/filter-name&gt; &lt;filter-class&gt;edu.frame.web.core.FrameFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;ExcludedPages&lt;/param-name&gt; &lt;param-value&gt;/authImage,/register&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DataBaseName&lt;/param-name&gt; &lt;param-value&gt;MySql&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DBConfigFile&lt;/param-name&gt; &lt;param-value&gt;DBConfig.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;FlowControlConfigFile&lt;/param-name&gt; &lt;param-value&gt;flowcontrol.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;AppBasePath&lt;/param-name&gt; &lt;param-value&gt;edu.demo.web.flowcontrol&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ConfigPath&lt;/param-name&gt; &lt;param-value&gt;config&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;JspPath&lt;/param-name&gt; &lt;param-value&gt;jsp&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FrameFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 上述代码段来自web.xml，我们用一个名叫FrameFilter的filter来拦截浏览器发送的所有的请求然后判定请求的类别，如果是jsp页面，我们不做处理直接扔给服务器，如果是action类请求，我们获取路径分解出类名和方法名，利用Java反射机制实例化相应的的动作类执行相应的方法，然后返回结果字符串result，在根据结果result找到流程控制配置文件中对应的jsp页面扔给服务器。init-param部分为初始化参数，包括ExcludedPages（请求过滤页面），DataBaseName（选用数据库名称，我们将数据库的统一操作也封装在框架内，应用层通过配置文件来进行数据库的选择和连接），DBConfigFile（数据库配置文件）FlowControlConfigFile（流程控制文件），AppBasePath（action动作类目录），ConfigPath（配置文件地址），JspPath（页面地址）。因此FrameFilter.java为本框架中最核心的部分，下面我们来看一下此文件的具体内容123456789101112131415161718public class FrameFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)&#123;&#125; //前处理，字符的乱码，数据库和流程控制配置文件的解析与实例化封装 public void perpare(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //初始化过滤器，加载web.xml文件中参数 public void init(FilterConfig config) throws ServletException &#123;&#125; //获取物理路径 private String getRealPath(FilterConfig config, String name)&#123;&#125; //请求匹配，判定是action还是jsp页面 public String actionMapping(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //action执行前的准备，action动作类名及方法的提取分离 public void prepareExecute(HttpServletRequest request, HttpServletResponse response,String functionName)&#123;&#125; //根据传来的动作类名和方法名去相应的action中执行相应的方法，返回result public String executeAction(HttpServletRequest request, HttpServletResponse response)&#123;&#125; //根据action类返回的result跳转到相应的jsp页面 public void dispatcher(HttpServletRequest request, HttpServletResponse response,String result)&#123;&#125;&#125; 上述即为流程控制的核心部分，涉及到的细节有xml配置文件的解析（需引入dom4j或者其他的xml解析jar包，例如数据库配置文件和流程控制文件的解析均需要用到），还有就是java的反射机制，已知类名和方法名的字符串实现类的实例化，及方法的执行。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Struts</tag>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode_最大数]]></title>
    <url>%2F2017%2F05%2F22%2FLintCode-%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述 给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。(注意事项：最后的结果可能很大，所以我们返回一个字符串来代替这个整数。)样例：给出 [1, 20, 23, 4, 8]，返回组合最大的整数应为8423201。 思路拿到题目的第一反应就是比较大小嘛，但是继续往下想发现比较条件有点繁琐，同位数的直接比较大小即可，不同位数就比较麻烦了，需要一位一位进行比较…，然后突然间就想到了全排列，其实数据量比较小的时候是可以的，但是数据量大的情况就不行了，于是我卡在了数据样例[0,0,0,0,0,0,…,0,0,0]上，而且全然做了无用功，所以思路又回到了比较排序上，但是没想到什么好的比较方案，最终还是上网找了找资料，发现一个新思路，去比较两个数字组合后的大小，然后选择结果较大的组合，比如1和20，我们直接去比较120和201的大小，很明显201&gt; 120，所以1应该在20后面。这样一来比较就变得灰常容易，整个算法也瞬间简单明了起来！题解1234567891011121314151617181920212223242526public String largestNumber(int[] num) &#123; String[] A = new String[num.length]; int check = 0; for (int i=0;i&lt;num.length;i++) &#123; A[i] = String.valueOf(num[i]); check = Math.max(check,num[i]); &#125; if (check == 0) &#123; return "0"; &#125; Arrays.sort(A,new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;); StringBuilder s = new StringBuilder(); for (int i=0;i&lt;num.length;i++) &#123; s.append(String.valueOf(A[i])); &#125; return s.toString(); &#125; 收获一：以前只知道Arrays.sort(a[])这一种最简单的用法，今天又收获了两种更高级的用法，其中一种在本题中已用到，总结起来Arrays.sort()排序函数有以下几种用法 Arrays.sort(a[]) 排序a数组，且规则是从小到大，a可以是int,long,double,char,flaat,Object… Arrays.sort(a[], int fromIndex, int toIndex) 排序a数组的部分，从下标fromIndex到toIndex(不包括toIndex) Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) 排序a数组，按照比较器中的规则 12345class MyComparator implements Comparator&lt;Integer&gt;&#123; public int compare(Integer s1, Integer s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125; 二：匿名内部类，think in java中研究了好久，只是一直没怎么使用过，如今又看到了，却也感觉熟悉而陌生，所以再拿出来简单说道说道，看代码1234567Arrays.sort(A,new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;); 完整类为123456789101112public class Main &#123; public static void main(String[] args) &#123; String[] a = &#123;9, 8, 7, 2, 3, 4, 1, 0, 6, 5&#125;; Comparator cmp = new MyComparator(); Arrays.sort(a, cmp); &#125; &#125; class MyComparator implements Comparator&lt;String&gt;&#123; public int compare(String s1, String s2) &#123; return (s2+s1).compareTo(s1+s2); &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重温JavaEE_SSH框架]]></title>
    <url>%2F2017%2F05%2F10%2F%E9%87%8D%E6%B8%A9JavaEE-SSH%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[知识只有当需要书写下来或者讲解出来的时候才显得如此匮乏——菜鸟飞 struts2 hibernate spring ssh整合及项目实例 Struts2 Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。——百度百科 在我看来，struts本质就类似于一个filter，所以在使用前需要在项目lib目录中导入相应的jar包并在项目的web.xml文件中配置如下内容12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置完成后，所有的页面请求便会被截获到struts.xml的配置文件中，如下图所示，Struts2框架中核心组件就是Action、拦截器等，Struts2框架使用包来管理Action和拦截器等。每个包就是多个Action、多个拦截器、多个拦截器引用的集合。在struts.xml文件中package元素用于定义包配置，每个package元素定义了一个包配置。它的常用属性有： name：必填属性，用来指定包的名字。 extends：可选属性，用来指定该包继承其他包。继承其它包，可以继承其它包中的Action定义、拦截器定义等。 namespace：可选属性，用来指定该包的命名空间。(考虑到同一个Web应用中需要同名的Action，Struts2以命名空间的方式来管理Action，同一个命名空间不能有同名的Action。Struts2通过为包指定namespace属性来为包下面的所有Action指定共同的命名空间。) 其中action标签中的name属性表示与你所截获的请求名称进行匹配(也就是说将来你项目的所有页面请求在这里都会有所记录，可以清晰地体现你项目的页面跳转逻辑，同时也极大的方便了以后的更改操作)struts.xml12345678&lt;struts&gt; &lt;package name="default" extends="struts-default"&gt; &lt;action name="index" class="com.action.IndexAction"&gt; &lt;result name="success"&gt;index.jsp&lt;/result&gt; &lt;result name="error"&gt;error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 对应的action标签中的class属性表示该请求所对应的Action处理类，因为Struts2中的Action采用了低侵入式的设计，所以Struts2不要求Action类继承任何的Struts2的基类或实现Struts2接口。但是，我们为了方便实现Action，大多数情况下都会继承com.opensymphony.xwork2.ActionSupport类，并重写此类里的public String execute() throws Exception方法(Action处理类默认执行方法)。（因为此类中实现了很多的实用接口，提供了很多默认方法，这些默认方法包括获取国际化信息的方法、数据校验的方法、默认的处理用户请求的方法等，这样可以大大的简化Action的开发。)，Action处理类的所有方法最后都会返回一个字符串，如SUCCESS给struts.xml，而action标签内的result标签中的name属性负责匹配传回的字符串，从而跳转至不同的页面123456789101112public class IndexAction extends ActionSupport&#123; public String execute()throws Exception&#123; try &#123; &#125; return SUCCESS; &#125; catch (Exception e) &#123; e.printStackTrace(); return ERROR; &#125; &#125; public String ownMethod()throws Exception&#123;&#125;&#125; 当然你也可以去书写并执行自己的方法，这时你只需要在处理类中加入自己的ownMethod()方法，并在struts.xml文件中的对应的action标签中做如下修改即可1&lt;action name="index" class="com.action.IndexAction!ownMethod"&gt; 以下内容为struts.xml配置详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;struts&gt; &lt;!-- include节点是struts2中组件化的方式 可以将每个功能模块独立到一个xml配置文件中 然后用include节点引用 --&gt; &lt;include file="struts-default.xml"&gt;&lt;/include&gt; &lt;!-- 所有匹配*.action的请求都由struts2处理 --&gt; &lt;constant name="struts.action.extension" value="action" /&gt; &lt;!-- 是否启用开发模式 --&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!-- struts配置文件改动后，是否重新加载 --&gt; &lt;constant name="struts.configuration.xml.reload" value="true" /&gt; &lt;!-- 设置浏览器是否缓存静态内容 --&gt; &lt;constant name="struts.serve.static.browserCache" value="false" /&gt; &lt;!-- 请求参数的编码方式 --&gt; &lt;constant name="struts.i18n.encoding" value="utf-8" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件，有助于开发 --&gt; &lt;constant name="struts.i18n.reload" value="true" /&gt; &lt;!-- 文件上传最大值 --&gt; &lt;constant name="struts.multipart.maxSize" value="104857600" /&gt; &lt;!-- 让struts2支持动态方法调用 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; &lt;!-- Action名称中是否还是用斜线 --&gt; &lt;constant name="struts.enable.SlashesInActionNames" value="false" /&gt; &lt;!-- 允许标签中使用表达式语法 --&gt; &lt;constant name="struts.tag.altSyntax" value="true" /&gt; &lt;!-- 对于WebLogic,Orion,OC4J此属性应该设置成true --&gt; &lt;constant name="struts.dispatcher.parametersWorkaround" value="false" /&gt; &lt;package name="basePackage" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!-- 定义拦截器 name:拦截器名称 class:拦截器类路径 --&gt; &lt;interceptor name="timer" class="com.kay.timer"&gt;&lt;/interceptor&gt; &lt;interceptor name="logger" class="com.kay.logger"&gt;&lt;/interceptor&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name="mystack"&gt; &lt;interceptor-ref name="timer"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="logger"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 定义默认的拦截器 每个Action都会自动引用 如果Action中引用了其它的拦截器 默认的拦截器将无效 --&gt; &lt;default-interceptor-ref name="mystack"&gt;&lt;/default-interceptor-ref&gt; &lt;!-- 全局results配置 --&gt; &lt;global-results&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="" class=""&gt; &lt;!-- 引用拦截器 name:拦截器名称或拦截器栈名称 --&gt; &lt;interceptor-ref name="timer"&gt;&lt;/interceptor-ref&gt; &lt;!-- 节点配置 name : result名称 和Action中返回的值相同 type : result类型 不写则选用superpackage的type struts-default.xml中的默认为dispatcher --&gt; &lt;result name="success" type="dispatcher"&gt;/talk.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 允许一个Action内包含多个请求处理方法：动态方法调用是指：表单元素的action不直接等于某个Action的名字，而是以感叹号后加方法名来指定对应的动作名：要使用动态方法调用，必须设置Struts2允许动态方法调用，通过设置struts.enable.DynamicMethodInvocation常量来完成，该常量属性的默认值是true。1234567&lt;struts&gt; &lt;!-- //禁用动态方法调用，默认为true启用，false禁用 constant:name="struts.enable.DynamicMethodInvocation" --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt;&lt;/struts&gt; 默认Action： 在浏览器输入一个不存在的Action，页面将呈现404错误，为了网站更友好，我们可以设置一个默认的Action。1234&lt;default-action-ref name="defaultAction"&gt;&lt;/default-action-ref&gt; &lt;action name="defaultAction"&gt; &lt;result&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; 处理结果类型： Struts2提供了对不同种类返回结果的支持，常见的有JSP，FreeMarker，Velocity等。 Struts2支持的不同类型的返回结果为：(加粗为常用) 名字 说明 chain 用来处理Action链 dispatcher 用来转向页面，通常处理JSP，这是默认的结果类型 freeMarker 处理FreeMarker模板 httpHeader 用来控制特殊的Http行为 redirect 重定向到一个URL redirect-action 重定向到一个Action stream 向浏览器发送InputSream对象，通常用来处理文件下载 velocity 处理Velocity模板 xslt 处理XML/XLST模板 plaintext 显示原始文件内容，例如文件源代码 tiles 结合Tile使用strutsUI页面标签库的引用需在jsp页面加入以下内容（详细介绍链接）1&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt; Hibernate Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。——百度百科 Hibernate的API一共有6个，分别为:Session、SessionFactory、Transaction、Query、Criteria和Configuration。通过这些接口，可以对持久化对象进行存取、事务控制。 SessionSession接口负责执行被持久化对象的CRUD操作(CRUD的任务是完成与数据库的交流，包含了很多常见的SQL语句)。但需要注意的是Session对象是非线程安全的。同时，Hibernate的session不同于JSP应用中的HttpSession。这里当使用session这个术语时，其实指的是Hibernate中的session，而以后会将HttpSession对象称为用户session。 SessionFactorySessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。 TransactionTransaction 接口是一个可选的API，可以选择不使用这个接口，取而代之的是Hibernate 的设计者自己写的底层事务处理代码。 Transaction 接口是对实际事务实现的一个抽象，这些实现包括JDBC的事务、JTA 中的UserTransaction、甚至可以是CORBA 事务。之所以这样设计是能让开发者能够使用一个统一事务的操作界面，使得自己的项目可以在不同的环境和容器之间方便地移植。 QueryQuery接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。Query经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。 CriteriaCriteria接口与Query接口非常类似，允许创建并执行面向对象的标准化查询。值得注意的是Criteria接口也是轻量级的，它不能在Session之外使用。 ConfigurationConfiguration 类的作用是对Hibernate 进行配置，以及对它进行启动。在Hibernate 的启动过程中，Configuration 类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象。虽然Configuration 类在整个Hibernate 项目中只扮演着一个很小的角色，但它是启动hibernate 时所遇到的第一个对象。 Hibernate.xml配置 Hibernate.show_sql：是否在运行时候sql语句输出到控制台，编码阶段便于测试的。（默认设置为true） Hibernate.format_sql：输出在控制台sql语句是否进行排版，便于阅读。（默认设置为true） Hbm2ddl.auto：可帮助由Java代码生成数据库脚本，进而生成具体表结构。如：create/update/create-drop/validate。 hbm2ddl.auto: 生成表结构的策略配置update(最常用的取值): 如果当前数据库中不存在表结构,那么自动创建表结构.如果存在表结构,并且表结构与实体一致,那么不做修改如果存在表结构,并且表结构与实体不一致,那么会修改表结构.会保留原有列.create(很少):无论是否存在表结构.每次启动Hibernate都会重新创建表结构.(数据会丢失)create-drop(极少): 无论是否存在表结构.每次启动Hibernate都会重新创建表结构.每次Hibernate运行结束时,删除表结构.validate(很少):不会自动创建表结构.也不会自动维护表结构.Hibernate只校验表结构. 如果表结构不一致将会抛出异常.12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC"-//Hibernate/Hibernate Configuration DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- property 元素用于配置Hibernate中的属性键:值 --&gt; &lt;!-- hibernate.connection.driver_class : 连接数据库的驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- hibernate.connection.username : 连接数据库的用户名 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!-- hibernate.connection.password : 连接数据库的密码 --&gt; &lt;property name="hibernate.connection.password"&gt;123&lt;/property&gt; &lt;!-- hibernate.connection.url : 连接数据库的地址,路径 --&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hibernatedemｏ&lt;/property&gt; &lt;!-- show_sql: 操作数据库时,会 向控制台打印sql语句 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- format_sql: 打印sql语句前,会将sql语句先格式化 --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 数据库方言配置org.hibernate.dialect.MySQLDialect (选择最短的)--&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- hibernate.connection.autocommit: 事务自动提交 --&gt; &lt;property name="hibernate.connection.autocommit"&gt;true&lt;/property&gt; &lt;!-- 将Session与线程绑定=&gt; 只有配置了该配置,才能使用getCurrentSession --&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 引入ORM 映射文件 填写src之后的路径--&gt; &lt;mapping resource="com/itheima/a_hello/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; XXXX.hbm.xml(ecplise可自动生成)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;!-- &lt;hibernate-mapping&gt;一般不去配置，采用默认即可。 default-cascade="none"：默认的级联风格，表与表联动。 default-lazy="true"：默认延迟加载 --&gt; &lt;hibernate-mapping&gt; &lt;!-- &lt;class&gt;：使用class元素定义一个持久化类。 name="cn.javass.user.vo.UserModel"：持久化类的java全限定名； table="tbl_user"：对应数据库表名； mutable="true"：默认为true，设置为false时则不可以被应用程序更新或删除； dynamic-insert="false"：默认为false，动态修改那些有改变过的字段，而不用修改所有字段； dynamic-update="false"：默认为false，动态插入非空值字段； select-before-update="false"：默认为false，在修改之前先做一次查询，与用户的值进行对比，有变化都会真正更新； optimistic-lock="version"：默认为version(检查version/timestamp字段)，取值：all(检查全部字段)、dirty(只检查修改过的字段)、 none(不使用乐观锁定)，此参数主要用来处理并发，每条值都有固定且唯一的版本，版本为最新时才能执行操作； --&gt; &lt;class name="cn.javass.user.vo.UserModel" table="tbl_user" dynamic-insert="true" dynamic-update="true" optimistic-lock="version"&gt; &lt;!-- &lt;id&gt;：定义了该属性到数据库表主键字段的映射。 name="userId"：标识属性的名字； column="userId"：表主键字段的名字，如果不填写与name一样； --&gt; &lt;id name="userId"&gt; &lt;!-- &lt;generator&gt;：指定主键由什么生成，推荐使用uuid（随机生成唯一通用的表示符，实体类的ID必须是String）， native（让数据库自动选择用什么生成（根据底层数据库的能力选择identity，sequence或hilo中的一种））， assigned（指用户手工填入，默认）。 --&gt; &lt;generator class="uuid"/&gt; &lt;/id&gt; &lt;!-- &lt;version/&gt;：使用版本控制来处理并发，要开启optimistic-lock="version"和dynamic-update="true"。 name="version"：持久化类的属性名，column="version"：指定持有版本号的字段名； --&gt; &lt;version name="version" column="version"/&gt; &lt;!-- &lt;property&gt;：为类定义一个持久化的javaBean风格的属性。 name="name"：标识属性的名字，以小写字母开头； column="name"：表主键字段的名字，如果不填写与name一样； update="true"/insert="true"：默认为true，表示可以被更新或插入； --&gt; &lt;property name="name" column="name" /&gt; &lt;property name="sex" column="sex"/&gt; &lt;property name="age" column="age"/&gt; &lt;!-- 组件映射：把多个属性打包在一起当一个属性使用，用来把类的粒度变小。 &lt;component name="属性，这里指对象"&gt; &lt;property name="name1"&gt;&lt;/property&gt; &lt;property name="name2"&gt;&lt;/property&gt; &lt;/component&gt; --&gt; &lt;!-- &lt;join&gt;:一个对象映射多个表，该元素必须放在所有&lt;property&gt;之后。 &lt;join table="tbl_test：子表名"&gt; &lt;key column="uuid：子表主键"&gt;&lt;/key&gt; &lt;property name="name1：对象属性" column="name：子表字段"&gt;&lt;/property&gt; &lt;/join&gt; --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 实例 post.hbm.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.form.Post" table="post"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="id"/&gt; &lt;generator class="identity"/&gt; &lt;/id&gt; &lt;many-to-one name="admin" class="com.form.Admin" fetch="select" lazy="false"&gt; &lt;column name="aid"/&gt; &lt;/many-to-one&gt; &lt;many-to-one name="user" class="com.form.User" fetch="select" lazy="false"&gt; &lt;column name="uid"/&gt; &lt;/many-to-one&gt; &lt;many-to-one name="board" class="com.form.Board" fetch="select" lazy="false"&gt; &lt;column name="bid"/&gt; &lt;/many-to-one&gt; &lt;property name="name" type="string"&gt; &lt;column name="name"/&gt; &lt;/property&gt; &lt;property name="content" type="string"&gt; &lt;column name="content"/&gt; &lt;/property&gt; &lt;property name="publishTime" type="timestamp"&gt; &lt;column name="publishTime"/&gt; &lt;/property&gt; &lt;property name="count" type="java.lang.Integer"&gt; &lt;column name="count"/&gt; &lt;/property&gt; &lt;property name="photoPath" type="string"&gt; &lt;column name="photoPath"/&gt; &lt;/property&gt; &lt;set name="replies" inverse="true" cascade="all-delete-orphan" lazy="false" order-by="publishTime desc"&gt; &lt;key&gt; &lt;column name="pid" not-null="true"/&gt; &lt;/key&gt; &lt;one-to-many class="com.form.Reply"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;``` ### 说说为什么使用lazy```xml&lt;set name="replies" inverse="true" cascade="all-delete-orphan" lazy="true"&gt; 当使用Hibernate中的one-to-many、many-to one、many-to-many关系映射的时候，一个对象中会包含一个或多个Set来关联其他的对象。例如：user-groups，当程序取user 对象时，如果一个用户有多个自定义组，那么程序将把组的信息也读取出来，在log中可以看到两个sql的输出。但是在页面的显示上，也许并不需要显示这个用户相关组的信息，这样系统的消耗就白白浪费了，于是hibernate提供了lazy（延迟加载）的方法来避免这一情况的发生，我们只需要在 user.hbm.xml中设置lazy=true，就能实现延迟加载。 Spring 是一个非常强大的反转控制(IOC)框架，以帮助分离项目组件之间的依赖关系 控制反转——Spring通过一种称作控制反转（IoC）的技术促进了低耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。 web.xml配置123456789101112131415161718192021&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;filter&gt;&lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.orm.hibernate4.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;init-param&gt; &lt;param-name&gt;org.springframework.orm.hibernate4.LocalSessionFactoryBean&lt;/param-name&gt; &lt;param-value&gt;sessionFactory&lt;/param-value&gt;&lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 说说为什么使用OpenSessionInView1&lt;filter-name&gt;openSessionInViewFilter&lt;/filter-name&gt; 当hibernate+spring配合使用的时候，如果设置了lazy=true,那么在读取数据的时候，当读取了父数据后，hibernate会自动关闭session，这样，当要使用子数据的时候，系统会抛出lazyinit的错误，这时就需要使用spring提供的 OpenSessionInViewFilter,OpenSessionInViewFilter主要是保持Session状态知道request将全部页面发送到客户端，这样就可以解决延迟加载带来的问题 applicationContext.xml配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"? &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" &lt;!-- 自动扫描与装配bean，扫描web包，将带有注解的类纳入spring容器管理 --&gt; &lt;!-- &lt;context:component-scan base-package="cn.itcast.oa"&gt;作用 Spring容器初始化时，会扫描cn.itcast.oa目录下标有@Component；@Service；@Controller；@Repository 注解的类纳入Spring容器管理 在类上，使用以下注解，实现bean的声明： @Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service 用于标注业务层组件 @Controller 用于标注控制层组件（如springMvc的controller，struts中的action） @Repository用于标注数据访问组件，即DAO组件 在类的成员变量上，使用以下注解，实现属性的自动装配 @Autowired ：按类的类型进行装配 @Resource： 1.如果同时指定了name和type，那么从Spring上下文中找到唯一匹配的bean进行装配 2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 3.如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 4.如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； --&gt; &lt;context:component-scan base-package="cn.itcast.oa"&gt;&lt;/context:component-scan&gt; &lt;!-- 加载外部的properties配置文件（引入jdbc的配置文件） -- &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置数据库连接池（c3p0）这个可以在hibernate.cfg.xml中配置 -- &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 基本信息 ：jdbc的url、驱动名、数据库名字、密码-- &lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;!-- 其他配置 -- &lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 -- &lt;property name="initialPoolSize" value="3"&gt;&lt;/property&gt; &lt;!--连接池中保留的最小连接数。Default: 3 -- &lt;property name="minPoolSize" value="3"&gt;&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 -- &lt;property name="maxPoolSize" value="5"&gt;&lt;/property&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 -- &lt;property name="acquireIncrement" value="3"&gt;&lt;/property&gt;&lt;!-- 控制数据源内加载的PreparedStatements数量。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 -- &lt;property name="maxStatements" value="8"&gt;&lt;/property&gt;&lt;!-- maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 -- &lt;property name="maxStatementsPerConnection" value="5"&gt;&lt;/property&gt; &lt;!--最大空闲时间,1800秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 -- &lt;property name="maxIdleTime" value="1800"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory （把数据源注入给session工厂）、配置映射文件将Spring与hibernate初步整合起来 -- &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean" &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置声明式的事务管理（采用基于注解的方式） session工厂注入到事务管理器transactionManager使Spring与Hinbernate整合实现业务逻辑 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager" &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;/beans&gt; 常见问题 自动装配与扫描有问题，context的命名空间的问题1&lt;context:component-scan base-package="cn.itcast.oa"&gt;&lt;/context:component-scan&gt; &lt;beans xmlns=”http://www.springframework.org/schema/beans“ xmlns:context=”http://www.springframework.org/schema/context“ ssh整合及项目实例项目实例链接:https://github.com/LFstefan/JavaEE]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Struts</tag>
        <tag>Hibernate</tag>
        <tag>Spring</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初心]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%88%9D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[引言 2017-04-29是我阳历的生日，同时也是我第一个博客的诞辰！初心是为了能有一个可以记录自己在代码中的成长过程的空间，同时也希望能够发挥自己的一些微不足道的能力去帮助一些人，在此过程中不断提高自己。——————一只奋进的小菜鸟 随笔 起因其实可以追溯到一篇微博，内容讲述了为什么程序员要写博客，作者文笔着实不错，让我看着动了心，回想起从前码代码的日子，经历过好多的坑，走过好多的弯路，一直想可以把自己心得或者当时的想法，做法记录下来，以后可以回头看看自己当初犯过那些错，走过那些弯路，警醒一下自己，同时也可以提醒同在路上的人不要重蹈我的覆辙，为他人尽自己的一丝绵薄之力。 本人小小一程序员菜鸟，无意间对编程产生了浓厚的兴趣，遂开始了码代码的日子，由于起步较晚，基础也薄弱，希望以后的日子有幸能看我文章的小伙伴不要吝啬你们的口水，为我提出宝贵的意见，更希望各位大牛心情愉悦之际能指点一二，同路的菜鸟我们相互交流，共同学习，一起奋进！]]></content>
      <categories>
        <category>初心</category>
      </categories>
      <tags>
        <tag>初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>